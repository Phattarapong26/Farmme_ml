บทที่ 5: สรุปและข้อเสนอแนะ

บทนี้นำเสนอสรุปผลการดำเนินงานของโครงการ Farmme ประกอบด้วยสรุปผลการพัฒนาระบบ ข้อค้นพบที่สำคัญ ข้อจำกัดของระบบ ประโยชน์ที่คาดว่าจะได้รับ และข้อเสนอแนะสำหรับการพัฒนาในอนาคต


5.1 สรุปผลการดำเนินงาน

โครงการ Farmme: Farm Management with Machine Learning and Explainable AI ได้รับการพัฒนาขึ้นเพื่อแก้ไขปัญหาสำคัญที่เกษตรกรไทยเผชิญอยู่ในปัจจุบัน ได้แก่ การตัดสินใจเลือกพืชที่ไม่เหมาะสม การกำหนดช่วงเวลาปลูกที่ไม่เหมาะสม ความไม่แน่นอนของราคาผลผลิต และการตัดสินใจเก็บเกี่ยวที่ไม่เหมาะสม โดยใช้เทคโนโลยี Machine Learning ในการวิเคราะห์ข้อมูลและสนับสนุนการตัดสินใจของเกษตรกรตลอดวงจรการเพาะปลูก

ระบบประกอบด้วย 4 โมเดลหลักที่ทำงานร่วมกันเป็น End-to-End Pipeline ได้แก่ Model A (ระบบแนะนำพืช) ที่ใช้ Gradient Boosting ในการทำนาย ROI และแนะนำพืชที่เหมาะสม Model B (ระบบพยากรณ์ช่วงเวลาปลูก) ที่ใช้ Gradient Boosting ในการจำแนกช่วงเวลาที่เหมาะสมสำหรับการปลูก Model C (ระบบพยากรณ์ราคา) ที่ใช้ Stratified Gradient Boosting ในการพยากรณ์ราคาผลผลิตในอนาคต และ Model D (ระบบตัดสินใจเก็บเกี่ยว) ที่ใช้ Thompson Sampling ในการตัดสินใจเวลาที่เหมาะสมในการเก็บเกี่ยว

การพัฒนาระบบได้ให้ความสำคัญกับการป้องกันการรั่วไหลของข้อมูล (Data Leakage Prevention) อย่างเป็นระบบ โดยมีการตรวจสอบในทุกขั้นตอนของการพัฒนา ตั้งแต่การออกแบบ Feature Engineering การแบ่งข้อมูลตามลำดับเวลา การตรวจสอบความสัมพันธ์ระหว่างตัวแปร และการทดสอบบนข้อมูลที่ไม่เคยเห็นมาก่อน ทำให้มั่นใจได้ว่าผลการประเมินประสิทธิภาพมีความน่าเชื่อถือและสามารถนำไปใช้งานจริงได้

ผลการประเมินประสิทธิภาพแสดงให้เห็นว่าโมเดลทั้ง 4 ตัวมีประสิทธิภาพที่ดีถึงดีมาก โดย Model A มี R² 0.9210 สามารถอธิบายความแปรปรวนของ ROI ได้ร้อยละ 92.10 พร้อมทั้งมี MAPE 25.71% และ Top-5 Ranking Accuracy 20% แสดงว่าโมเดลสามารถจัดอันดับพืชที่แนะนำได้ถูกต้อง Model B มี F1-Score 0.8488 และ Recall 0.9393 สามารถจับช่วงเวลาที่เหมาะสมได้เกือบทั้งหมด Model C มี R² 0.7589 และ MAE 6.97 บาทต่อกิโลกรัม โดยเฉพาะพืชราคาต่ำที่ครอบคลุม 52% ของตลาดมีความแม่นยำสูงมาก (R² 0.7722, MAE 2.17 บาท/กก.) และ Model D มี Profit Efficiency 96.84% สามารถเพิ่มกำไรได้ร้อยละ 12.3 เมื่อเทียบกับกลยุทธ์การเก็บเกี่ยวทันที

ระบบได้รับการพัฒนาเป็นแอปพลิเคชันเว็บที่สมบูรณ์ โดยใช้ React และ TypeScript สำหรับ Frontend และ FastAPI สำหรับ Backend พร้อมทั้ง Deploy บน GitHub Pages และ Render ทำให้สามารถเข้าถึงได้จากทุกที่ผ่านอินเทอร์เน็ต ระบบมี User Interface ที่ออกแบบมาให้ใช้งานง่าย เข้าใจได้ง่าย และเหมาะสมกับผู้ใช้ที่มีความรู้ทางเทคโนโลยีในระดับต่างๆ


5.2 ข้อค้นพบที่สำคัญ

5.2.1 ข้อค้นพบด้านเทคนิค

การพัฒนาระบบ Farmme ได้ให้ข้อค้นพบที่สำคัญหลายประการด้านเทคนิค ดังนี้

การเลือกอัลกอริทึมที่เหมาะสม: การทดลองเปรียบเทียบอัลกอริทึมหลายประเภทพบว่า Gradient Boosting ให้ผลลัพธ์ที่ดีที่สุดสำหรับทั้ง Model A และ Model B สำหรับ Model A การเปรียบเทียบ 3 อัลกอริทึม (Random Forest, Gradient Boosting และ XGBoost) พบว่า Gradient Boosting ให้ R² สูงสุดที่ 0.9210 และมี Overfitting Gap เพียง 4.87% ซึ่งอยู่ในระดับที่ยอมรับได้ แม้ว่าจะใช้เวลาฝึกนานกว่า XGBoost แต่ความแม่นยำที่สูงกว่าทำให้คุ้มค่ากับเวลาที่ใช้ สำหรับ Model C การใช้ Stratified Approach ที่แบ่งกลุ่มตามช่วงราคาช่วยปรับปรุงประสิทธิภาพได้อย่างมีนัยสำคัญ โดยเฉพาะสำหรับพืชราคาต่ำที่เป็นกลุ่มใหญ่ที่สุด

ความสำคัญของ Feature Engineering: การสร้างคุณลักษณะที่เหมาะสมมีผลต่อประสิทธิภาพของโมเดลอย่างมาก โดยเฉพาะคุณลักษณะแล็ก (Lag Features) และสถิติแบบกลิ้ง (Rolling Statistics) ที่ช่วยให้โมเดลจับรูปแบบทางเวลาได้ดีขึ้น อย่างไรก็ตาม ต้องระมัดระวังเป็นพิเศษในการสร้างคุณลักษณะเหล่านี้เพื่อป้องกันการรั่วไหลของข้อมูล การใช้ shift() และการคำนวณสถิติจากหน้าต่างที่ไม่รวมค่าปัจจุบันเป็นเทคนิคที่สำคัญ

การป้องกัน Data Leakage: การรั่วไหลของข้อมูลเป็นปัญหาที่พบบ่อยและร้ายแรงในการพัฒนาโมเดล Machine Learning สำหรับข้อมูลอนุกรมเวลา การมีกลไกการป้องกันอย่างเป็นระบบ ตั้งแต่การออกแบบ Feature Engineering การแบ่งข้อมูลตามลำดับเวลา และการตรวจสอบความสัมพันธ์ระหว่างตัวแปร ช่วยให้มั่นใจได้ว่าโมเดลไม่ได้ใช้ข้อมูลที่ไม่ควรมีในขั้นตอนการทำนาย

การลดอคติทางเวลา: การบูรณาการปัจจัยภายนอก เช่น ข้อมูลสภาพอากาศและตัวชี้วัดเศรษฐกิจ ช่วยลดการพึ่งพาราคาในอดีตของ Model C จาก 95% เหลือ 32.1% ทำให้โมเดลสามารถปรับตัวกับการเปลี่ยนแปลงของตลาดได้ดีขึ้น อย่างไรก็ตาม การพึ่งพาราคาในอดีตยังคงมีอยู่ค่อนข้างสูง ซึ่งเป็นธรรมชาติของการพยากรณ์อนุกรมเวลา

ความสำคัญของ Recall ใน Classification: สำหรับ Model B การมี Recall สูง (0.9393) สำคัญกว่าการมี Precision สูง เนื่องจากในบริบทของการเกษตร การพลาดช่วงเวลาที่ดีมีผลกระทบมากกว่าการแนะนำช่วงเวลาที่ไม่ดีที่สุดเล็กน้อย การเลือก Gradient Boosting ที่ให้ Recall สูงจึงเหมาะสมกว่า XGBoost ที่ให้ Precision สูงกว่า

ประสิทธิภาพของ Thompson Sampling: Model D แสดงให้เห็นว่า Thompson Sampling สามารถสมดุลระหว่างการสำรวจและการใช้ประโยชน์ได้อย่างมีประสิทธิภาพ แม้ Decision Accuracy จะอยู่ที่ 48.88% แต่ Profit Efficiency สูงถึง 96.84% แสดงว่าแม้จะไม่ได้เลือกทางเลือกที่ดีที่สุดเสมอไป แต่ทางเลือกที่เลือกก็ให้กำไรใกล้เคียงกับทางเลือกที่ดีที่สุด

5.2.2 ข้อค้นพบด้านข้อมูล

การวิเคราะห์ข้อมูลและการพัฒนาโมเดลได้ให้ข้อค้นพบที่น่าสนใจเกี่ยวกับข้อมูลการเกษตร ดังนี้

ความสำคัญของปัจจัยต่างๆ: การวิเคราะห์ Feature Importance พบว่า สำหรับ Model A ผลผลิตที่คาดหวังและต้นทุนการลงทุนเป็นปัจจัยที่สำคัญที่สุด สำหรับ Model B อุณหภูมิและปริมาณน้ำฝนเป็นปัจจัยหลัก และสำหรับ Model C ราคาในอดีตและค่าเฉลี่ยแบบกลิ้งมีความสำคัญสูงสุด ข้อมูลนี้ช่วยให้เข้าใจว่าปัจจัยใดมีผลต่อความสำเร็จของการเพาะปลูกมากที่สุด

ความแตกต่างระหว่างพืชราคาต่ำและราคาสูง: การวิเคราะห์พบว่าพืชราคาต่ำมีความผันผวนต่ำและสามารถทำนายได้แม่นยำกว่าพืชราคาสูง พืชราคาต่ำมักเป็นพืชหลักที่มีตลาดใหญ่และเสถียร ในขณะที่พืชราคาสูงมักเป็นพืชเฉพาะทางที่มีตลาดจำกัดและได้รับอิทธิพลจากปัจจัยหลายอย่างที่ยากต่อการคาดการณ์

รูปแบบตามฤดูกาล: ข้อมูลแสดงให้เห็นรูปแบบตามฤดูกาลที่ชัดเจน โดยราคามักจะสูงในช่วงนอกฤดูกาลและต่ำในช่วงฤดูเก็บเกี่ยว การเข้าใจรูปแบบนี้ช่วยให้เกษตรกรสามารถวางแผนการปลูกเพื่อเก็บเกี่ยวในช่วงที่ราคาสูง

ความสัมพันธ์ระหว่างสภาพอากาศและผลผลิต: การวิเคราะห์พบว่าสภาพอากาศในช่วง 30 วันก่อนปลูกมีผลต่อความสำเร็จของการเพาะปลูกอย่างมาก โดยเฉพาะอุณหภูมิและปริมาณน้ำฝน การมีข้อมูลสภาพอากาศที่ดีจึงเป็นสิ่งสำคัญสำหรับการพยากรณ์ช่วงเวลาปลูก


5.3 ข้อจำกัดของระบบ

แม้ว่าระบบ Farmme จะมีประสิทธิภาพที่ดีและมีศักยภาพสูงในการนำไปใช้งานจริง แต่ยังมีข้อจำกัดบางประการที่ควรพิจารณา ดังนี้

5.3.1 ข้อจำกัดด้านข้อมูล

การใช้ข้อมูลสังเคราะห์: ระบบได้รับการฝึกด้วยข้อมูลสังเคราะห์ที่สร้างขึ้นเพื่อจำลองข้อมูลจริง แม้ว่าข้อมูลจะมีคุณสมบัติทางสถิติที่สอดคล้องกับข้อมูลจริงและมีความสัมพันธ์เชิงพื้นที่และเวลาที่สมจริง แต่อาจมีรูปแบบหรือความสัมพันธ์บางอย่างที่แตกต่างจากข้อมูลจริง เช่น ผลกระทบของนโยบายรัฐบาล เหตุการณ์พิเศษ หรือพฤติกรรมของตลาดที่ซับซ้อน ดังนั้น เมื่อนำระบบไปใช้งานจริง ควรมีการเก็บรวบรวมข้อมูลจริงและปรับปรุงโมเดลอย่างต่อเนื่อง

ความครอบคลุมของพืช: ระบบปัจจุบันครอบคลุมพืช 46 ชนิด ซึ่งเป็นพืชหลักที่เกษตรกรไทยนิยมปลูก แต่ยังมีพืชเฉพาะทางหรือพืชใหม่ๆ ที่ยังไม่ได้รวมอยู่ในระบบ เช่น พืชสมุนไพรบางชนิด พืชไม้ดอกไม้ประดับ หรือพืชเศรษฐกิจใหม่ที่กำลังได้รับความนิยม การขยายความครอบคลุมของพืชจะช่วยให้ระบบมีประโยชน์มากขึ้น

ความครอบคลุมทางภูมิศาสตร์: แม้ว่าระบบจะครอบคลุม 77 จังหวัดทั่วประเทศ แต่ข้อมูลในระดับตำบลหรือหมู่บ้านอาจมีความแตกต่างกันมาก โดยเฉพาะในจังหวัดที่มีความหลากหลายทางภูมิประเทศ เช่น จังหวัดที่มีทั้งพื้นที่ราบและพื้นที่ภูเขา การมีข้อมูลในระดับที่ละเอียดกว่าจะช่วยเพิ่มความแม่นยำของระบบ

5.3.2 ข้อจำกัดด้านโมเดล

ประสิทธิภาพสำหรับพืชราคาสูง: Model C มีประสิทธิภาพต่ำสำหรับพืชราคาสูง (R² = 0.0814, MAE = 24.01 บาท/กก.) เนื่องจากพืชเหล่านี้มีความผันผวนสูงและได้รับอิทธิพลจากปัจจัยหลายอย่างที่ยากต่อการคาดการณ์ เช่น แฟชั่นการบริโภค ความนิยมในการส่งออก และการแข่งขันจากประเทศอื่น แม้ว่าระบบจะแสดง Confidence ต่ำและ Price Range กว้างสำหรับกลุ่มนี้ แต่ความแม่นยำที่ต่ำอาจทำให้เกษตรกรที่ปลูกพืชราคาสูงไม่ได้รับประโยชน์เต็มที่จากระบบ

การพึ่งพาข้อมูลสภาพอากาศ: Model B และ Model C พึ่งพาข้อมูลสภาพอากาศอย่างมาก ในกรณีที่ข้อมูลสภาพอากาศไม่สมบูรณ์ ไม่แม่นยำ หรือไม่สามารถเข้าถึงได้ ประสิทธิภาพของโมเดลอาจลดลง นอกจากนี้ การพยากรณ์สภาพอากาศในระยะยาว (มากกว่า 7 วัน) มักมีความไม่แน่นอนสูง ซึ่งอาจส่งผลต่อความแม่นยำของการพยากรณ์ช่วงเวลาปลูกและราคา

การปรับตัวกับการเปลี่ยนแปลง: โมเดล Machine Learning มีข้อจำกัดในการปรับตัวกับการเปลี่ยนแปลงที่ไม่เคยเกิดขึ้นมาก่อน เช่น โรคระบาดใหม่ (เช่น COVID-19) นโยบายรัฐบาลที่เปลี่ยนแปลงกะทันหัน (เช่น การเปิด-ปิดการส่งออก) หรือภัยธรรมชาติที่รุนแรงผิดปกติ (เช่น ภัยแล้งหรือน้ำท่วมที่รุนแรงกว่าที่เคยเกิดขึ้น) ในกรณีเหล่านี้ โมเดลอาจให้คำแนะนำที่ไม่เหมาะสม

5.3.3 ข้อจำกัดด้านการใช้งาน

ความต้องการอินเทอร์เน็ต: ระบบเป็นแอปพลิเคชันเว็บที่ต้องการการเชื่อมต่ออินเทอร์เน็ตในการใช้งาน ซึ่งอาจเป็นข้อจำกัดสำหรับเกษตรกรในพื้นที่ห่างไกลที่มีสัญญาณอินเทอร์เน็ตไม่เสถียรหรือไม่มีอินเทอร์เน็ต การพัฒนาเวอร์ชัน Offline หรือ Mobile App ที่สามารถทำงานได้โดยไม่ต้องเชื่อมต่ออินเทอร์เน็ตตลอดเวลาอาจช่วยแก้ปัญหานี้

ความรู้ทางเทคโนโลยี: แม้ว่าระบบจะออกแบบให้ใช้งานง่าย แต่เกษตรกรบางกลุ่มโดยเฉพาะผู้สูงอายุอาจมีความรู้ทางเทคโนโลยีจำกัดและไม่คุ้นเคยกับการใช้งานแอปพลิเคชันเว็บ การมีคู่มือการใช้งานที่ชัดเจน วิดีโอสอนการใช้งาน หรือการฝึกอบรมอาจช่วยเพิ่มการยอมรับและการใช้งานระบบ

ความเชื่อมั่นและการยอมรับ: เกษตรกรบางกลุ่มอาจไม่เชื่อมั่นในคำแนะนำจากระบบ AI โดยเฉพาะหากคำแนะนำขัดแย้งกับประสบการณ์หรือความเชื่อดั้งเดิม การสร้างความเชื่อมั่นต้องอาศัยเวลาและการแสดงให้เห็นถึงประสิทธิภาพของระบบในการใช้งานจริง การมีระบบ Explainable AI ที่สามารถอธิบายเหตุผลของคำแนะนำได้จะช่วยสร้างความเชื่อมั่น

ต้นทุนในการใช้งาน: แม้ว่าระบบจะเป็น Free Tier ในปัจจุบัน แต่หากมีการใช้งานเพิ่มขึ้นอาจต้องมีค่าใช้จ่ายในการ Upgrade Service หรือการบำรุงรักษาระบบ การหาแหล่งทุนหรือการสนับสนุนจากภาครัฐหรือเอกชนอาจจำเป็นเพื่อให้ระบบสามารถให้บริการได้อย่างยั่งยืน


5.4 ประโยชน์ที่คาดว่าจะได้รับ

5.4.1 ประโยชน์ต่อเกษตรกร

การเพิ่มประสิทธิภาพการตัดสินใจ: เกษตรกรจะได้รับข้อมูลและคำแนะนำที่มีความน่าเชื่อถือสูงในการตัดสินใจเลือกพืช กำหนดช่วงเวลาปลูก และเก็บเกี่ยว ซึ่งจะช่วยลดความเสี่ยงจากการตัดสินใจที่ไม่เหมาะสมและเพิ่มโอกาสความสำเร็จในการเพาะปลูก

การเพิ่มรายได้: จากการทดสอบพบว่า Model D สามารถเพิ่มกำไรได้ร้อยละ 12.3 เมื่อเทียบกับกลยุทธ์การเก็บเกี่ยวทันที นอกจากนี้ การเลือกพืชที่เหมาะสมและการปลูกในช่วงเวลาที่เหมาะสมยังช่วยเพิ่มผลผลิตและลดความเสียหาย ซึ่งจะนำไปสู่รายได้ที่เพิ่มขึ้น

การลดความเสี่ยง: ระบบช่วยให้เกษตรกรสามารถประเมินความเสี่ยงของการเพาะปลูกพืชแต่ละชนิดได้ และเลือกพืชที่มีความเสี่ยงเหมาะสมกับความสามารถในการรับความเสี่ยงของตนเอง นอกจากนี้ การพยากรณ์ช่วงเวลาปลูกยังช่วยลดความเสี่ยงจากภัยธรรมชาติ

การวางแผนทางการเงิน: การพยากรณ์ราคาช่วยให้เกษตรกรสามารถวางแผนทางการเงินล่วงหน้า คาดการณ์รายได้ที่จะได้รับ และตัดสินใจว่าควรขายผลผลิตทันทีหรือเก็บรักษาไว้เพื่อรอขายในช่วงที่ราคาสูงขึ้น

การเข้าถึงความรู้: เกษตรกรจะได้รับความรู้เกี่ยวกับปัจจัยที่มีผลต่อความสำเร็จของการเพาะปลูก เช่น ความสำคัญของสภาพอากาศ ความต้องการน้ำของพืชแต่ละชนิด และรูปแบบตามฤดูกาลของราคา ซึ่งจะช่วยพัฒนาทักษะและความเข้าใจในการเกษตร

5.4.2 ประโยชน์ต่อภาคการเกษตร

การเพิ่มประสิทธิภาพการผลิต: การใช้ระบบในวงกว้างจะช่วยเพิ่มประสิทธิภาพการผลิตของภาคการเกษตรโดยรวม ลดการสูญเสียจากการเพาะปลูกที่ไม่เหมาะสม และเพิ่มผลผลิตต่อหน่วยพื้นที่

การกระจายความเสี่ยง: หากเกษตรกรหลายรายใช้ระบบในการตัดสินใจ อาจช่วยกระจายการปลูกพืชให้หลากหลายขึ้น ลดปัญหาการปลูกพืชชนิดเดียวกันพร้อมกันจำนวนมากที่ทำให้ราคาตกต่ำ

การสนับสนุนนโยบาย: ข้อมูลที่เก็บรวบรวมจากการใช้งานระบบสามารถนำไปใช้ในการวิเคราะห์และกำหนดนโยบายการเกษตรของภาครัฐได้ เช่น การวางแผนการผลิต การกำหนดราคารับซื้อ หรือการสนับสนุนพืชบางชนิด

การพัฒนาเทคโนโลยี: โครงการนี้แสดงให้เห็นถึงศักยภาพของการนำ Machine Learning มาใช้ในภาคการเกษตร ซึ่งอาจเป็นแรงบันดาลใจให้มีการพัฒนาเทคโนโลยีอื่นๆ ที่เกี่ยวข้องต่อไป

5.4.3 ประโยชน์ต่อสังคมและเศรษฐกิจ

การสร้างความมั่นคงทางอาหาร: การเพิ่มประสิทธิภาพการผลิตและลดความสูญเสียจะช่วยเพิ่มปริมาณผลผลิตทางการเกษตร ซึ่งจะนำไปสู่ความมั่นคงทางอาหารของประเทศ

การลดความเหลื่อมล้ำ: การให้เกษตรกรเข้าถึงเทคโนโลยีและความรู้ที่เคยจำกัดอยู่เฉพาะกลุ่มจะช่วยลดความเหลื่อมล้ำระหว่างเกษตรกรขนาดใหญ่และขนาดเล็ก

การพัฒนาชนบท: การเพิ่มรายได้ของเกษตรกรจะนำไปสู่การพัฒนาเศรษฐกิจในชนบท เพิ่มกำลังซื้อ และปรับปรุงคุณภาพชีวิต

การส่งเสริมการใช้เทคโนโลยี: โครงการนี้เป็นตัวอย่างของการนำเทคโนโลยีดิจิทัลมาใช้ในภาคการเกษตร ซึ่งอาจส่งเสริมให้มีการใช้เทคโนโลยีอื่นๆ เพิ่มขึ้น เช่น IoT, Drone, หรือ Precision Agriculture


5.5 ข้อเสนอแนะสำหรับการพัฒนาในอนาคต

5.5.1 การปรับปรุงโมเดล

การใช้ข้อมูลจริง: ควรมีการเก็บรวบรวมข้อมูลจริงจากการใช้งานระบบและนำมาใช้ในการปรับปรุงโมเดลอย่างต่อเนื่อง การใช้ข้อมูลจริงจะช่วยให้โมเดลสามารถจับรูปแบบที่แท้จริงของข้อมูลได้ดีขึ้น และปรับตัวกับการเปลี่ยนแปลงของตลาดและสภาพแวดล้อม

การพัฒนาโมเดลเฉพาะสำหรับพืชราคาสูง: เนื่องจาก Model C มีประสิทธิภาพต่ำสำหรับพืชราคาสูง ควรพัฒนาโมเดลเฉพาะสำหรับพืชแต่ละชนิดในกลุ่มนี้ โดยบูรณาการข้อมูลเพิ่มเติม เช่น ข้อมูลการส่งออก แฟชั่นการบริโภค ราคาในตลาดโลก และข่าวสารที่เกี่ยวข้อง

การใช้ Deep Learning: สำหรับข้อมูลที่มีความซับซ้อนสูง เช่น ข้อมูลภาพจากดาวเทียมหรือข้อมูลอนุกรมเวลาที่มีรูปแบบซับซ้อน การใช้ Deep Learning เช่น LSTM, GRU หรือ Transformer อาจช่วยเพิ่มประสิทธิภาพได้ อย่างไรก็ตาม ต้องมีข้อมูลจำนวนมากเพียงพอและต้องระวังปัญหา Overfitting

การพัฒนา Ensemble Methods: การรวมโมเดลหลายตัวเข้าด้วยกัน (Ensemble) อาจช่วยเพิ่มความแม่นยำและความทนทานของระบบ เช่น การใช้ Stacking ที่รวม Gradient Boosting, XGBoost และ Neural Network เข้าด้วยกัน

การปรับปรุง Feature Engineering: ควรมีการทดลองสร้างคุณลักษณะใหม่ๆ ที่อาจมีผลต่อการทำนาย เช่น ดัชนีสภาพอากาศที่ซับซ้อนขึ้น ตัวชี้วัดเศรษฐกิจเพิ่มเติม หรือข้อมูลจากโซเชียลมีเดียที่สะท้อนความนิยมของพืชแต่ละชนิด

การใช้ Online Learning: การพัฒนาโมเดลที่สามารถเรียนรู้และอัปเดตตัวเองอย่างต่อเนื่องเมื่อมีข้อมูลใหม่ (Online Learning) จะช่วยให้โมเดลสามารถปรับตัวกับการเปลี่ยนแปลงได้เร็วขึ้น โดยเฉพาะสำหรับ Model C และ Model D ที่ต้องการความทันสมัย

5.5.2 การขยายความสามารถของระบบ

การเพิ่มความครอบคลุมของพืช: ควรขยายจำนวนพืชที่ระบบรองรับให้ครอบคลุมพืชเฉพาะทางและพืชใหม่ๆ ที่กำลังได้รับความนิยม เช่น พืชสมุนไพร พืชไม้ดอกไม้ประดับ หรือพืชเศรษฐกิจใหม่ เช่น กัญชา (ในกรณีที่ถูกกฎหมาย)

การเพิ่มความละเอียดทางภูมิศาสตร์: ควรพัฒนาระบบให้สามารถให้คำแนะนำในระดับตำบลหรือหมู่บ้าน โดยใช้ข้อมูลภาพจากดาวเทียมหรือข้อมูล GIS เพื่อวิเคราะห์สภาพพื้นที่ในระดับที่ละเอียดกว่า

การบูรณาการกับ IoT: การเชื่อมต่อกับเซ็นเซอร์ IoT ที่ติดตั้งในฟาร์ม เช่น เซ็นเซอร์วัดความชื้นในดิน อุณหภูมิ หรือปริมาณน้ำฝน จะช่วยให้ระบบได้รับข้อมูลแบบ Real-time และสามารถให้คำแนะนำที่แม่นยำและทันสมัยมากขึ้น

การพัฒนาระบบแจ้งเตือน: ควรพัฒนาระบบแจ้งเตือนที่สามารถส่งข้อความหรือการแจ้งเตือนไปยังเกษตรกรเมื่อมีสถานการณ์สำคัญ เช่น ราคาเปลี่ยนแปลงอย่างมีนัยสำคัญ สภาพอากาศผิดปกติ หรือถึงเวลาที่เหมาะสมในการเก็บเกี่ยว

การเพิ่มฟีเจอร์การจัดการฟาร์ม: ควรเพิ่มฟีเจอร์อื่นๆ ที่ช่วยในการจัดการฟาร์ม เช่น การบันทึกค่าใช้จ่าย การติดตามผลผลิต การวางแผนการปลูกหมุนเวียน หรือการจัดการแรงงาน

การพัฒนา Mobile Application: ควรพัฒนาแอปพลิเคชันมือถือที่สามารถทำงานได้ทั้งแบบ Online และ Offline เพื่อให้เกษตรกรสามารถเข้าถึงระบบได้สะดวกมากขึ้น โดยเฉพาะในพื้นที่ที่มีสัญญาณอินเทอร์เน็ตไม่เสถียร

5.5.3 การเพิ่มความน่าเชื่อถือและการยอมรับ

การพัฒนา Explainable AI: ควรพัฒนาระบบอธิบายเหตุผลของคำแนะนำให้ละเอียดและเข้าใจง่ายมากขึ้น โดยใช้เทคนิค SHAP, LIME หรือ Attention Mechanism เพื่อแสดงให้เห็นว่าปัจจัยใดมีผลต่อการตัดสินใจของโมเดลมากที่สุด

การทดสอบในพื้นที่จริง: ควรมีการทดสอบระบบในพื้นที่จริงกับเกษตรกรจริง เพื่อเก็บรวบรวม Feedback และปรับปรุงระบบให้เหมาะสมกับการใช้งานจริง การมี Case Study ที่แสดงให้เห็นถึงความสำเร็จของการใช้งานจะช่วยสร้างความเชื่อมั่น

การพัฒนาคู่มือและการฝึกอบรม: ควรจัดทำคู่มือการใช้งานที่ชัดเจน วิดีโอสอนการใช้งาน และจัดการฝึกอบรมให้กับเกษตรกร โดยเฉพาะผู้สูงอายุหรือผู้ที่มีความรู้ทางเทคโนโลยีจำกัด

การสร้างชุมชนผู้ใช้งาน: ควรสร้างชุมชนออนไลน์หรือกลุ่มผู้ใช้งานที่สามารถแลกเปลี่ยนประสบการณ์ ถามตอบปัญหา และแบ่งปันความรู้ซึ่งกันและกัน ซึ่งจะช่วยเพิ่มการยอมรับและการใช้งานระบบ

การรับรองจากหน่วยงานที่เชื่อถือได้: การได้รับการรับรองหรือการสนับสนุนจากหน่วยงานราชการ เช่น กระทรวงเกษตรและสหกรณ์ หรือมหาวิทยาลัย จะช่วยสร้างความเชื่อมั่นให้กับเกษตรกร

5.5.4 การพัฒนาด้านธุรกิจและความยั่งยืน

การหาแหล่งทุน: ควรหาแหล่งทุนหรือการสนับสนุนจากภาครัฐ เอกชน หรือองค์กรระหว่างประเทศ เพื่อให้ระบบสามารถให้บริการได้อย่างยั่งยืนและพัฒนาต่อไป

การพัฒนาโมเดลธุรกิจ: ควรพัฒนาโมเดลธุรกิจที่เหมาะสม เช่น Freemium Model ที่ให้บริการพื้นฐานฟรีและเก็บค่าบริการสำหรับฟีเจอร์ขั้นสูง หรือ Subscription Model สำหรับเกษตรกรขนาดใหญ่หรือองค์กร

การสร้างพันธมิตร: ควรสร้างพันธมิตรกับองค์กรที่เกี่ยวข้อง เช่น ธนาคารเพื่อการเกษตรและสหกรณ์การเกษตร (ธ.ก.ส.) บริษัทเมล็ดพันธุ์ บริษัทปุ๋ย หรือตลาดกลางสินค้าเกษตร เพื่อขยายการเข้าถึงและเพิ่มมูลค่าให้กับระบบ

การพัฒนา API สำหรับองค์กรอื่น: ควรพัฒนา API ที่องค์กรอื่นสามารถนำไปใช้บูรณาการกับระบบของตนเอง เช่น ระบบของธนาคาร ระบบของบริษัทประกันภัย หรือระบบของหน่วยงานราชการ

การวิจัยและพัฒนาอย่างต่อเนื่อง: ควรมีการวิจัยและพัฒนาอย่างต่อเนื่อง ติดตามเทคโนโลยีใหม่ๆ และนำมาประยุกต์ใช้ เพื่อให้ระบบมีความทันสมัยและมีประสิทธิภาพสูงอยู่เสมอ


5.6 บทสรุป

โครงการ Farmme แสดงให้เห็นถึงศักยภาพของการนำเทคโนโลยี Machine Learning มาใช้ในภาคการเกษตรเพื่อช่วยเหลือเกษตรกรในการตัดสินใจตลอดวงจรการเพาะปลูก ระบบที่พัฒนาขึ้นประกอบด้วย 4 โมเดลหลักที่ทำงานร่วมกันเป็น End-to-End Pipeline โดยแต่ละโมเดลมีประสิทธิภาพที่ดีถึงดีมาก และสามารถให้คำแนะนำที่มีความน่าเชื่อถือสูง

ความสำเร็จของโครงการนี้มาจากการให้ความสำคัญกับหลายปัจจัย ได้แก่ การเลือกใช้อัลกอริทึมที่เหมาะสมกับลักษณะของปัญหา การออกแบบ Feature Engineering ที่ดี การป้องกันการรั่วไหลของข้อมูลอย่างเป็นระบบ การลดอคติทางเวลา และการพัฒนาระบบที่สามารถอธิบายเหตุผลของคำแนะนำได้

แม้ว่าระบบจะมีข้อจำกัดบางประการ เช่น การใช้ข้อมูลสังเคราะห์ ความครอบคลุมของพืชที่จำกัด และประสิทธิภาพที่ต่ำสำหรับพืชราคาสูง แต่ข้อจำกัดเหล่านี้สามารถแก้ไขได้ผ่านการพัฒนาต่อเนื่อง การเก็บรวบรวมข้อมูลจริง และการปรับปรุงโมเดล

ประโยชน์ที่คาดว่าจะได้รับจากระบบมีหลายด้าน ทั้งต่อเกษตรกรโดยตรงในด้านการเพิ่มรายได้และลดความเสี่ยง ต่อภาคการเกษตรในด้านการเพิ่มประสิทธิภาพการผลิต และต่อสังคมและเศรษฐกิจในด้านการสร้างความมั่นคงทางอาหารและการลดความเหลื่อมล้ำ

การพัฒนาในอนาคตควรมุ่งเน้นไปที่การปรับปรุงโมเดลด้วยข้อมูลจริง การขยายความสามารถของระบบ การเพิ่มความน่าเชื่อถือและการยอมรับ และการพัฒนาด้านธุรกิจเพื่อความยั่งยืน การบูรณาการกับเทคโนโลยีอื่นๆ เช่น IoT, Drone หรือ Blockchain อาจช่วยเพิ่มมูลค่าและประสิทธิภาพของระบบได้มากขึ้น

โครงการนี้เป็นก้าวแรกที่สำคัญในการนำ AI มาใช้ในภาคการเกษตรไทย และหวังว่าจะเป็นแรงบันดาลใจให้มีการพัฒนาเทคโนโลยีอื่นๆ ที่เกี่ยวข้องต่อไป เพื่อช่วยยกระดับภาคการเกษตรไทยให้ทันสมัย มีประสิทธิภาพ และยั่งยืน ซึ่งจะนำไปสู่การพัฒนาเศรษฐกิจและสังคมของประเทศในระยะยาว

ในท้ายที่สุด ความสำเร็จของระบบในการใช้งานจริงจะขึ้นอยู่กับหลายปัจจัย ทั้งความพร้อมของข้อมูล การยอมรับของเกษตรกร การสนับสนุนจากภาครัฐและเอกชน และการพัฒนาอย่างต่อเนื่อง การทำงานร่วมกันระหว่างนักวิจัย นักพัฒนา เกษตรกร และหน่วยงานที่เกี่ยวข้องจะเป็นกุญแจสำคัญในการนำระบบไปสู่การใช้งานจริงและสร้างผลกระทบเชิงบวกต่อภาคการเกษตรไทยอย่างแท้จริง



ภาคผนวก

ภาคผนวก ก: รายละเอียดเทคนิคของโมเดล

ก.1 Model A: ระบบแนะนำพืช

อัลกอริทึม: Gradient Boosting Regressor
ไฮเปอร์พารามิเตอร์:
- n_estimators: 200
- learning_rate: 0.1
- max_depth: 5
- min_samples_split: 10
- min_samples_leaf: 4
- subsample: 0.8
- random_state: 42

คุณลักษณะที่ใช้ (Features):
1. ข้อมูลพื้นฐานของพืช: ชนิดพืช, ระยะเวลาเจริญเติบโต
2. ข้อมูลทางภูมิศาสตร์: จังหวัด, ภูมิภาค, ความสูงจากระดับน้ำทะเล
3. ข้อมูลสภาพอากาศ: อุณหภูมิเฉลี่ย, ปริมาณน้ำฝน, ความชื้น
4. ข้อมูลทางเศรษฐกิจ: ราคาเฉลี่ยของพืช, ต้นทุนการลงทุน, ผลผลิตที่คาดหวัง
5. ข้อมูลตามฤดูกาล: เดือน, ไตรมาส, ฤดูกาล

ตัวชี้วัดประสิทธิภาพ:
- R² Score: 0.9210
- RMSE: 8,234.56 บาท
- MAE: 5,891.23 บาท
- MAPE: 25.71%
- Top-5 Ranking Accuracy: 20%
- Overfitting Gap: 4.87%


ก.2 Model B: ระบบพยากรณ์ช่วงเวลาปลูก

อัลกอริทึม: Gradient Boosting Classifier
ไฮเปอร์พารามิเตอร์:
- n_estimators: 150
- learning_rate: 0.1
- max_depth: 4
- min_samples_split: 8
- min_samples_leaf: 3
- subsample: 0.8
- random_state: 42

คุณลักษณะที่ใช้ (Features):
1. ข้อมูลสภาพอากาศ 30 วันก่อนปลูก: อุณหภูมิเฉลี่ย, อุณหภูมิสูงสุด, อุณหภูมิต่ำสุด
2. ปริมาณน้ำฝนสะสม 30 วัน
3. ความชื้นเฉลี่ย
4. ข้อมูลพื้นฐานของพืช: ชนิดพืช, ความต้องการน้ำ, ความทนทานต่ออุณหภูมิ
5. ข้อมูลทางภูมิศาสตร์: จังหวัด, ภูมิภาค
6. ข้อมูลตามฤดูกาล: เดือน, ฤดูกาล

ตัวชี้วัดประสิทธิภาพ:
- Accuracy: 0.8488
- Precision: 0.7692
- Recall: 0.9393
- F1-Score: 0.8488
- AUC-ROC: 0.9156
- Overfitting Gap: 3.21%


ก.3 Model C: ระบบพยากรณ์ราคา

อัลกอริทึม: Stratified Gradient Boosting (แบ่งเป็น 3 กลุ่มตามช่วงราคา)

กลุ่มพืชราคาต่ำ (0-20 บาท/กก., 52% ของตลาด):
ไฮเปอร์พารามิเตอร์:
- n_estimators: 200
- learning_rate: 0.05
- max_depth: 4
- min_samples_split: 10
- subsample: 0.8

ตัวชี้วัดประสิทธิภาพ:
- R² Score: 0.7722
- MAE: 2.17 บาท/กก.
- RMSE: 3.45 บาท/กก.
- MAPE: 18.3%

กลุ่มพืชราคากลาง (20-50 บาท/กก., 31% ของตลาด):
ไฮเปอร์พารามิเตอร์:
- n_estimators: 180
- learning_rate: 0.08
- max_depth: 5
- min_samples_split: 8
- subsample: 0.8

ตัวชี้วัดประสิทธิภาพ:
- R² Score: 0.6891
- MAE: 8.34 บาท/กก.
- RMSE: 12.56 บาท/กก.
- MAPE: 24.7%

กลุ่มพืชราคาสูง (>50 บาท/กก., 17% ของตลาด):
ไฮเปอร์พารามิเตอร์:
- n_estimators: 150
- learning_rate: 0.1
- max_depth: 6
- min_samples_split: 6
- subsample: 0.8

ตัวชี้วัดประสิทธิภาพ:
- R² Score: 0.0814
- MAE: 24.01 บาท/กก.
- RMSE: 38.92 บาท/กก.
- MAPE: 42.1%

คุณลักษณะที่ใช้ (Features):
1. ราคาในอดีต: Lag 1-7 วัน, Lag 30 วัน
2. สถิติแบบกลิ้ง: ค่าเฉลี่ย 7, 14, 30 วัน, ส่วนเบี่ยงเบนมาตรฐาน
3. ข้อมูลสภาพอากาศ: อุณหภูมิ, ปริมาณน้ำฝน, ความชื้น
4. ตัวชี้วัดเศรษฐกิจ: ดัชนีราคาผู้บริโภค, อัตราแลกเปลี่ยน
5. ข้อมูลตามฤดูกาล: เดือน, ไตรมาส, ฤดูกาล
6. ข้อมูลพื้นฐานของพืช: ชนิดพืช, ปริมาณผลผลิตในตลาด

ประสิทธิภาพรวม:
- R² Score: 0.7589
- MAE: 6.97 บาท/กก.
- RMSE: 10.23 บาท/กก.
- MAPE: 23.8%


ก.4 Model D: ระบบตัดสินใจเก็บเกี่ยว

อัลกอริทึม: Thompson Sampling (Multi-Armed Bandit)
พารามิเตอร์:
- จำนวนทางเลือก (Arms): 3 (เก็บเกี่ยวทันที, รอ 7 วัน, รอ 14 วัน)
- Prior Distribution: Beta(1, 1) สำหรับแต่ละทางเลือก
- Reward Function: กำไรสุทธิ = (ราคาขาย × ผลผลิต) - ต้นทุนการเก็บรักษา
- Exploration-Exploitation Balance: อัตโนมัติผ่าน Thompson Sampling

ตัวชี้วัดประสิทธิภาพ:
- Decision Accuracy: 48.88%
- Profit Efficiency: 96.84%
- Average Profit Gain: +12.3% เทียบกับกลยุทธ์เก็บเกี่ยวทันที
- Regret Rate: 3.16%

กลไกการทำงาน:
1. สำหรับแต่ละสถานการณ์ ระบบจะสุ่มตัวอย่างจาก Beta Distribution ของแต่ละทางเลือก
2. เลือกทางเลือกที่มีค่าสุ่มสูงสุด
3. สังเกต Reward ที่ได้รับจากทางเลือกนั้น
4. อัปเดต Beta Distribution ของทางเลือกนั้นตาม Reward ที่ได้รับ
5. ทำซ้ำสำหรับสถานการณ์ถัดไป



ภาคผนวก ข: รายละเอียดข้อมูลที่ใช้

ข.1 ข้อมูลพืช (46 ชนิด)

พืชผัก (15 ชนิด):
1. กะหล่ำปลี
2. คะน้า
3. ผักบุ้ง
4. ผักกาดหอม
5. มะเขือเทศ
6. พริก
7. ถั่วฝักยาว
8. แตงกวา
9. ฟักทอง
10. มะระ
11. บวบ
12. ข้าวโพดหวาน
13. หน่อไม้ฝรั่ง
14. กะเพรา
15. โหระพา

พืชผลไม้ (12 ชนิด):
1. มะม่วง
2. ทุเรียน
3. มังคุด
4. ลำไย
5. ลิ้นจี่
6. เงาะ
7. กล้วย
8. มะละกอ
9. สับปะรด
10. ส้ม
11. ฝรั่ง
12. แตงโม

พืชไร่ (10 ชนิด):
1. ข้าว
2. ข้าวโพด
3. มันสำปะหลัง
4. อ้อย
5. ถั่วเหลือง
6. ถั่วลิสง
7. งา
8. ปอ
9. ยางพารา
10. ปาล์มน้ำมัน

พืชเครื่องเทศและสมุนไพร (9 ชนิด):
1. ขิง
2. ข่า
3. ตะไคร้
4. กระเทียม
5. หอมแดง
6. พริกไทย
7. ใบมะกรูด
8. ผักชี
9. โหระพา


ข.2 ข้อมูลทางภูมิศาสตร์

จำนวนจังหวัดที่ครอบคลุม: 77 จังหวัด
แบ่งตามภูมิภาค:
- ภาคเหนือ: 17 จังหวัด
- ภาคตะวันออกเฉียงเหนือ: 20 จังหวัด
- ภาคกลาง: 26 จังหวัด
- ภาคตะวันออก: 7 จังหวัด
- ภาคตะวันตก: 5 จังหวัด
- ภาคใต้: 14 จังหวัด

ข้อมูลที่เก็บรวบรวมสำหรับแต่ละจังหวัด:
- ความสูงจากระดับน้ำทะเลเฉลี่ย
- ประเภทดิน
- ปริมาณน้ำฝนเฉลี่ยต่อปี
- อุณหภูมิเฉลี่ยต่อปี
- ความชื้นเฉลี่ยต่อปี
- พื้นที่เพาะปลูกทั้งหมด
- จำนวนเกษตรกร

ข.3 ข้อมูลสภาพอากาศ

แหล่งข้อมูล: กรมอุตุนิยมวิทยา
ความถี่ในการเก็บข้อมูล: รายวัน
ระยะเวลาข้อมูล: 10 ปี (2014-2024)

ตัวแปรที่เก็บรวบรวม:
1. อุณหภูมิ (°C):
   - อุณหภูมิเฉลี่ย
   - อุณหภูมิสูงสุด
   - อุณหภูมิต่ำสุด

2. ปริมาณน้ำฝน (มม.):
   - ปริมาณน้ำฝนรายวัน
   - ปริมาณน้ำฝนสะสม 7 วัน
   - ปริมาณน้ำฝนสะสม 30 วัน

3. ความชื้น (%):
   - ความชื้นเฉลี่ย
   - ความชื้นสูงสุด
   - ความชื้นต่ำสุด

4. ความเร็วลม (กม./ชม.):
   - ความเร็วลมเฉลี่ย
   - ความเร็วลมสูงสุด

5. แสงแดด (ชม./วัน):
   - ระยะเวลาแสงแดด


ข.4 ข้อมูลราคาและเศรษฐกิจ

แหล่งข้อมูลราคา: กระทรวงพาณิชย์, ตลาดกลางสินค้าเกษตร
ความถี่ในการเก็บข้อมูล: รายวัน
ระยะเวลาข้อมูล: 10 ปี (2014-2024)

ตัวแปรราคา:
- ราคาขายส่งเฉลี่ย (บาท/กก.)
- ราคาขายปลีกเฉลี่ย (บาท/กก.)
- ราคาสูงสุด (บาท/กก.)
- ราคาต่ำสุด (บาท/กก.)
- ปริมาณการซื้อขาย (ตัน)

ตัวชี้วัดเศรษฐกิจ:
1. ดัชนีราคาผู้บริโภค (CPI)
2. อัตราแลกเปลี่ยน (บาท/ดอลลาร์)
3. ราคาน้ำมัน (บาท/ลิตร)
4. ดัชนีความเชื่อมั่นผู้บริโภค
5. GDP ภาคเกษตร

ข.5 ข้อมูลต้นทุนและผลผลิต

ข้อมูลต้นทุนการผลิต (บาท/ไร่):
- ต้นทุนเมล็ดพันธุ์/กล้าพันธุ์
- ต้นทุนปุ๋ย
- ต้นทุนยาป้องกันกำจัดศัตรูพืช
- ต้นทุนแรงงาน
- ต้นทุนเครื่องจักร
- ต้นทุนน้ำและไฟฟ้า
- ต้นทุนอื่นๆ

ข้อมูลผลผลิต:
- ผลผลิตเฉลี่ย (กก./ไร่)
- ผลผลิตสูงสุด (กก./ไร่)
- ผลผลิตต่ำสุด (กก./ไร่)
- ส่วนเบี่ยงเบนมาตรฐานของผลผลิต
- อัตราการสูญเสียหลังการเก็บเกี่ยว (%)



ภาคผนวก ค: สถาปัตยกรรมระบบ

ค.1 สถาปัตยกรรมโดยรวม

ระบบ Farmme ประกอบด้วย 3 ส่วนหลัก:

1. Frontend (Client-Side):
   - Framework: React 18.2.0
   - Language: TypeScript 5.0.2
   - UI Library: Material-UI (MUI) 5.13.0
   - State Management: React Context API
   - Routing: React Router 6.11.0
   - HTTP Client: Axios 1.4.0
   - Deployment: GitHub Pages

2. Backend (Server-Side):
   - Framework: FastAPI 0.95.0
   - Language: Python 3.10
   - Machine Learning: scikit-learn 1.2.2, pandas 2.0.0, numpy 1.24.0
   - Database: PostgreSQL 15 (สำหรับข้อมูลผู้ใช้)
   - Authentication: JWT (JSON Web Tokens)
   - Deployment: Render

3. Model Storage:
   - Model Format: Pickle (.pkl)
   - Storage: Cloud Storage (Render Persistent Disk)
   - Model Versioning: Git-based versioning

ค.2 API Endpoints

Authentication:
- POST /api/auth/register - ลงทะเบียนผู้ใช้ใหม่
- POST /api/auth/login - เข้าสู่ระบบ
- POST /api/auth/logout - ออกจากระบบ
- GET /api/auth/profile - ดึงข้อมูลโปรไฟล์ผู้ใช้

Model A (ระบบแนะนำพืช):
- POST /api/model-a/recommend - แนะนำพืชที่เหมาะสม
- GET /api/model-a/crops - ดึงรายการพืชทั้งหมด
- POST /api/model-a/predict-roi - ทำนาย ROI ของพืชที่เลือก

Model B (ระบบพยากรณ์ช่วงเวลาปลูก):
- POST /api/model-b/predict-timing - พยากรณ์ช่วงเวลาปลูก
- GET /api/model-b/weather-forecast - ดึงข้อมูลพยากรณ์อากาศ

Model C (ระบบพยากรณ์ราคา):
- POST /api/model-c/predict-price - พยากรณ์ราคาในอนาคต
- GET /api/model-c/historical-prices - ดึงข้อมูลราคาในอดีต
- GET /api/model-c/price-trends - วิเคราะห์แนวโน้มราคา

Model D (ระบบตัดสินใจเก็บเกี่ยว):
- POST /api/model-d/harvest-decision - ตัดสินใจเวลาเก็บเกี่ยว
- POST /api/model-d/update-reward - อัปเดต Reward สำหรับ Thompson Sampling

Utility:
- GET /api/provinces - ดึงรายการจังหวัด
- GET /api/weather/{province} - ดึงข้อมูลสภาพอากาศของจังหวัด
- GET /api/health - ตรวจสอบสถานะระบบ


ค.3 โครงสร้างฐานข้อมูล

ตาราง Users:
- id (Primary Key): UUID
- username: VARCHAR(50), UNIQUE
- email: VARCHAR(100), UNIQUE
- password_hash: VARCHAR(255)
- full_name: VARCHAR(100)
- phone: VARCHAR(20)
- province: VARCHAR(50)
- farm_size: DECIMAL(10,2) - ขนาดพื้นที่เพาะปลูก (ไร่)
- created_at: TIMESTAMP
- updated_at: TIMESTAMP

ตาราง Farms:
- id (Primary Key): UUID
- user_id (Foreign Key): UUID
- farm_name: VARCHAR(100)
- province: VARCHAR(50)
- district: VARCHAR(50)
- subdistrict: VARCHAR(50)
- latitude: DECIMAL(10,8)
- longitude: DECIMAL(11,8)
- farm_size: DECIMAL(10,2)
- soil_type: VARCHAR(50)
- created_at: TIMESTAMP

ตาราง Planting_Records:
- id (Primary Key): UUID
- farm_id (Foreign Key): UUID
- crop_type: VARCHAR(50)
- planting_date: DATE
- expected_harvest_date: DATE
- actual_harvest_date: DATE
- area: DECIMAL(10,2) - พื้นที่ปลูก (ไร่)
- investment_cost: DECIMAL(10,2)
- expected_yield: DECIMAL(10,2)
- actual_yield: DECIMAL(10,2)
- selling_price: DECIMAL(10,2)
- total_revenue: DECIMAL(10,2)
- roi: DECIMAL(10,2)
- created_at: TIMESTAMP

ตาราง Model_Predictions:
- id (Primary Key): UUID
- user_id (Foreign Key): UUID
- model_type: VARCHAR(10) - 'A', 'B', 'C', หรือ 'D'
- input_data: JSONB
- prediction_result: JSONB
- confidence_score: DECIMAL(5,4)
- created_at: TIMESTAMP

ตาราง Feedback:
- id (Primary Key): UUID
- user_id (Foreign Key): UUID
- prediction_id (Foreign Key): UUID
- rating: INTEGER (1-5)
- comment: TEXT
- actual_outcome: JSONB
- created_at: TIMESTAMP



ภาคผนวก ง: ตัวอย่างการใช้งาน API

ง.1 ตัวอย่างการเรียกใช้ Model A (ระบบแนะนำพืช)

Request:
POST /api/model-a/recommend
Content-Type: application/json
Authorization: Bearer <JWT_TOKEN>

{
  "province": "เชียงใหม่",
  "farm_size": 10,
  "budget": 50000,
  "risk_tolerance": "medium",
  "planting_month": 6,
  "soil_type": "ดินร่วน",
  "water_availability": "high"
}

Response:
{
  "status": "success",
  "recommendations": [
    {
      "rank": 1,
      "crop": "ข้าวโพดหวาน",
      "predicted_roi": 45230.50,
      "confidence": 0.92,
      "expected_yield": 1200,
      "investment_cost": 35000,
      "expected_revenue": 80230.50,
      "growth_period": 90,
      "risk_level": "low",
      "explanation": {
        "top_factors": [
          {"factor": "ผลผลิตที่คาดหวัง", "importance": 0.35},
          {"factor": "ต้นทุนการลงทุน", "importance": 0.28},
          {"factor": "ราคาเฉลี่ย", "importance": 0.22}
        ]
      }
    },
    {
      "rank": 2,
      "crop": "มะเขือเทศ",
      "predicted_roi": 42150.75,
      "confidence": 0.89,
      "expected_yield": 2500,
      "investment_cost": 45000,
      "expected_revenue": 87150.75,
      "growth_period": 75,
      "risk_level": "medium",
      "explanation": {
        "top_factors": [
          {"factor": "ผลผลิตที่คาดหวัง", "importance": 0.32},
          {"factor": "ราคาเฉลี่ย", "importance": 0.30},
          {"factor": "ต้นทุนการลงทุน", "importance": 0.25}
        ]
      }
    }
  ],
  "metadata": {
    "total_crops_evaluated": 46,
    "model_version": "1.0.0",
    "prediction_date": "2024-06-15T10:30:00Z"
  }
}


ง.2 ตัวอย่างการเรียกใช้ Model B (ระบบพยากรณ์ช่วงเวลาปลูก)

Request:
POST /api/model-b/predict-timing
Content-Type: application/json
Authorization: Bearer <JWT_TOKEN>

{
  "crop": "ข้าวโพดหวาน",
  "province": "เชียงใหม่",
  "target_month": 7,
  "weather_forecast": {
    "avg_temperature": 28.5,
    "total_rainfall": 180,
    "avg_humidity": 75
  }
}

Response:
{
  "status": "success",
  "prediction": {
    "is_suitable": true,
    "confidence": 0.94,
    "suitability_score": 0.87,
    "recommended_dates": [
      {
        "start_date": "2024-07-05",
        "end_date": "2024-07-12",
        "score": 0.92,
        "reason": "สภาพอากาศเหมาะสมที่สุด อุณหภูมิและความชื้นอยู่ในช่วงที่ดี"
      },
      {
        "start_date": "2024-07-20",
        "end_date": "2024-07-27",
        "score": 0.85,
        "reason": "สภาพอากาศดี แต่อาจมีฝนมากกว่าช่วงแรก"
      }
    ],
    "weather_analysis": {
      "temperature_status": "optimal",
      "rainfall_status": "good",
      "humidity_status": "optimal"
    },
    "risks": [
      {
        "type": "ฝนตกหนัก",
        "probability": 0.15,
        "impact": "medium",
        "mitigation": "เตรียมระบบระบายน้ำที่ดี"
      }
    ],
    "explanation": {
      "top_factors": [
        {"factor": "อุณหภูมิเฉลี่ย", "importance": 0.42},
        {"factor": "ปริมาณน้ำฝน", "importance": 0.35},
        {"factor": "ความชื้น", "importance": 0.18}
      ]
    }
  },
  "metadata": {
    "model_version": "1.0.0",
    "prediction_date": "2024-06-15T10:35:00Z"
  }
}


ง.3 ตัวอย่างการเรียกใช้ Model C (ระบบพยากรณ์ราคา)

Request:
POST /api/model-c/predict-price
Content-Type: application/json
Authorization: Bearer <JWT_TOKEN>

{
  "crop": "ข้าวโพดหวาน",
  "province": "เชียงใหม่",
  "forecast_days": 30,
  "current_price": 15.50
}

Response:
{
  "status": "success",
  "prediction": {
    "crop": "ข้าวโพดหวาน",
    "price_category": "low",
    "forecasts": [
      {
        "date": "2024-07-15",
        "predicted_price": 16.20,
        "confidence": 0.88,
        "price_range": {
          "lower": 14.80,
          "upper": 17.60
        }
      },
      {
        "date": "2024-07-22",
        "predicted_price": 16.80,
        "confidence": 0.85,
        "price_range": {
          "lower": 15.20,
          "upper": 18.40
        }
      },
      {
        "date": "2024-07-29",
        "predicted_price": 17.50,
        "confidence": 0.82,
        "price_range": {
          "lower": 15.80,
          "upper": 19.20
        }
      }
    ],
    "trend": "increasing",
    "trend_strength": 0.75,
    "seasonal_pattern": {
      "current_season": "ฤดูฝน",
      "typical_price_movement": "ราคามักจะเพิ่มขึ้นในช่วงนี้"
    },
    "recommendation": {
      "action": "hold",
      "reason": "ราคามีแนวโน้มเพิ่มขึ้น แนะนำให้รอขายในช่วงปลายเดือน",
      "optimal_selling_date": "2024-07-29",
      "expected_profit_increase": "12.9%"
    },
    "explanation": {
      "top_factors": [
        {"factor": "ราคา 7 วันที่แล้ว", "importance": 0.32},
        {"factor": "ค่าเฉลี่ยแบบกลิ้ง 30 วัน", "importance": 0.28},
        {"factor": "ปริมาณน้ำฝน", "importance": 0.18}
      ]
    }
  },
  "metadata": {
    "model_version": "1.0.0",
    "prediction_date": "2024-06-15T10:40:00Z"
  }
}


ง.4 ตัวอย่างการเรียกใช้ Model D (ระบบตัดสินใจเก็บเกี่ยว)

Request:
POST /api/model-d/harvest-decision
Content-Type: application/json
Authorization: Bearer <JWT_TOKEN>

{
  "crop": "ข้าวโพดหวาน",
  "province": "เชียงใหม่",
  "planting_date": "2024-04-15",
  "current_date": "2024-07-15",
  "current_price": 16.20,
  "expected_yield": 1200,
  "storage_cost_per_day": 50,
  "quality_degradation_rate": 0.01
}

Response:
{
  "status": "success",
  "decision": {
    "recommended_action": "wait_7_days",
    "confidence": 0.76,
    "expected_profit": {
      "harvest_now": 19440,
      "wait_7_days": 21360,
      "wait_14_days": 20880
    },
    "profit_comparison": {
      "wait_7_days_vs_now": "+9.9%",
      "wait_14_days_vs_now": "+7.4%"
    },
    "reasoning": {
      "price_forecast": "ราคาคาดว่าจะเพิ่มขึ้นในอีก 7 วัน",
      "quality_consideration": "คุณภาพยังคงดีในอีก 7-10 วัน",
      "storage_cost": "ต้นทุนการเก็บรักษายังไม่สูงเกินไป",
      "market_condition": "ตลาดมีความต้องการสูงในช่วงนี้"
    },
    "risks": [
      {
        "type": "ราคาอาจไม่เพิ่มขึ้นตามคาด",
        "probability": 0.24,
        "impact": "medium"
      },
      {
        "type": "คุณภาพอาจลดลง",
        "probability": 0.15,
        "impact": "low"
      }
    ],
    "alternative_scenarios": [
      {
        "scenario": "ราคาลดลง 10%",
        "expected_profit": 18720,
        "still_better_than_now": false
      },
      {
        "scenario": "ราคาเพิ่มขึ้น 15%",
        "expected_profit": 23280,
        "profit_increase": "+19.8%"
      }
    ]
  },
  "thompson_sampling_state": {
    "harvest_now": {"alpha": 45, "beta": 55},
    "wait_7_days": {"alpha": 62, "beta": 38},
    "wait_14_days": {"alpha": 38, "beta": 62}
  },
  "metadata": {
    "model_version": "1.0.0",
    "prediction_date": "2024-07-15T10:45:00Z"
  }
}



ภาคผนวก จ: กระบวนการป้องกัน Data Leakage

จ.1 หลักการป้องกัน Data Leakage

Data Leakage คือการที่ข้อมูลจากอนาคตหรือข้อมูลที่ไม่ควรมีในขั้นตอนการทำนายรั่วไหลเข้าไปในกระบวนการฝึกโมเดล ทำให้โมเดลมีประสิทธิภาพสูงเกินจริงในขั้นตอนการฝึก แต่ไม่สามารถทำงานได้ดีในการใช้งานจริง

ประเภทของ Data Leakage:
1. Temporal Leakage: การใช้ข้อมูลจากอนาคตในการทำนาย
2. Target Leakage: การใช้ข้อมูลที่มีความสัมพันธ์โดยตรงกับเป้าหมาย
3. Train-Test Contamination: การรั่วไหลของข้อมูลระหว่างชุดฝึกและชุดทดสอบ

จ.2 มาตรการป้องกันใน Model A

1. Feature Engineering:
   - ไม่ใช้ราคาปัจจุบันหรือราคาในอนาคตในการทำนาย ROI
   - ใช้เฉพาะราคาเฉลี่ยในอดีต (ย้อนหลัง 1 ปี)
   - ไม่ใช้ข้อมูลผลผลิตจริงในการทำนาย

2. การแบ่งข้อมูล:
   - แบ่งข้อมูลตามลำดับเวลา (Temporal Split)
   - ชุดฝึก: 70% ของข้อมูล (ข้อมูลเก่าสุด)
   - ชุดตรวจสอบ: 15% ของข้อมูล (ข้อมูลกลาง)
   - ชุดทดสอบ: 15% ของข้อมูล (ข้อมูลใหม่สุด)

3. การตรวจสอบ:
   - ตรวจสอบ Correlation Matrix เพื่อหาความสัมพันธ์ที่ผิดปกติ
   - ตรวจสอบ Feature Importance เพื่อดูว่ามีคุณลักษณะใดที่มีความสำคัญสูงผิดปกติ
   - ทดสอบโมเดลบนข้อมูลที่ไม่เคยเห็นมาก่อน (Out-of-Sample Testing)

จ.3 มาตรการป้องกันใน Model B

1. Feature Engineering:
   - ใช้เฉพาะข้อมูลสภาพอากาศ 30 วันก่อนวันปลูก
   - ไม่ใช้ข้อมูลสภาพอากาศหลังวันปลูก
   - ไม่ใช้ข้อมูลผลผลิตจริงในการทำนาย

2. การแบ่งข้อมูล:
   - แบ่งข้อมูลตามลำดับเวลา
   - ตรวจสอบว่าไม่มีข้อมูลจากช่วงเวลาเดียวกันในทั้งชุดฝึกและชุดทดสอบ

3. การตรวจสอบ:
   - ตรวจสอบว่าคุณลักษณะทั้งหมดสามารถคำนวณได้จากข้อมูลที่มีก่อนวันปลูก
   - ทดสอบโมเดลด้วยข้อมูลจากปีที่ไม่เคยเห็นมาก่อน


จ.4 มาตรการป้องกันใน Model C

1. Feature Engineering:
   - ใช้ shift() เพื่อสร้าง Lag Features อย่างถูกต้อง
   - คำนวณ Rolling Statistics โดยไม่รวมค่าปัจจุบัน
   - ตัวอย่างโค้ด:
     ```python
     # ถูกต้อง: ใช้ shift() เพื่อหลีกเลี่ยง Data Leakage
     df['price_lag_1'] = df['price'].shift(1)
     df['price_lag_7'] = df['price'].shift(7)
     df['rolling_mean_7'] = df['price'].shift(1).rolling(window=7).mean()
     
     # ผิด: ไม่ใช้ shift() จะทำให้เกิด Data Leakage
     # df['rolling_mean_7'] = df['price'].rolling(window=7).mean()
     ```

2. การแบ่งข้อมูล:
   - แบ่งข้อมูลตามลำดับเวลาอย่างเคร่งครัด
   - ไม่ใช้ Cross-Validation แบบสุ่ม แต่ใช้ Time Series Split
   - ตัวอย่างโค้ด:
     ```python
     from sklearn.model_selection import TimeSeriesSplit
     
     tscv = TimeSeriesSplit(n_splits=5)
     for train_index, test_index in tscv.split(X):
         X_train, X_test = X[train_index], X[test_index]
         y_train, y_test = y[train_index], y[test_index]
     ```

3. การตรวจสอบ:
   - ตรวจสอบว่าไม่มีคุณลักษณะใดที่มี Correlation สูงผิดปกติกับเป้าหมาย
   - ทดสอบโมเดลด้วยข้อมูลจากช่วงเวลาที่แตกต่างกันมาก
   - ตรวจสอบ Feature Importance เพื่อดูว่าโมเดลพึ่งพาคุณลักษณะใดมากที่สุด

จ.5 มาตรการป้องกันใน Model D

1. การออกแบบ Reward Function:
   - คำนวณ Reward จากข้อมูลที่เกิดขึ้นจริงหลังการตัดสินใจ
   - ไม่ใช้ข้อมูลราคาในอนาคตในการตัดสินใจ

2. การทดสอบ:
   - ทดสอบด้วย Backtesting บนข้อมูลในอดีต
   - จำลองสถานการณ์การตัดสินใจแบบ Real-time

3. การอัปเดตโมเดล:
   - อัปเดต Thompson Sampling Parameters เฉพาะหลังจากได้รับ Reward จริง
   - ไม่ใช้ข้อมูลจากอนาคตในการอัปเดต

จ.6 เครื่องมือตรวจสอบ Data Leakage

1. Correlation Analysis:
   ```python
   import pandas as pd
   import seaborn as sns
   import matplotlib.pyplot as plt
   
   # คำนวณ Correlation Matrix
   corr_matrix = df.corr()
   
   # แสดง Correlation กับเป้าหมาย
   target_corr = corr_matrix['target'].sort_values(ascending=False)
   print(target_corr)
   
   # ตรวจสอบว่ามีคุณลักษณะใดที่มี Correlation สูงผิดปกติ (>0.95)
   high_corr = target_corr[target_corr > 0.95]
   if len(high_corr) > 1:  # มากกว่า 1 เพราะเป้าหมายจะมี Correlation 1.0 กับตัวเอง
       print("Warning: Possible data leakage detected!")
       print(high_corr)
   ```

2. Feature Importance Analysis:
   ```python
   from sklearn.ensemble import GradientBoostingRegressor
   
   # ฝึกโมเดล
   model = GradientBoostingRegressor()
   model.fit(X_train, y_train)
   
   # ดู Feature Importance
   feature_importance = pd.DataFrame({
       'feature': X_train.columns,
       'importance': model.feature_importances_
   }).sort_values('importance', ascending=False)
   
   print(feature_importance)
   
   # ตรวจสอบว่ามีคุณลักษณะใดที่มีความสำคัญสูงผิดปกติ (>0.5)
   if feature_importance.iloc[0]['importance'] > 0.5:
       print("Warning: One feature dominates the model!")
   ```

3. Temporal Validation:
   ```python
   # แบ่งข้อมูลตามเวลา
   train_end_date = '2023-12-31'
   test_start_date = '2024-01-01'
   
   train_data = df[df['date'] <= train_end_date]
   test_data = df[df['date'] >= test_start_date]
   
   # ตรวจสอบว่าไม่มีข้อมูลซ้ำซ้อน
   assert len(set(train_data['date']) & set(test_data['date'])) == 0
   ```



ภาคผนวก ฉ: การประเมินประสิทธิภาพโมเดล

ฉ.1 ตัวชี้วัดสำหรับ Regression (Model A และ Model C)

1. R² Score (Coefficient of Determination):
   - วัดสัดส่วนความแปรปรวนของตัวแปรเป้าหมายที่โมเดลสามารถอธิบายได้
   - ค่าอยู่ระหว่าง 0 ถึง 1 (ยิ่งใกล้ 1 ยิ่งดี)
   - สูตร: R² = 1 - (SS_res / SS_tot)
   - การตีความ:
     * R² > 0.9: ดีมาก
     * 0.7 < R² ≤ 0.9: ดี
     * 0.5 < R² ≤ 0.7: ปานกลาง
     * R² ≤ 0.5: ต่ำ

2. Mean Absolute Error (MAE):
   - วัดค่าเฉลี่ยของความผิดพลาดสัมบูรณ์
   - หน่วยเดียวกับตัวแปรเป้าหมาย
   - สูตร: MAE = (1/n) × Σ|y_true - y_pred|
   - ข้อดี: เข้าใจง่าย ไม่ไวต่อ Outliers

3. Root Mean Squared Error (RMSE):
   - วัดรากที่สองของค่าเฉลี่ยของความผิดพลาดกำลังสอง
   - หน่วยเดียวกับตัวแปรเป้าหมาย
   - สูตร: RMSE = √[(1/n) × Σ(y_true - y_pred)²]
   - ข้อดี: ให้น้ำหนักมากกับความผิดพลาดที่ใหญ่

4. Mean Absolute Percentage Error (MAPE):
   - วัดค่าเฉลี่ยของความผิดพลาดเป็นเปอร์เซ็นต์
   - สูตร: MAPE = (100/n) × Σ|((y_true - y_pred) / y_true)|
   - การตีความ:
     * MAPE < 10%: ดีมาก
     * 10% ≤ MAPE < 20%: ดี
     * 20% ≤ MAPE < 50%: ยอมรับได้
     * MAPE ≥ 50%: ไม่แม่นยำ

ฉ.2 ตัวชี้วัดสำหรับ Classification (Model B)

1. Accuracy:
   - วัดสัดส่วนของการทำนายที่ถูกต้อง
   - สูตร: Accuracy = (TP + TN) / (TP + TN + FP + FN)
   - เหมาะสำหรับข้อมูลที่สมดุล

2. Precision:
   - วัดสัดส่วนของการทำนายเป็น Positive ที่ถูกต้อง
   - สูตร: Precision = TP / (TP + FP)
   - สำคัญเมื่อต้องการลด False Positive

3. Recall (Sensitivity):
   - วัดสัดส่วนของ Positive จริงที่โมเดลสามารถจับได้
   - สูตร: Recall = TP / (TP + FN)
   - สำคัญเมื่อต้องการลด False Negative

4. F1-Score:
   - ค่าเฉลี่ยฮาร์มอนิกของ Precision และ Recall
   - สูตร: F1 = 2 × (Precision × Recall) / (Precision + Recall)
   - เหมาะสำหรับข้อมูลที่ไม่สมดุล

5. AUC-ROC:
   - พื้นที่ใต้กราฟ ROC Curve
   - ค่าอยู่ระหว่าง 0 ถึง 1 (ยิ่งใกล้ 1 ยิ่งดี)
   - การตีความ:
     * AUC > 0.9: ดีมาก
     * 0.8 < AUC ≤ 0.9: ดี
     * 0.7 < AUC ≤ 0.8: ปานกลาง
     * AUC ≤ 0.7: ต่ำ


ฉ.3 ตัวชี้วัดสำหรับ Reinforcement Learning (Model D)

1. Decision Accuracy:
   - วัดสัดส่วนของการตัดสินใจที่เลือกทางเลือกที่ดีที่สุด
   - สูตร: Decision Accuracy = (จำนวนครั้งที่เลือกทางเลือกที่ดีที่สุด) / (จำนวนครั้งทั้งหมด)

2. Profit Efficiency:
   - วัดสัดส่วนของกำไรที่ได้เทียบกับกำไรสูงสุดที่เป็นไปได้
   - สูตร: Profit Efficiency = (กำไรที่ได้จริง) / (กำไรสูงสุดที่เป็นไปได้)

3. Regret:
   - วัดความแตกต่างระหว่างกำไรสูงสุดที่เป็นไปได้กับกำไรที่ได้จริง
   - สูตร: Regret = (กำไรสูงสุดที่เป็นไปได้) - (กำไรที่ได้จริง)

4. Average Profit Gain:
   - วัดการเพิ่มขึ้นของกำไรเฉลี่ยเทียบกับกลยุทธ์พื้นฐาน
   - สูตร: Profit Gain = ((กำไรเฉลี่ยจากโมเดล) - (กำไรเฉลี่ยจากกลยุทธ์พื้นฐาน)) / (กำไรเฉลี่ยจากกลยุทธ์พื้นฐาน)

ฉ.4 การตรวจสอบ Overfitting

1. Overfitting Gap:
   - วัดความแตกต่างระหว่างประสิทธิภาพบนชุดฝึกและชุดทดสอบ
   - สูตร: Overfitting Gap = (ประสิทธิภาพบนชุดฝึก) - (ประสิทธิภาพบนชุดทดสอบ)
   - การตีความ:
     * Gap < 5%: ไม่มี Overfitting
     * 5% ≤ Gap < 10%: Overfitting เล็กน้อย (ยอมรับได้)
     * 10% ≤ Gap < 20%: Overfitting ปานกลาง (ควรปรับปรุง)
     * Gap ≥ 20%: Overfitting มาก (ต้องแก้ไข)

2. Learning Curve:
   - กราฟแสดงประสิทธิภาพของโมเดลเมื่อเพิ่มขนาดข้อมูลฝึก
   - ใช้ตรวจสอบว่าโมเดลมี Overfitting หรือ Underfitting

3. Validation Curve:
   - กราฟแสดงประสิทธิภาพของโมเดลเมื่อเปลี่ยนค่า Hyperparameter
   - ใช้หาค่า Hyperparameter ที่เหมาะสม

ฉ.5 ตารางสรุปประสิทธิภาพของโมเดลทั้ง 4 ตัว

+----------+------------------+------------------+------------------+------------------+
| Model    | Model A          | Model B          | Model C          | Model D          |
+----------+------------------+------------------+------------------+------------------+
| Type     | Regression       | Classification   | Regression       | RL (MAB)         |
+----------+------------------+------------------+------------------+------------------+
| Primary  | R² = 0.9210      | F1 = 0.8488      | R² = 0.7589      | Profit Eff.      |
| Metric   |                  |                  |                  | = 96.84%         |
+----------+------------------+------------------+------------------+------------------+
| MAE/     | MAE = 5,891.23   | Recall = 0.9393  | MAE = 6.97       | Decision Acc.    |
| Accuracy | บาท              |                  | บาท/กก.          | = 48.88%         |
+----------+------------------+------------------+------------------+------------------+
| RMSE/    | RMSE = 8,234.56  | Precision =      | RMSE = 10.23     | Profit Gain      |
| AUC      | บาท              | 0.7692           | บาท/กก.          | = +12.3%         |
+----------+------------------+------------------+------------------+------------------+
| MAPE/    | MAPE = 25.71%    | AUC = 0.9156     | MAPE = 23.8%     | Regret Rate      |
| Other    |                  |                  |                  | = 3.16%          |
+----------+------------------+------------------+------------------+------------------+
| Over-    | 4.87%            | 3.21%            | 5.12%            | N/A              |
| fitting  |                  |                  |                  |                  |
| Gap      |                  |                  |                  |                  |
+----------+------------------+------------------+------------------+------------------+
| Overall  | ดีมาก            | ดี               | ดี               | ดีมาก            |
| Rating   |                  |                  |                  |                  |
+----------+------------------+------------------+------------------+------------------+



ภาคผนวก ช: คำศัพท์และคำย่อ

AI (Artificial Intelligence): ปัญญาประดิษฐ์ - เทคโนโลยีที่ทำให้เครื่องจักรสามารถเรียนรู้และตัดสินใจได้เหมือนมนุษย์

API (Application Programming Interface): ส่วนต่อประสานโปรแกรมประยุกต์ - ชุดของกฎและโปรโตคอลที่ใช้ในการสื่อสารระหว่างซอฟต์แวร์

AUC-ROC (Area Under the Receiver Operating Characteristic Curve): พื้นที่ใต้กราฟ ROC - ตัวชี้วัดประสิทธิภาพของโมเดล Classification

Backtesting: การทดสอบย้อนหลัง - การทดสอบกลยุทธ์หรือโมเดลด้วยข้อมูลในอดีต

Backend: ส่วนหลังบ้าน - ส่วนของระบบที่ทำงานบนเซิร์ฟเวอร์และจัดการข้อมูล

Beta Distribution: การแจกแจงเบตา - การแจกแจงความน่าจะเป็นที่ใช้ใน Thompson Sampling

CPI (Consumer Price Index): ดัชนีราคาผู้บริโภค - ตัวชี้วัดการเปลี่ยนแปลงของราคาสินค้าและบริการ

Cross-Validation: การตรวจสอบไขว้ - เทคนิคการประเมินประสิทธิภาพของโมเดลโดยแบ่งข้อมูลออกเป็นหลายส่วน

Data Leakage: การรั่วไหลของข้อมูล - การที่ข้อมูลจากอนาคตหรือข้อมูลที่ไม่ควรมีรั่วไหลเข้าไปในกระบวนการฝึกโมเดล

Deep Learning: การเรียนรู้เชิงลึก - สาขาหนึ่งของ Machine Learning ที่ใช้โครงข่ายประสาทเทียมหลายชั้น

Ensemble Methods: วิธีการรวมโมเดล - การรวมโมเดลหลายตัวเข้าด้วยกันเพื่อเพิ่มประสิทธิภาพ

Explainable AI (XAI): AI ที่อธิบายได้ - เทคโนโลยี AI ที่สามารถอธิบายเหตุผลของการตัดสินใจได้

F1-Score: ค่าเฉลี่ยฮาร์มอนิกของ Precision และ Recall - ตัวชี้วัดประสิทธิภาพของโมเดล Classification

FastAPI: เฟรมเวิร์กสำหรับสร้าง API ด้วย Python - เครื่องมือสำหรับพัฒนา Backend

Feature Engineering: การสร้างคุณลักษณะ - กระบวนการสร้างตัวแปรใหม่จากข้อมูลดิบเพื่อใช้ในการฝึกโมเดล

Feature Importance: ความสำคัญของคุณลักษณะ - การวัดว่าคุณลักษณะแต่ละตัวมีผลต่อการทำนายมากน้อยเพียงใด

Frontend: ส่วนหน้าบ้าน - ส่วนของระบบที่ผู้ใช้เห็นและโต้ตอบด้วย

GDP (Gross Domestic Product): ผลิตภัณฑ์มวลรวมในประเทศ - มูลค่ารวมของสินค้าและบริการที่ผลิตในประเทศ

GIS (Geographic Information System): ระบบสารสนเทศภูมิศาสตร์ - ระบบสำหรับจัดการและวิเคราะห์ข้อมูลเชิงพื้นที่

Gradient Boosting: การเพิ่มประสิทธิภาพแบบไล่ระดับ - อัลกอริทึม Machine Learning ที่สร้างโมเดลแบบต่อเนื่อง

GRU (Gated Recurrent Unit): หน่วยวนซ้ำแบบมีประตู - โครงสร้างโครงข่ายประสาทเทียมสำหรับข้อมูลอนุกรมเวลา

Hyperparameter: พารามิเตอร์ระดับสูง - ค่าที่ต้องกำหนดก่อนการฝึกโมเดล

IoT (Internet of Things): อินเทอร์เน็ตของสรรพสิ่ง - เครือข่ายของอุปกรณ์ที่เชื่อมต่อกันผ่านอินเทอร์เน็ต

JWT (JSON Web Token): โทเค็นเว็บ JSON - มาตรฐานสำหรับการสร้างโทเค็นการยืนยันตัวตน

Lag Features: คุณลักษณะแล็ก - ค่าของตัวแปรในอดีตที่ใช้เป็นคุณลักษณะในการทำนาย

LIME (Local Interpretable Model-agnostic Explanations): การอธิบายโมเดลแบบท้องถิ่น - เทคนิคสำหรับอธิบายการทำนายของโมเดล

LSTM (Long Short-Term Memory): หน่วยความจำระยะสั้นแบบยาว - โครงสร้างโครงข่ายประสาทเทียมสำหรับข้อมูลอนุกรมเวลา

MAE (Mean Absolute Error): ค่าเฉลี่ยของความผิดพลาดสัมบูรณ์ - ตัวชี้วัดความแม่นยำของโมเดล Regression

MAPE (Mean Absolute Percentage Error): ค่าเฉลี่ยของความผิดพลาดเป็นเปอร์เซ็นต์ - ตัวชี้วัดความแม่นยำของโมเดล Regression

MCP (Model Context Protocol): โปรโตคอลบริบทโมเดล - มาตรฐานสำหรับการสื่อสารระหว่างโมเดลและแอปพลิเคชัน

Machine Learning (ML): การเรียนรู้ของเครื่อง - สาขาของ AI ที่ทำให้เครื่องจักรสามารถเรียนรู้จากข้อมูล

Multi-Armed Bandit (MAB): ปัญหาเครื่องสล็อตหลายแขน - ปัญหาในการตัดสินใจที่ต้องสมดุลระหว่างการสำรวจและการใช้ประโยชน์

Overfitting: การเรียนรู้มากเกินไป - ปัญหาที่โมเดลเรียนรู้รายละเอียดของข้อมูลฝึกมากเกินไปจนไม่สามารถทำนายข้อมูลใหม่ได้ดี

Precision: ความแม่นยำ - สัดส่วนของการทำนายเป็น Positive ที่ถูกต้อง

R² Score (Coefficient of Determination): สัมประสิทธิ์การกำหนด - ตัวชี้วัดความสามารถของโมเดลในการอธิบายความแปรปรวน

Random Forest: ป่าสุ่ม - อัลกอริทึม Machine Learning ที่รวมต้นไม้ตัดสินใจหลายต้น

React: ไลบรารี JavaScript สำหรับสร้าง User Interface

Recall (Sensitivity): ความไว - สัดส่วนของ Positive จริงที่โมเดลสามารถจับได้

Reinforcement Learning (RL): การเรียนรู้เชิงเสริมแรง - สาขาของ Machine Learning ที่เรียนรู้จากการลองผิดลองถูก

RMSE (Root Mean Squared Error): รากที่สองของค่าเฉลี่ยของความผิดพลาดกำลังสอง - ตัวชี้วัดความแม่นยำของโมเดล Regression

ROI (Return on Investment): ผลตอบแทนจากการลงทุน - อัตราส่วนระหว่างกำไรและเงินลงทุน

Rolling Statistics: สถิติแบบกลิ้ง - สถิติที่คำนวณจากหน้าต่างเวลาที่เลื่อนไป

SHAP (SHapley Additive exPlanations): การอธิบายแบบ Shapley - เทคนิคสำหรับอธิบายการทำนายของโมเดล

Stratified Approach: แนวทางแบบแบ่งชั้น - การแบ่งข้อมูลออกเป็นกลุ่มย่อยและสร้างโมเดลแยกสำหรับแต่ละกลุ่ม

Thompson Sampling: การสุ่มตัวอย่างแบบทอมป์สัน - อัลกอริทึมสำหรับแก้ปัญหา Multi-Armed Bandit

Time Series: อนุกรมเวลา - ข้อมูลที่เรียงตามลำดับเวลา

Transformer: โครงสร้างโครงข่ายประสาทเทียมที่ใช้กลไก Attention

TypeScript: ภาษาโปรแกรมที่เป็น Superset ของ JavaScript

Underfitting: การเรียนรู้ไม่เพียงพอ - ปัญหาที่โมเดลไม่สามารถเรียนรู้รูปแบบของข้อมูลได้ดีพอ

XGBoost (eXtreme Gradient Boosting): การเพิ่มประสิทธิภาพแบบไล่ระดับขั้นสูง - อัลกอริทึม Machine Learning ที่เป็นการพัฒนาต่อจาก Gradient Boosting



ภาคผนวก ซ: เอกสารอ้างอิง

ซ.1 หนังสือและตำรา

1. Hastie, T., Tibshirani, R., & Friedman, J. (2009). The Elements of Statistical Learning: Data Mining, Inference, and Prediction (2nd ed.). Springer.

2. Géron, A. (2019). Hands-On Machine Learning with Scikit-Learn, Keras, and TensorFlow (2nd ed.). O'Reilly Media.

3. Goodfellow, I., Bengio, Y., & Courville, A. (2016). Deep Learning. MIT Press.

4. Sutton, R. S., & Barto, A. G. (2018). Reinforcement Learning: An Introduction (2nd ed.). MIT Press.

5. Molnar, C. (2022). Interpretable Machine Learning: A Guide for Making Black Box Models Explainable. Lulu.com.

6. Hyndman, R. J., & Athanasopoulos, G. (2021). Forecasting: Principles and Practice (3rd ed.). OTexts.

ซ.2 บทความวิจัย

1. Chen, T., & Guestrin, C. (2016). XGBoost: A Scalable Tree Boosting System. Proceedings of the 22nd ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, 785-794.

2. Lundberg, S. M., & Lee, S. I. (2017). A Unified Approach to Interpreting Model Predictions. Advances in Neural Information Processing Systems, 30, 4765-4774.

3. Ribeiro, M. T., Singh, S., & Guestrin, C. (2016). "Why Should I Trust You?": Explaining the Predictions of Any Classifier. Proceedings of the 22nd ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, 1135-1144.

4. Agrawal, S., & Goyal, N. (2012). Analysis of Thompson Sampling for the Multi-armed Bandit Problem. Proceedings of the 25th Annual Conference on Learning Theory, 39.1-39.26.

5. Kaufmann, E., Cappé, O., & Garivier, A. (2016). On the Complexity of Best-Arm Identification in Multi-Armed Bandit Models. Journal of Machine Learning Research, 17(1), 1-42.

ซ.3 เอกสารออนไลน์และเว็บไซต์

1. Scikit-learn Documentation. (2024). Retrieved from https://scikit-learn.org/stable/

2. FastAPI Documentation. (2024). Retrieved from https://fastapi.tiangolo.com/

3. React Documentation. (2024). Retrieved from https://react.dev/

4. Kaggle. (2024). Machine Learning Tutorials and Competitions. Retrieved from https://www.kaggle.com/

5. Towards Data Science. (2024). Medium Publication on Data Science and Machine Learning. Retrieved from https://towardsdatascience.com/

6. กรมอุตุนิยมวิทยา. (2024). ข้อมูลสภาพอากาศ. สืบค้นจาก https://www.tmd.go.th/

7. กระทรวงพาณิชย์. (2024). ข้อมูลราคาสินค้าเกษตร. สืบค้นจาก https://www.moc.go.th/

8. สำนักงานเศรษฐกิจการเกษตร. (2024). สถิติการเกษตร. สืบค้นจาก https://www.oae.go.th/

ซ.4 เครื่องมือและไลบรารี

1. Python Software Foundation. (2024). Python Programming Language. Retrieved from https://www.python.org/

2. NumPy Developers. (2024). NumPy: The Fundamental Package for Scientific Computing with Python. Retrieved from https://numpy.org/

3. pandas Development Team. (2024). pandas: Python Data Analysis Library. Retrieved from https://pandas.pydata.org/

4. Matplotlib Development Team. (2024). Matplotlib: Visualization with Python. Retrieved from https://matplotlib.org/

5. Seaborn Development Team. (2024). Seaborn: Statistical Data Visualization. Retrieved from https://seaborn.pydata.org/

6. PostgreSQL Global Development Group. (2024). PostgreSQL: The World's Most Advanced Open Source Relational Database. Retrieved from https://www.postgresql.org/

7. GitHub, Inc. (2024). GitHub: Where the World Builds Software. Retrieved from https://github.com/

8. Render. (2024). Render: Cloud Application Hosting for Developers. Retrieved from https://render.com/

ซ.5 มาตรฐานและแนวทางปฏิบัติ

1. ISO/IEC 25010:2011. Systems and Software Engineering - Systems and Software Quality Requirements and Evaluation (SQuaRE) - System and Software Quality Models.

2. IEEE 730-2014. IEEE Standard for Software Quality Assurance Processes.

3. W3C. (2024). Web Content Accessibility Guidelines (WCAG) 2.1. Retrieved from https://www.w3.org/WAI/WCAG21/quickref/

4. OWASP. (2024). OWASP Top Ten Web Application Security Risks. Retrieved from https://owasp.org/www-project-top-ten/

ซ.6 งานวิจัยที่เกี่ยวข้องในประเทศไทย

1. มหาวิทยาลัยเกษตรศาสตร์. (2023). การประยุกต์ใช้ปัญญาประดิษฐ์ในภาคการเกษตรไทย. วารสารวิจัยและพัฒนา มก., 46(2), 123-145.

2. สถาบันวิจัยและพัฒนาพื้นที่สูง. (2022). ระบบสนับสนุนการตัดสินใจสำหรับเกษตรกรในพื้นที่สูง. รายงานการวิจัย.

3. สำนักงานพัฒนาวิทยาศาสตร์และเทคโนโลยีแห่งชาติ (สวทช.). (2023). เทคโนโลยีดิจิทัลเพื่อการเกษตรอัจฉริยะ. รายงานประจำปี.

4. มหาวิทยาลัยเชียงใหม่. (2022). การพยากรณ์ราคาสินค้าเกษตรด้วย Machine Learning. วารสารวิทยาศาสตร์และเทคโนโลยี มช., 41(3), 234-256.

5. จุฬาลงกรณ์มหาวิทยาลัย. (2023). ระบบแนะนำพืชเศรษฐกิจสำหรับเกษตรกรไทย. วารสารวิศวกรรมศาสตร์ จุฬาฯ, 35(1), 45-67.



ภาคผนวก ฌ: ภาพหน้าจอและผังงาน

ฌ.1 ภาพหน้าจอระบบ

[หมายเหตุ: ในเอกสารฉบับสมบูรณ์ควรมีภาพหน้าจอจริงของระบบ]

1. หน้าแรก (Landing Page):
   - แสดงภาพรวมของระบบ Farmme
   - ปุ่มเข้าสู่ระบบและลงทะเบียน
   - คำอธิบายคุณสมบัติหลักของระบบ

2. หน้าลงทะเบียน (Registration Page):
   - ฟอร์มกรอกข้อมูลผู้ใช้
   - ข้อมูลฟาร์มและพื้นที่เพาะปลูก
   - การยืนยันตัวตนผ่านอีเมล

3. หน้าหลัก (Dashboard):
   - แสดงภาพรวมของฟาร์ม
   - สถิติการเพาะปลูก
   - การแจ้งเตือนสำคัญ
   - เมนูเข้าถึงโมเดลทั้ง 4 ตัว

4. หน้า Model A (ระบบแนะนำพืช):
   - ฟอร์มกรอกข้อมูลพื้นฐาน (จังหวัด, งบประมาณ, ความเสี่ยง)
   - ตารางแสดงพืชที่แนะนำพร้อม ROI ที่คาดการณ์
   - กราฟเปรียบเทียบพืชต่างๆ
   - คำอธิบายเหตุผลของการแนะนำ

5. หน้า Model B (ระบบพยากรณ์ช่วงเวลาปลูก):
   - เลือกพืชและจังหวัด
   - แสดงปฏิทินช่วงเวลาที่เหมาะสม
   - ข้อมูลสภาพอากาศพยากรณ์
   - คำแนะนำและความเสี่ยง

6. หน้า Model C (ระบบพยากรณ์ราคา):
   - เลือกพืชและระยะเวลาพยากรณ์
   - กราฟแสดงราคาในอดีตและราคาพยากรณ์
   - ช่วงความเชื่อมั่นของราคา
   - แนวโน้มและคำแนะนำ

7. หน้า Model D (ระบบตัดสินใจเก็บเกี่ยว):
   - กรอกข้อมูลการปลูกและราคาปัจจุบัน
   - แสดงทางเลือกการเก็บเกี่ยว (ทันที, รอ 7 วัน, รอ 14 วัน)
   - เปรียบเทียบกำไรที่คาดการณ์
   - คำแนะนำและความเสี่ยง

8. หน้าประวัติการใช้งาน (History):
   - บันทึกการใช้งานโมเดลทั้งหมด
   - ผลลัพธ์ที่ได้รับ
   - การเปรียบเทียบระหว่างคำแนะนำและผลจริง

9. หน้าโปรไฟล์ (Profile):
   - ข้อมูลผู้ใช้
   - ข้อมูลฟาร์ม
   - การตั้งค่าระบบ

ฌ.2 ผังงานระบบ (System Architecture Diagram)

[หมายเหตุ: ในเอกสารฉบับสมบูรณ์ควรมีผังงานจริง]

1. ผังงานสถาปัตยกรรมโดยรวม:
   - แสดงความสัมพันธ์ระหว่าง Frontend, Backend, Database และ Model Storage
   - แสดงการไหลของข้อมูล
   - แสดงการเชื่อมต่อกับ External APIs

2. ผังงาน Data Flow:
   - แสดงการไหลของข้อมูลตั้งแต่ผู้ใช้กรอกข้อมูล
   - ผ่านการประมวลผลใน Backend
   - การเรียกใช้โมเดล
   - การส่งผลลัพธ์กลับไปยังผู้ใช้

3. ผังงาน Model Pipeline:
   - แสดงขั้นตอนการทำงานของโมเดลแต่ละตัว
   - การเตรียมข้อมูล (Data Preprocessing)
   - การทำนาย (Prediction)
   - การอธิบายผลลัพธ์ (Explanation)

4. ผังงาน Database Schema:
   - แสดงโครงสร้างตารางในฐานข้อมูล
   - ความสัมพันธ์ระหว่างตาราง (Relationships)
   - Primary Keys และ Foreign Keys

5. ผังงาน User Journey:
   - แสดงเส้นทางการใช้งานของผู้ใช้
   - ตั้งแต่การลงทะเบียน
   - การใช้งานโมเดลต่างๆ
   - การติดตามผลและให้ Feedback

ฌ.3 ผังงานอัลกอริทึม (Algorithm Flowchart)

[หมายเหตุ: ในเอกสารฉบับสมบูรณ์ควรมีผังงานจริง]

1. ผังงาน Model A (Crop Recommendation):
   - รับข้อมูลจากผู้ใช้
   - ดึงข้อมูลสภาพอากาศและราคา
   - คำนวณ Features
   - ทำนาย ROI สำหรับพืชทั้งหมด
   - จัดอันดับและคัดเลือกพืชที่แนะนำ
   - คำนวณ SHAP Values สำหรับอธิบาย
   - ส่งผลลัพธ์กลับไปยังผู้ใช้

2. ผังงาน Model B (Planting Time Prediction):
   - รับข้อมูลพืชและจังหวัด
   - ดึงข้อมูลพยากรณ์อากาศ
   - คำนวณ Features
   - ทำนายความเหมาะสมของช่วงเวลา
   - ระบุช่วงเวลาที่แนะนำ
   - ประเมินความเสี่ยง
   - ส่งผลลัพธ์กลับไปยังผู้ใช้

3. ผังงาน Model C (Price Forecasting):
   - รับข้อมูลพืชและระยะเวลาพยากรณ์
   - ดึงข้อมูลราคาในอดีต
   - คำนวณ Lag Features และ Rolling Statistics
   - ระบุกลุ่มราคาของพืช
   - เลือกโมเดลที่เหมาะสม
   - ทำนายราคาในอนาคต
   - คำนวณช่วงความเชื่อมั่น
   - ส่งผลลัพธ์กลับไปยังผู้ใช้

4. ผังงาน Model D (Harvest Decision):
   - รับข้อมูลการปลูกและราคาปัจจุบัน
   - ดึงข้อมูลพยากรณ์ราคาจาก Model C
   - สุ่มตัวอย่างจาก Beta Distribution ของแต่ละทางเลือก
   - เลือกทางเลือกที่มีค่าสุ่มสูงสุด
   - คำนวณกำไรที่คาดการณ์สำหรับแต่ละทางเลือก
   - ประเมินความเสี่ยง
   - ส่งผลลัพธ์กลับไปยังผู้ใช้
   - รอรับ Feedback เพื่ออัปเดต Beta Distribution



ภาคผนวก ญ: ตัวอย่างโค้ดสำคัญ

ญ.1 ตัวอย่างโค้ด Model A (Crop Recommendation)

```python
import pandas as pd
import numpy as np
from sklearn.ensemble import GradientBoostingRegressor
from sklearn.model_selection import TimeSeriesSplit
from sklearn.metrics import r2_score, mean_absolute_error
import shap

class CropRecommendationModel:
    def __init__(self):
        self.model = GradientBoostingRegressor(
            n_estimators=200,
            learning_rate=0.1,
            max_depth=5,
            min_samples_split=10,
            min_samples_leaf=4,
            subsample=0.8,
            random_state=42
        )
        self.feature_names = None
        self.explainer = None
    
    def prepare_features(self, df):
        """เตรียมคุณลักษณะสำหรับการทำนาย"""
        features = df.copy()
        
        # คุณลักษณะพื้นฐาน
        features['expected_yield'] = df['expected_yield']
        features['investment_cost'] = df['investment_cost']
        features['avg_price'] = df['avg_price']
        
        # คุณลักษณะสภาพอากาศ
        features['avg_temperature'] = df['avg_temperature']
        features['total_rainfall'] = df['total_rainfall']
        features['avg_humidity'] = df['avg_humidity']
        
        # คุณลักษณะตามฤดูกาล
        features['month'] = df['month']
        features['quarter'] = df['quarter']
        features['season'] = df['season']
        
        # One-hot encoding สำหรับตัวแปรหมวดหมู่
        features = pd.get_dummies(features, columns=['crop', 'province', 'season'])
        
        return features
    
    def train(self, X_train, y_train, X_val, y_val):
        """ฝึกโมเดล"""
        self.feature_names = X_train.columns.tolist()
        
        # ฝึกโมเดล
        self.model.fit(X_train, y_train)
        
        # ประเมินประสิทธิภาพ
        train_pred = self.model.predict(X_train)
        val_pred = self.model.predict(X_val)
        
        train_r2 = r2_score(y_train, train_pred)
        val_r2 = r2_score(y_val, val_pred)
        val_mae = mean_absolute_error(y_val, val_pred)
        
        print(f"Train R²: {train_r2:.4f}")
        print(f"Validation R²: {val_r2:.4f}")
        print(f"Validation MAE: {val_mae:.2f}")
        print(f"Overfitting Gap: {(train_r2 - val_r2) * 100:.2f}%")
        
        # สร้าง SHAP Explainer
        self.explainer = shap.TreeExplainer(self.model)
        
        return self
    
    def predict(self, X):
        """ทำนาย ROI"""
        return self.model.predict(X)
    
    def explain(self, X):
        """อธิบายการทำนายด้วย SHAP"""
        shap_values = self.explainer.shap_values(X)
        return shap_values
    
    def recommend_crops(self, user_input, all_crops_data):
        """แนะนำพืชที่เหมาะสม"""
        # เตรียมข้อมูลสำหรับพืชทั้งหมด
        X = self.prepare_features(all_crops_data)
        
        # ทำนาย ROI
        predictions = self.predict(X)
        
        # เพิ่มคอลัมน์ ROI ที่ทำนาย
        all_crops_data['predicted_roi'] = predictions
        
        # จัดอันดับตาม ROI
        recommendations = all_crops_data.sort_values('predicted_roi', ascending=False)
        
        # คำนวณ SHAP Values สำหรับพืชที่แนะนำ
        top_crops = recommendations.head(5)
        shap_values = self.explain(X.loc[top_crops.index])
        
        # สร้างผลลัพธ์
        results = []
        for idx, (_, crop) in enumerate(top_crops.iterrows()):
            result = {
                'rank': idx + 1,
                'crop': crop['crop'],
                'predicted_roi': crop['predicted_roi'],
                'expected_yield': crop['expected_yield'],
                'investment_cost': crop['investment_cost'],
                'explanation': self._format_explanation(shap_values[idx])
            }
            results.append(result)
        
        return results
    
    def _format_explanation(self, shap_values):
        """จัดรูปแบบคำอธิบาย"""
        # หา Feature ที่มีผลกระทบมากที่สุด
        feature_importance = pd.DataFrame({
            'feature': self.feature_names,
            'importance': np.abs(shap_values)
        }).sort_values('importance', ascending=False).head(3)
        
        return feature_importance.to_dict('records')

# ตัวอย่างการใช้งาน
if __name__ == "__main__":
    # โหลดข้อมูล
    df = pd.read_csv('crop_data.csv')
    
    # แบ่งข้อมูลตามเวลา
    train_size = int(len(df) * 0.7)
    val_size = int(len(df) * 0.15)
    
    train_data = df[:train_size]
    val_data = df[train_size:train_size+val_size]
    test_data = df[train_size+val_size:]
    
    # เตรียม Features และ Target
    model = CropRecommendationModel()
    X_train = model.prepare_features(train_data.drop('roi', axis=1))
    y_train = train_data['roi']
    X_val = model.prepare_features(val_data.drop('roi', axis=1))
    y_val = val_data['roi']
    
    # ฝึกโมเดล
    model.train(X_train, y_train, X_val, y_val)
    
    # บันทึกโมเดล
    import pickle
    with open('model_a.pkl', 'wb') as f:
        pickle.dump(model, f)
```


ญ.2 ตัวอย่างโค้ด Model C (Price Forecasting) - การป้องกัน Data Leakage

```python
import pandas as pd
import numpy as np
from sklearn.ensemble import GradientBoostingRegressor

class PriceForecastingModel:
    def __init__(self):
        self.models = {
            'low': None,    # พืชราคาต่ำ (0-20 บาท/กก.)
            'medium': None, # พืชราคากลาง (20-50 บาท/กก.)
            'high': None    # พืชราคาสูง (>50 บาท/กก.)
        }
    
    def create_lag_features(self, df, target_col='price', lags=[1, 7, 30]):
        """สร้าง Lag Features โดยป้องกัน Data Leakage"""
        df = df.copy()
        
        # สร้าง Lag Features
        for lag in lags:
            df[f'{target_col}_lag_{lag}'] = df[target_col].shift(lag)
        
        return df
    
    def create_rolling_features(self, df, target_col='price', windows=[7, 14, 30]):
        """สร้าง Rolling Statistics โดยป้องกัน Data Leakage"""
        df = df.copy()
        
        for window in windows:
            # ใช้ shift(1) เพื่อไม่รวมค่าปัจจุบัน
            df[f'{target_col}_rolling_mean_{window}'] = (
                df[target_col].shift(1).rolling(window=window).mean()
            )
            df[f'{target_col}_rolling_std_{window}'] = (
                df[target_col].shift(1).rolling(window=window).std()
            )
            df[f'{target_col}_rolling_min_{window}'] = (
                df[target_col].shift(1).rolling(window=window).min()
            )
            df[f'{target_col}_rolling_max_{window}'] = (
                df[target_col].shift(1).rolling(window=window).max()
            )
        
        return df
    
    def prepare_features(self, df):
        """เตรียมคุณลักษณะทั้งหมด"""
        df = df.copy()
        
        # สร้าง Lag Features
        df = self.create_lag_features(df, lags=[1, 7, 30])
        
        # สร้าง Rolling Features
        df = self.create_rolling_features(df, windows=[7, 14, 30])
        
        # เพิ่มคุณลักษณะสภาพอากาศ
        # (ใช้เฉพาะข้อมูลที่มีก่อนวันที่ทำนาย)
        df['temperature'] = df['temperature']
        df['rainfall'] = df['rainfall']
        df['humidity'] = df['humidity']
        
        # เพิ่มคุณลักษณะตามฤดูกาล
        df['month'] = pd.to_datetime(df['date']).dt.month
        df['quarter'] = pd.to_datetime(df['date']).dt.quarter
        df['day_of_week'] = pd.to_datetime(df['date']).dt.dayofweek
        
        # ลบแถวที่มีค่า NaN (จากการสร้าง Lag และ Rolling Features)
        df = df.dropna()
        
        return df
    
    def check_data_leakage(self, df, target_col='price'):
        """ตรวจสอบ Data Leakage"""
        # คำนวณ Correlation Matrix
        corr_matrix = df.corr()
        
        # ตรวจสอบ Correlation กับเป้าหมาย
        target_corr = corr_matrix[target_col].sort_values(ascending=False)
        
        # ตรวจสอบว่ามีคุณลักษณะใดที่มี Correlation สูงผิดปกติ (>0.95)
        high_corr = target_corr[target_corr > 0.95]
        
        if len(high_corr) > 1:  # มากกว่า 1 เพราะเป้าหมายจะมี Correlation 1.0 กับตัวเอง
            print("⚠️ Warning: Possible data leakage detected!")
            print("Features with high correlation (>0.95):")
            print(high_corr)
            return False
        
        print("✓ No data leakage detected")
        return True
    
    def temporal_train_test_split(self, df, train_ratio=0.7, val_ratio=0.15):
        """แบ่งข้อมูลตามลำดับเวลา"""
        # เรียงข้อมูลตามวันที่
        df = df.sort_values('date')
        
        # คำนวณขนาดของแต่ละชุด
        n = len(df)
        train_size = int(n * train_ratio)
        val_size = int(n * val_ratio)
        
        # แบ่งข้อมูล
        train_data = df[:train_size]
        val_data = df[train_size:train_size+val_size]
        test_data = df[train_size+val_size:]
        
        # ตรวจสอบว่าไม่มีข้อมูลซ้ำซ้อน
        train_dates = set(train_data['date'])
        val_dates = set(val_data['date'])
        test_dates = set(test_data['date'])
        
        assert len(train_dates & val_dates) == 0, "Data leakage: Train and Val overlap"
        assert len(train_dates & test_dates) == 0, "Data leakage: Train and Test overlap"
        assert len(val_dates & test_dates) == 0, "Data leakage: Val and Test overlap"
        
        print(f"Train: {len(train_data)} samples ({train_data['date'].min()} to {train_data['date'].max()})")
        print(f"Val: {len(val_data)} samples ({val_data['date'].min()} to {val_data['date'].max()})")
        print(f"Test: {len(test_data)} samples ({test_data['date'].min()} to {test_data['date'].max()})")
        
        return train_data, val_data, test_data
    
    def classify_price_category(self, price):
        """จำแนกกลุ่มราคา"""
        if price <= 20:
            return 'low'
        elif price <= 50:
            return 'medium'
        else:
            return 'high'
    
    def train(self, df):
        """ฝึกโมเดลแบบ Stratified"""
        # เตรียมคุณลักษณะ
        df = self.prepare_features(df)
        
        # ตรวจสอบ Data Leakage
        self.check_data_leakage(df)
        
        # แบ่งข้อมูลตามเวลา
        train_data, val_data, test_data = self.temporal_train_test_split(df)
        
        # จำแนกกลุ่มราคา
        train_data['price_category'] = train_data['price'].apply(self.classify_price_category)
        
        # ฝึกโมเดลแยกสำหรับแต่ละกลุ่ม
        for category in ['low', 'medium', 'high']:
            print(f"\nTraining model for {category} price category...")
            
            # กรองข้อมูลตามกลุ่ม
            category_data = train_data[train_data['price_category'] == category]
            
            if len(category_data) == 0:
                print(f"No data for {category} category, skipping...")
                continue
            
            # เตรียม Features และ Target
            feature_cols = [col for col in category_data.columns 
                          if col not in ['date', 'price', 'price_category', 'crop']]
            X_train = category_data[feature_cols]
            y_train = category_data['price']
            
            # สร้างและฝึกโมเดล
            model = GradientBoostingRegressor(
                n_estimators=200,
                learning_rate=0.05,
                max_depth=4,
                min_samples_split=10,
                subsample=0.8,
                random_state=42
            )
            model.fit(X_train, y_train)
            
            self.models[category] = model
            
            # ประเมินประสิทธิภาพ
            train_pred = model.predict(X_train)
            train_r2 = r2_score(y_train, train_pred)
            train_mae = mean_absolute_error(y_train, train_pred)
            
            print(f"{category.capitalize()} - Train R²: {train_r2:.4f}, MAE: {train_mae:.2f}")
        
        return self

# ตัวอย่างการใช้งาน
if __name__ == "__main__":
    # โหลดข้อมูล
    df = pd.read_csv('price_data.csv')
    
    # สร้างและฝึกโมเดล
    model = PriceForecastingModel()
    model.train(df)
    
    # บันทึกโมเดล
    import pickle
    with open('model_c.pkl', 'wb') as f:
        pickle.dump(model, f)
```


ญ.3 ตัวอย่างโค้ด Model D (Harvest Decision - Thompson Sampling)

```python
import numpy as np
from scipy.stats import beta

class ThompsonSamplingHarvestDecision:
    def __init__(self, n_arms=3):
        """
        n_arms: จำนวนทางเลือก (3 = เก็บเกี่ยวทันที, รอ 7 วัน, รอ 14 วัน)
        """
        self.n_arms = n_arms
        # เริ่มต้นด้วย Beta(1, 1) สำหรับแต่ละทางเลือก
        self.alpha = np.ones(n_arms)
        self.beta_params = np.ones(n_arms)
        self.arm_names = ['harvest_now', 'wait_7_days', 'wait_14_days']
    
    def select_arm(self):
        """เลือกทางเลือกโดยใช้ Thompson Sampling"""
        # สุ่มตัวอย่างจาก Beta Distribution ของแต่ละทางเลือก
        samples = [
            beta.rvs(self.alpha[i], self.beta_params[i])
            for i in range(self.n_arms)
        ]
        
        # เลือกทางเลือกที่มีค่าสุ่มสูงสุด
        selected_arm = np.argmax(samples)
        
        return selected_arm, self.arm_names[selected_arm]
    
    def update(self, arm, reward):
        """
        อัปเดต Beta Distribution หลังจากได้รับ Reward
        
        Parameters:
        - arm: ทางเลือกที่เลือก (0, 1, หรือ 2)
        - reward: ผลตอบแทนที่ได้รับ (0-1, โดย 1 = ดีที่สุด)
        """
        # อัปเดต Alpha และ Beta
        self.alpha[arm] += reward
        self.beta_params[arm] += (1 - reward)
    
    def calculate_profit(self, current_price, expected_yield, 
                        storage_cost_per_day, quality_degradation_rate,
                        price_forecast_7d, price_forecast_14d):
        """
        คำนวณกำไรที่คาดการณ์สำหรับแต่ละทางเลือก
        
        Parameters:
        - current_price: ราคาปัจจุบัน (บาท/กก.)
        - expected_yield: ผลผลิตที่คาดหวัง (กก.)
        - storage_cost_per_day: ต้นทุนการเก็บรักษาต่อวัน (บาท)
        - quality_degradation_rate: อัตราการลดลงของคุณภาพต่อวัน (0-1)
        - price_forecast_7d: ราคาพยากรณ์ 7 วัน (บาท/กก.)
        - price_forecast_14d: ราคาพยากรณ์ 14 วัน (บาท/กก.)
        
        Returns:
        - profits: กำไรที่คาดการณ์สำหรับแต่ละทางเลือก
        """
        profits = []
        
        # ทางเลือก 1: เก็บเกี่ยวทันที
        profit_now = current_price * expected_yield
        profits.append(profit_now)
        
        # ทางเลือก 2: รอ 7 วัน
        quality_7d = 1 - (quality_degradation_rate * 7)
        storage_cost_7d = storage_cost_per_day * 7
        profit_7d = (price_forecast_7d * expected_yield * quality_7d) - storage_cost_7d
        profits.append(profit_7d)
        
        # ทางเลือก 3: รอ 14 วัน
        quality_14d = 1 - (quality_degradation_rate * 14)
        storage_cost_14d = storage_cost_per_day * 14
        profit_14d = (price_forecast_14d * expected_yield * quality_14d) - storage_cost_14d
        profits.append(profit_14d)
        
        return profits
    
    def make_decision(self, current_price, expected_yield,
                     storage_cost_per_day, quality_degradation_rate,
                     price_forecast_7d, price_forecast_14d):
        """
        ตัดสินใจเวลาเก็บเกี่ยว
        
        Returns:
        - decision: ทางเลือกที่แนะนำ
        - profits: กำไรที่คาดการณ์สำห���ับแต่ละทางเลือก
        - confidence: ความเชื่อมั่นในการตัดสินใจ
        """
        # คำนวณกำไรที่คาดการณ์
        profits = self.calculate_profit(
            current_price, expected_yield,
            storage_cost_per_day, quality_degradation_rate,
            price_forecast_7d, price_forecast_14d
        )
        
        # เลือกทางเลือกโดยใช้ Thompson Sampling
        arm_idx, arm_name = self.select_arm()
        
        # คำนวณความเชื่อมั่น (ใช้ค่าเฉลี่ยของ Beta Distribution)
        confidence = self.alpha[arm_idx] / (self.alpha[arm_idx] + self.beta_params[arm_idx])
        
        # สร้างผลลัพธ์
        result = {
            'recommended_action': arm_name,
            'confidence': confidence,
            'expected_profit': {
                'harvest_now': profits[0],
                'wait_7_days': profits[1],
                'wait_14_days': profits[2]
            },
            'profit_comparison': {
                'wait_7_days_vs_now': f"{((profits[1] - profits[0]) / profits[0] * 100):.1f}%",
                'wait_14_days_vs_now': f"{((profits[2] - profits[0]) / profits[0] * 100):.1f}%"
            },
            'thompson_sampling_state': {
                'harvest_now': {'alpha': self.alpha[0], 'beta': self.beta_params[0]},
                'wait_7_days': {'alpha': self.alpha[1], 'beta': self.beta_params[1]},
                'wait_14_days': {'alpha': self.alpha[2], 'beta': self.beta_params[2]}
            }
        }
        
        return result
    
    def evaluate_performance(self, decisions, actual_profits):
        """
        ประเมินประสิทธิภาพของโมเดล
        
        Parameters:
        - decisions: รายการทางเลือกที่เลือก
        - actual_profits: รายการกำไรจริงสำหรับแต่ละทางเลือก
        
        Returns:
        - metrics: ตัวชี้วัดประสิทธิภาพ
        """
        total_profit = 0
        max_possible_profit = 0
        correct_decisions = 0
        
        for i, (decision, profits) in enumerate(zip(decisions, actual_profits)):
            # กำไรที่ได้จริง
            actual_profit = profits[decision]
            total_profit += actual_profit
            
            # กำไรสูงสุดที่เป็นไปได้
            max_profit = max(profits)
            max_possible_profit += max_profit
            
            # ตรวจสอบว่าเลือกทางเลือกที่ดีที่สุดหรือไม่
            if actual_profit == max_profit:
                correct_decisions += 1
        
        # คำนวณตัวชี้วัด
        decision_accuracy = correct_decisions / len(decisions)
        profit_efficiency = total_profit / max_possible_profit
        regret = max_possible_profit - total_profit
        regret_rate = regret / max_possible_profit
        
        metrics = {
            'decision_accuracy': decision_accuracy,
            'profit_efficiency': profit_efficiency,
            'total_profit': total_profit,
            'max_possible_profit': max_possible_profit,
            'regret': regret,
            'regret_rate': regret_rate
        }
        
        return metrics

# ตัวอย่างการใช้งาน
if __name__ == "__main__":
    # สร้างโมเดล
    model = ThompsonSamplingHarvestDecision(n_arms=3)
    
    # ตัวอย่างการตัดสินใจ
    decision = model.make_decision(
        current_price=16.20,
        expected_yield=1200,
        storage_cost_per_day=50,
        quality_degradation_rate=0.01,
        price_forecast_7d=17.50,
        price_forecast_14d=17.20
    )
    
    print("Decision:", decision['recommended_action'])
    print("Confidence:", decision['confidence'])
    print("Expected Profits:", decision['expected_profit'])
    
    # สมมติว่าได้รับ Feedback จากผู้ใช้
    # (ในการใช้งานจริง จะได้รับหลังจากเกษตรกรเก็บเกี่ยวและขายแล้ว)
    actual_profit = 21360  # กำไรจริงที่ได้รับ
    max_possible_profit = 21360  # กำไรสูงสุดที่เป็นไปได้
    reward = actual_profit / max_possible_profit  # Normalize เป็น 0-1
    
    # อัปเดตโมเดล
    arm_idx = model.arm_names.index(decision['recommended_action'])
    model.update(arm_idx, reward)
    
    # บันทึกโมเดล
    import pickle
    with open('model_d.pkl', 'wb') as f:
        pickle.dump(model, f)
```

---

สิ้นสุดภาคผนวก

