






Farmme ระบบปัญญาประดิษฐ์สำหรับการเกษตรอัจฉริยะ



จัดทำโดย
นายภัทรพงษ์
เพ็งทวี 
65041785 
นายกิตติพัฒน์
เปรมจิตร์ 
65054917 
นางสาวอทิตยา
ชัยศิริวัฒนาศัย
65076751 





เสนอ
ผู้ช่วยศาสตราจารย์ มาสวีร์ 
มาศดิศรโชติ
อาจารย์ทิพย์อรุณ
เขี้ยวแก้ว
อาจารย์ตรีภพ
วิศาลวณิชธัญ






รายงานฉบับนี้เป็นส่วนหนึ่งของการเรียน
รายวิชาวิทยาการข้อมูล รหัส CSI410 รายวิชาการเรียนรู้ด้วยเครื่อง รหัส CSI411
รายวิชาการวิเคราะห์ข้อมูลและพัฒนาแบบจำลองธุรกิจ รหัส CSI413
และรายวิชาดาต้าวิชวลไลเซชัน รหัส CSI414 
สาขาวิชาวิทยาการคอมพิวเตอร์และนวัตกรรมการพัฒนาซอฟต์แวร์ (CSI)
ภาคเรียนที่ 1 ปีการศึกษา 2568 มหาวิทยาลัยศรีปทุม บางเขน

คำนำ
เอกสารฉบับนี้จัดทำขึ้นเพื่อนำเสนอระบบปัญญาประดิษฐ์สำหรับการเกษตรอัจฉริยะ (Farmme) ซึ่งเป็นระบบที่พัฒนาขึ้นเพื่อช่วยเหลือเกษตรกรในการตัดสินใจเกี่ยวกับการเพาะปลูก ตั้งแต่การเลือกพืช การกำหนดช่วงเวลาปลูก การคาดการณ์ราคา ไปจนถึงการตัดสินใจเก็บเกี่ยว

	ระบบนี้ประกอบด้วยโมเดล Machine Learning 4 โมเดลหลัก ที่ทำงานร่วมกันอย่างเป็นระบบ โดยแต่ละโมเดลมีหน้าที่เฉพาะทางและเชื่อมโยงกันเป็น Pipeline ที่สมบูรณ์ ระบบได้รับการพัฒนาโดยคำนึงถึงความถูกต้องของข้อมูล การป้องกัน Data Leakage และความเหมาะสมกับบริบทการเกษตรไทย

	คณะผู้จัดทำหวังเป็นอย่างยิ่งว่าเอกสารฉบับนี้จะเป็นประโยชน์ต่อผู้ที่สนใจในการประยุกต์ใช้ปัญญาประดิษฐ์ในภาคการเกษตร และเป็นแนวทางในการพัฒนาระบบที่คล้ายคลึงกันต่อไป














Table of contents
บทที่ 1 : บทนำ	1
1.1 ความเป็นมาและความสำคัญของปัญหา	1
1.2 วัตถุประสงค์ของโครงการ	2
โดยวัตถุประสงค์หลักที่เน้น คือ การสร้างระบบ Farmme ที่ใช้ Machine Learning ช่วยเกษตรกรตัดสินใจตั้งแต่ “เลือกปลูกอะไร → ปลูกเมื่อไร → ราคาน่าจะเป็นเท่าไร → ควรเก็บเกี่ยวเมื่อไร”	2
1.2.1 วัตถุประสงค์เฉพาะ (4 ระบบหลัก)	2
1.2.2 วัตถุประสงค์ด้านเทคนิค	3
1.3 ขอบเขตของโครงการ	3
1.3.1 ข้อจำกัด	4
1.4 ประโยชน์ที่คาดว่าจะได้รับ	4
1.5 นิยามศัพท์เฉพาะ	5
บทที่ 2: ทฤษฎีหรืองานที่เกี่ยวข้อง	7
2.1 บทนำ	7
2.2 Machine Learning ในการเกษตร	7
2.2.1 บริบททางประวัติศาสตร์ การประยุกต์ใช้ Machine Learning กับการเกษตรได้วิวัฒนาการผ่านหลายระยะที่ชัดเจน	7
2.2.2 ระบบการแนะนำพืช	8
2.2.3 การพยากรณ์ช่วงเวลาปลูก	10
2.2.4 การพยากรณ์ราคาการเกษตร	11
2.2.5 การเพิ่มประสิทธิภาพเวลาเก็บเกี่ยว	13
2.3 การเพิ่มประสิทธิภาพหลายวัตถุประสงค์	15
2.3.1 รากฐานทางทฤษฎี	15
2.3.2 อัลกอริทึมวิวัฒนาการหลายวัตถุประสงค์ (MOEAs)	16
2.3.3 รายละเอียดอัลกอริทึม NSGA-II	17
2.3.4 การประยุกต์ใช้ในการเกษตร	18
2.3.5 แนวทางไฮบริด ML-MOEA	19
2.4 การพยากรณ์อนุกรมเวลา	20
2.4.1 วิธีอนุกรมเวลาแบบคลาสสิก	20
2.4.2 แมชชีนเลิร์นนิงสำหรับอนุกรมเวลา	21
2.4.3 Deep Learning สำหรับอนุกรมเวลา	22
2.4.4 การพยากรณ์อนุกรมเวลาหลายตัวแปร	23
2.4.5 ตัวชี้วัดการประเมิน	24
2.5 มัลติ-อาร์มด์ แบนดิตและรีอินฟอร์ซเมนต์เลิร์นนิง	24
2.5.1 ปัญหามัลติ-อาร์มด์ แบนดิต	24
2.5.2 อัลกอริทึมแบนดิตแบบคลาสสิก	25
2.5.3 Thompson Sampling (แนวทางแบบเบย์)	26
2.5.4 Contextual Bandits	28
2.5.5 รากฐานรีอินฟอร์ซเมนต์เลิร์นนิง	28
2.5.6 อัลกอริทึม RL แบบไม่มีแบบจำลอง	29
2.5.7 การประยุกต์ใช้ในการเกษตร	30
2.6 การรั่วไหลของข้อมูลในแมชชีนเลิร์นนิง	32
2.6.1 คำจำกัดความและประเภท	32
2.6.2 การรั่วไหลทางเวลาโดยละเอียด	33
2.6.3 วิธีการตรวจจับ	34
2.6.4 กลยุทธ์การป้องกัน	36
2.6.5 การรั่วไหลในเกษตร ML	37
2.6.6 กรอบการประเมินที่ซื่อสัตย์	38
2.7 ระบบและแพลตฟอร์มที่เกี่ยวข้อง	40
2.7.1 ระบบสนับสนุนการตัดสินใจทางการเกษตรเชิงพาณิชย์	40
2.7.2 ต้นแบบการวิจัย	41
2.7.3 แพลตฟอร์มการเกษตร ML	42
2.7.4 การเปรียบเทียบกับ FarmMe	43
2.8 ช่องว่างและโอกาสการวิจัย	44
2.8.1 ช่องว่างที่ระบุ	44
2.8.2 ทิศทางการวิจัยในอนาคต	45
2.9 สรุป	47
บทที่ 3 : การดำเนินงาน / กระบวนการ	49
3.1 ภาพรวม การสร้างข้อมูลสังเคราะห์ด้วยการเร่งความเร็วโดย GPU	49
3.1.1 สถาปัตยกรรมระบบ	49
3.1.2 โครงสร้างพื้นฐานทางเทคนิค	49
3.1.3 การเริ่มต้น GPU และการจัดการหน่วยความจำ	51
3.2 การสร้างแบบจำลองความสัมพันธ์เชิงพื้นที่	52
3.2.1 เมทริกซ์ระยะทางทางภูมิศาสตร์	52
3.2.2 ความแปรปรวนร่วมเชิงพื้นที่ด้วยการเร่งความเร็วโดย GPU	53
3.2.3 การให้น้ำหนักตามระยะทาง	54
3.3 การสร้างแบบจำลองการพึ่งพาทางเวลา	55
3.3.1 กระบวนการออโตรีเกรสซีฟด้วยความสัมพันธ์เชิงพื้นที่	55
3.3.2 การใช้งานสำรองบน CPU	57
3.4 การสร้างข้อมูลสภาพอากาศ	58
3.4.1 ระบบสภาพอากาศหลายตัวแปร	58
3.4.2 กระบวนการสร้างสภาพอากาศ	59
3.4.3 รูปแบบตามฤดูกาล	60
3.5 การสร้างข้อมูลราคา	62
3.5.1 โครงสร้างราคาหลายระดับ	62
3.5.2 องค์ประกอบการสร้างราคา	62
3.5.3 การเปลี่ยนแปลงราคาเฉพาะตลาด	64
3.5.4 ความสัมพันธ์เชิงพื้นที่ของราคา	65
3.5.5 ความผันผวนของราคาตามประเภทพืช	66
3.6 การสร้างข้อมูลการเพาะปลูก	66
3.6.1 โครงสร้างบันทึกการเพาะปลูก	66
3.6.2 เมทริกซ์ความเข้ากันได้ของพืช	67
3.6.3 การสร้างแบบจำลองผลผลิต	69
3.6.4 การคำนวณต้นทุนและรายได้	70
3.7 การสร้างตัวชี้วัดเศรษฐกิจ	72
3.7.1 ตัวแปรเศรษฐกิจมหภาค	72
3.7.2 โครงสร้างข้อมูลเศรษฐกิจ	73
3.7.3 การสร้างอนุกรมเวลาทางเศรษฐกิจ	73
3.7.4 โครงสร้างความสัมพันธ์ข้าม	76
3.8 คุณภาพข้อมูลและการตรวจสอบ	76
3.8.1 การตรวจสอบคุณภาพ	76
3.8.2 การยืนยันคุณสมบัติทางสถิติ	78
3.8.3 การยืนยันความสัมพันธ์เชิงพื้นที่	79
3.9 กระบวนการวิศวกรรมคุณลักษณะ	80
3.9.1 ภาพรวมของวิศวกรรมคุณลักษณะ	80
3.9.2 คุณลักษณะทางเวลา	81
3.9.3 คุณลักษณะแล็ก (พร้อมการป้องกันการรั่วไหลของข้อมูล)	83
3.9.4 คุณลักษณะการรวมสภาพอากาศ	87
3.9.5 คุณลักษณะราคา	89
3.9.6 การเข้ารหัสตามหมวดหมู่	91
3.9.7 การปรับขนาดและมาตรฐานคุณลักษณะ	94
3.10 กรอบการป้องกันการรั่วไหลของข้อมูล	95
3.10.1 ประเภทของการรั่วไหลของข้อมูล	95
3.10.2 ระบบตรวจจับการรั่วไหล	96
3.10.3 รายการตรวจสอบวิศวกรรมคุณลักษณะที่ปลอดภัย	98
3.11 สถิติและลักษณะของชุดข้อมูล	99
3.11.1 ขนาดชุดข้อมูลสุดท้าย	99
3.11.2 ลักษณะการกระจายข้อมูล	100
3.11.3 การวิเคราะห์ความสัมพันธ์	101
3.12 การวิเคราะห์ประสิทธิภาพการคำนวณ	102
3.12.1 การแบ่งเวลาในการสร้าง	102
3.12.2 โปรไฟล์การใช้หน่วยความจำ	103
3.12.3 การวิเคราะห์การขยายขนาด	103
3.13 สรุปและประเด็นสำคัญ	104
3.13.1 ความสำเร็จทางเทคนิค	104
3.13.2 ตัวชี้วัดคุณภาพชุดข้อมูล	104
3.13.3 ข้อจำกัดและการปรับปรุงในอนาคต	105
บทที่ 4 : ผลลัพท์ที่ได้	106
บทที่ 5: สรุปผล	120
5.1 บทนำ	120
5.2 โมเดล A: ผลการแนะนำพืชผล	121
5.2.1 สรุปประสิทธิภาพ	121
5.2.2 การวิเคราะห์ข้อผิดพลาดตามประเภทพืช	123
5.2.3 การวิเคราะห์ความสำคัญของฟีเจอร์	124
5.3 โมเดล B: ผลการกำหนดช่วงเวลาปลูก	126
5.3.1 สรุปประสิทธิภาพ	126
5.3.2 การวิเคราะห์เมทริกซ์ความสับสน	128
5.3.3 การวิเคราะห์ตามเวลา	129
5.4 โมเดล C: ผลการพยากรณ์ราคา	130
5.4.1 การเปรียบเทียบ Baseline กับแบบปรับปรุง	130
5.4.2 การวิเคราะห์การลดอคติ	132
5.4.3 การวิเคราะห์ความแข็งแกร่ง	134
5.5 โมเดล D: ผลการตัดสินใจเก็บเกี่ยว	135
5.5.1 สรุปประสิทธิภาพ	135
5.5.2 การวิเคราะห์เส้นโค้งการเรียนรู้	137
5.5.3 การกระจายการกระทำ	137
5.6 การวิเคราะห์ข้ามโมเดล	138
5.6.1 การพึ่งพาโมเดล	138
5.6.2 ประสิทธิภาพไปป์ไลน์แบบครบวงจร	140
5.6.3 การวิเคราะห์การแพร่กระจายข้อผิดพลาด	141
5.7 กรณีศึกษาจากโลกจริง	142
5.7.1 กรณีศึกษา 1: เกษตรกรปลูกข้าวในภาคกลางของประเทศไทย	142
5.7.2 กรณีศึกษา 2: เกษตรกรปลูกผักในภาคเหนือของประเทศไทย	144
5.7.3 กรณีศึกษา 3: เกษตรกรเชิงพาณิชย์ที่มีการกระจายความเสี่ยง	146
5.8 การศึกษา Ablation	149
5.8.1 โมเดล A: การตัดฟีเจอร์	149
5.8.2 โมเดล C: การตัดปัจจัยภายนอก	150
5.8.3 โมเดล D: การตัดอัตราการสำรวจ	151
5.9 การทดสอบความมีนัยสำคัญทางสถิติ	152
5.9.1 การเปรียบเทียบประสิทธิภาพโมเดล	152
5.9.2 ช่วงความเชื่อมั่น	154
5.9.3 ผลลัพธ์การตรวจสอบข้าม	155
5.10 เมตริกประสิทธิภาพระบบ	155
5.10.1 การวิเคราะห์ความหน่วง	156
5.10.2 การวิเคราะห์ปริมาณงาน	157
5.10.3 การใช้ทรัพยากร	158
5.11 ข้อจำกัดและภัยคุกคามต่อความถูกต้อง	159
5.11.1 ความถูกต้องภายใน	159
5.11.2 ความถูกต้องภายนอก	160
5.11.3 ความถูกต้องของโครงสร้าง	161
5.12 สรุป	161





บทที่ 1 : บทนำ

1.1 ความเป็นมาและความสำคัญของปัญหา

ภาคการเกษตรเป็นรากฐานสำคัญของเศรษฐกิจไทย โดยมีเกษตรกรไทยมากกว่า 11 ล้านครัวเรือนที่พึ่งพาการเกษตรเป็นอาชีพหลัก อย่างไรก็ตาม เกษตรกรส่วนใหญ่ยังคงเผชิญกับปัญหาและความท้าทายหลายประการ ได้แก่

การตัดสินใจเลือกพืชที่ไม่เหมาะสม เกษตรกรมักเลือกปลูกพืชตามประสบการณ์หรือตามกระแส โดยไม่ได้พิจารณาปัจจัยสำคัญอย่างครบถ้วน เช่น สภาพดิน สภาพอากาศ งบประมาณ และความต้องการของตลาด ส่งผลให้ผลผลิตไม่เป็นไปตามที่คาดหวังและขาดทุน
การกำหนดช่วงเวลาปลูกที่ไม่เหมาะสม การปลูกในช่วงเวลาที่ไม่เหมาะสมอาจทำให้พืชเจริญเติบโตไม่ดี ได้รับผลกระทบจากภัยธรรมชาติ หรือเก็บเกี่ยวในช่วงที่ราคาตกต่ำ
ความไม่แน่นอนของราคาผลผลิต ราคาผลผลิตทางการเกษตรมีความผันผวนสูง เกษตรกรไม่สามารถคาดการณ์ราคาในอนาคตได้ ทำให้วางแผนการผลิตและการเงินได้ยาก
การตัดสินใจเก็บเกี่ยวที่ไม่เหมาะสม การเก็บเกี่ยวเร็วหรือช้าเกินไปส่งผลต่อคุณภาพและราคาขาย การตัดสินใจว่าควรเก็บเกี่ยวทันทีหรือรอให้ราคาดีขึ้นเป็นเรื่องที่ท้าทาย

ปัญหาเหล่านี้ส่งผลให้เกษตรกรมีรายได้ไม่แน่นอน ขาดทุน และไม่สามารถพัฒนาคุณภาพชีวิตได้ ในยุคที่เทคโนโลยีดิจิทัลและปัญญาประดิษฐ์ (Artificial Intelligence) ได้รับการพัฒนาอย่างก้าวกระโดด การนำเทคโนโลยีเหล่านี้มาประยุกต์ใช้ในภาคการเกษตรจึงเป็นแนวทางที่มีศักยภาพในการแก้ไขปัญหาดังกล่าว


1.2 วัตถุประสงค์ของโครงการ

พัฒนาระบบแนะนำพืช (Crop Recommendation System) 
พัฒนาระบบคาดการณ์ช่วงเวลาปลูก (Planting Window Prediction) 
พัฒนาระบบพยากรณ์ราคา (Price Forecasting System) 
พัฒนาระบบตัดสินใจเก็บเกี่ยว (Harvest Decision System) 
บูรณาการระบบทั้ง 4 ส่วนเข้าด้วยกัน เป็น End-to-End Pipeline ที่สามารถให้คำแนะนำตั้งแต่ก่อนปลูกจนถึงหลังเก็บเกี่ยว
พัฒนาแอปพลิเคชันและแดชบอร์ด ที่ใช้งานง่าย เข้าถึงได้สะดวก และแสดงผลข้อมูลอย่างชัดเจน
โดยวัตถุประสงค์หลักที่เน้น คือ การสร้างระบบ Farmme ที่ใช้ Machine Learning ช่วยเกษตรกรตัดสินใจตั้งแต่ “เลือกปลูกอะไร → ปลูกเมื่อไร → ราคาน่าจะเป็นเท่าไร → ควรเก็บเกี่ยวเมื่อไร”


1.2.1 วัตถุประสงค์เฉพาะ (4 ระบบหลัก)

1) แนะนำพืชที่เหมาะกับฟาร์ม Crop Recommendation System (Model A)
ดูข้อมูลฟาร์ม ดิน พื้นที่ งบประมาณ
คาดการณ์กำไร (ROI)
แนะนำพืช 3–5 อันดับที่เหมาะที่สุด
ประโยชน์: ช่วยเกษตรกรเลือกปลูกแบบ “มีเหตุผลและคุ้มทุนที่สุด”
2) แนะนำเวลาปลูกที่ดีที่สุด Planting Window Prediction (Model B)
บอกว่าปลูกช่วงนี้ดีหรือไม่ดี
ใช้ข้อมูลอากาศและดินประกอบ
ประโยชน์: ลดโอกาสพืชเสียหายจากฝนแล้ง/ฝนหนัก
3) คาดการณ์ช่วงเก็บเกี่ยว Harvest Decision System (Model C)
ดูราคาย้อนหลัง
ดูข้อมูลอากาศ
ดูเศรษฐกิจ เช่น ค่าน้ำมัน ปุ๋ย ส่งออก
ประโยชน์: ช่วยวางแผนล่วงหน้า จะขายตอนไหน ได้ราคาเท่าไร
4) พยากรณ์ราคา Price Forecasting System (Model D)
บอกว่า “เก็บวันนี้ดีไหม” หรือ “รออีก 3 วันจะคุ้มกว่า”
วิเคราะห์กำไรที่จะได้
ประโยชน์: เพิ่มรายได้จากการเลือกจังหวะเก็บเกี่ยวให้ถูกต้อง
1.2.2 วัตถุประสงค์ด้านเทคนิค
ป้องกันโมเดลหลอกตัวเองด้วยข้อมูลอนาคต (Data Leakage)
ลดปัญหาโมเดลมัวแต่ยึดติดข้อมูลราคาในอดีต
ทำให้ระบบอธิบายได้ว่า “ทำไมถึงแนะนำแบบนี้”
ระบบต้องใช้งานในความเป็นจริงได้แม้ข้อมูลขาดหรือ API ล่ม

1.3 ขอบเขตของโครงการ

ขอบเขตด้านพื้นที่ โครงการนี้มุ่งเน้นพื้นที่การเกษตรในประเทศไทย ครอบคลุม 77 จังหวัด
	ขอบเขตด้านพืช ระบบรองรับพืชเศรษฐกิจหลักของไทย จำนวน 46 ชนิด แบ่งเป็น พืชผัก พืชไร่ พืชสวน และพืชเครื่องเทศ
	ขอบเขตด้านข้อมูล
		ข้อมูลการเพาะปลูก 6,226 records
		ข้อมูลลักษณะพืช 46 crops
		ข้อมูลสภาพอากาศ 56,287 records
		ข้อมูลราค 2,289,492 records
		ข้อมูลเศรษฐกิจ 731 records
	ขอบเขตด้านเทคนิค ใช้ Machine Learning Algorithms ได้แก่ XGBoost, Logistic Regression, NSGA-II, และ Thompson Sampling 
ใช้ข้อมูลสังเคราะห์เพราะยังไม่มีข้อมูลจริง
แบบจำลองเน้นง่ายและอธิบายได้
ใช้ GPU ตอนฝึก แต่รองรับ CPU เวลานำไปใช้งานจริง
ยังเป็นระบบสแตนด์อโลน ยังไม่เชื่อมกับเมืองอัจฉริยะเต็มรูปแบบ
1.3.1 ข้อจำกัด
ใช้ข้อมูลจำลอง
ใช้ตัวแปรอากาศพื้นฐาน
ยังไม่ทดสอบกับเกษตรกรจริง
ยังไม่ใช่ระบบที่พร้อมขยายทั่วประเทศในทันที


1.4 ประโยชน์ที่คาดว่าจะได้รับ

ประโยชน์ต่อเกษตรกร
เพิ่มรายได้จากการเลือกพืชและช่วงเวลาที่เหมาะสม
ลดต้นทุนและความเสี่ยงจากการวางแผนที่ดีขึ้น
ตัดสินใจได้ดีขึ้นด้วยข้อมูลที่เชื่อถือได้

ประโยชน์ต่อภาคการเกษตร
เพิ่มประสิทธิภาพการผลิต
ความมั่นคงทางอาหาร
การพัฒนาที่ยั่งยืน
ประโยชน์ทางวิชาการ
องค์ความรู้ใหม่ในการประยุกต์ใช้ AI ในภาคการเกษตรไทย
แนวทางการพัฒนาระบบที่คล้ายคลึงกัน
การป้องกัน Data Leakage ในการสร้างโมเดล ML

1.5 นิยามศัพท์เฉพาะ

Machine Learning (ML) การเรียนรู้ของเครื่อง เป็นสาขาหนึ่งของปัญญาประดิษฐ์ที่ให้คอมพิวเตอร์สามารถเรียนรู้จากข้อมูลและปรับปรุงประสิทธิภาพได้เองโดยไม่ต้องเขียนโปรแกรมโดยตรง
Data Leakage การรั่วไหลของข้อมูล หมายถึงการที่ข้อมูลที่ไม่ควรมีในขั้นตอนการทำนาย (เช่น ข้อมูลอนาคต) ถูกนำมาใช้ในการฝึกโมเดล ทำให้ผลการประเมินดีเกินจริง
Feature Engineering กระบวนการสร้างและคัดเลือกตัวแปร (features) ที่เหมาะสมจากข้อมูลดิบเพื่อใช้ในการฝึกโมเดล
ROI (Return on Investment) ผลตอบแทนจากการลงทุน คำนวณจาก (กำไร / ต้นทุน) × 100%
F1-Score ค่าวัดประสิทธิภาพของโมเดล Classification ที่พิจารณาทั้ง Precision และ Recall
R² (R-squared) ค่าสัมประสิทธิ์การตัดสินใจ วัดความสามารถของโมเดลในการอธิบายความแปรปรวนของข้อมูล
XGBoost: Extreme Gradient Boosting อัลกอริทึม Machine Learning ที่มีประสิทธิภาพสูงสำหรับปัญหา Regression และ Classification
Thompson Sampling อัลกอริทึมสำหรับปัญหา Multi-Armed Bandit ที่ใช้ในการตัดสินใจภายใต้ความไม่แน่นอน












บทที่ 2: ทฤษฎีหรืองานที่เกี่ยวข้อง

2.1 บทนำ

บทนี้ให้การทบทวนอย่างครอบคลุมเกี่ยวกับรากฐานทางทฤษฎีและงานที่เกี่ยวข้องซึ่งเป็นข้อมูลให้กับระบบ Farmme เราจัดการทบทวนออกเป็นห้าพื้นที่หลัก
แมชชีนเลิร์นนิงในการเกษตร (ส่วนที่ 3.2)
การเพิ่มประสิทธิภาพหลายวัตถุประสงค์ (ส่วนที่ 3.3)
การพยากรณ์อนุกรมเวลา (ส่วนที่ 3.4)
มัลติ-อาร์มด์ แบนดิตและรีอินฟอร์ซเมนต์เลิร์นนิง (ส่วนที่ 3.5)
การรั่วไหลของข้อมูลในแมชชีนเลิร์นนิง (ส่วนที่ 3.6)
แต่ละส่วนทบทวนวรรณกรรมที่เกี่ยวข้อง สร้างรากฐานทางทฤษฎี และระบุช่องว่างที่ระบบ Farmme แก้ไข

2.2 Machine Learning ในการเกษตร
2.2.1 บริบททางประวัติศาสตร์ การประยุกต์ใช้ Machine Learning กับการเกษตรได้วิวัฒนาการผ่านหลายระยะที่ชัดเจน
ระยะที่ 1 ระบบผู้เชี่ยวชาญ (ทศวรรษ 1980-1990)
ระบบตามกฎสำหรับการเลือกพืชและการจัดการศัตรูพืช
ถูกจำกัดโดยวิศวกรรมความรู้ด้วยมือ
ตัวอย่าง COMAX (การจัดการฝ้าย), GOSSYM (การจำลองพืช)
ระยะที่ 2 แบบจำลองทางสถิติ (ทศวรรษ 1990-2000)
การถดถอยเชิงเส้นสำหรับการพยากรณ์ผลผลิต
การถดถอยโลจิสติกสำหรับการจำแนกโรค
ความสามารถในการสร้างคุณลักษณะที่จำกัด
ระยะที่ 3 ยุคMachine Learning  (ทศวรรษ 2000-2010)
Support Vector Machines (SVM) สำหรับการจำแนกพืช
Random Forests สำหรับการพยากรณ์ผลผลิต
Neural networks สำหรับการตรวจจับโรคพืช基于ภาพ
ระยะที่ 4 Deep Learning และ Big Data (ทศวรรษ 2010-ปัจจุบัน)
Convolutional Neural Networks (CNN) สำหรับการตรวจสอบพืช
Recurrent Neural Networks (RNN) สำหรับการพยากรณ์อนุกรมเวลา
การบูรณาการภาพดาวเทียม, เซนเซอร์ IoT, และข้อมูลสภาพอากาศ
2.2.2 ระบบการแนะนำพืช
แนวทางดั้งเดิม
ระบบตามกฎ
ใช้ความรู้ผู้เชี่ยวชาญที่เข้ารหัสเป็นกฎ if-then
ตัวอย่าง "IF soil_pH > 7 AND rainfall > 1000mm THEN recommend_rice"
ข้อจำกัด ไม่สามารถจัดการความไม่แน่นอน, บำรุงรักษายาก
แบบจำลองทางสถิติ
การถดถอยเชิงเส้น Yield = β₀ + β₁×rainfall + β₂×temperature + ε
ข้อจำกัด สมมติความสัมพันธ์เชิงเส้น, ไม่สามารถจับการโต้ตอบที่ซับซ้อน
แนวทาง ML สมัยใหม่
ระบบการจำแนก
ถือว่าการแนะนำพืชเป็นการจำแนกหลายคลาส
อัลกอริทึม Decision Trees, Random Forest, SVM, Neural Networks
ตัวอย่าง Puthumalar et al. (2016) - Naive Bayes สำหรับการทำนายพืช (ความแม่นยำ: 88%)
ระบบการถดถอย
ทำนายผลผลิตสำหรับแต่ละพืช, แนะนำพืชที่ให้ผลผลิตสูงสุด
อัลกอริทึม Linear Regression, Ridge, Lasso, XGBoost
ตัวอย่าง Khosla et al. (2010) - เกษตรแม่นยำโดยใช้แบบจำลองการถดถอย
วิธีเอนเซมเบิล
รวมหลายแบบจำลองสำหรับการทำนายที่แข็งแกร่ง
ตัวอย่าง Ramesh & Vardhan (2015) - เอนเซมเบิลของ DT, RF, SVM (ความแม่นยำ: 92%)
ข้อจำกัดของระบบที่มีอยู่
การเพิ่มประสิทธิภาพวัตถุประสงค์เดียว (มักจะเป็นกำไรหรือผลผลิต)
ไม่มีการพิจารณาความเสี่ยงหรือความยั่งยืน
การจัดการข้อจำกัดของเกษตรกรที่จำกัด (งบประมาณ, ที่ดิน, ประสบการณ์)
ขาดการตีความได้ในแบบจำลองที่ซับซ้อน
2.2.3 การพยากรณ์ช่วงเวลาปลูก
รากฐานทางการเกษตร
ช่วงเวลาปลูกที่เหมาะสมที่สุดขึ้นอยู่กับอุณหภูมิ, ปริมาณน้ำฝน, และความยาววัน
การปลูกเร็ว/ช้าสามารถลดผลผลิตได้ 20-50%
ความแตกต่างตามภูมิภาคและเฉพาะพืช
แนวทาง ML
แบบจำลองการจำแนก
การจำแนกไบนารี เหมาะสมที่สุด vs ไม่เหมาะสมที่สุด
หลายคลาส เร็ว/เหมาะสมที่สุด/ช้า
คุณลักษณะ สภาพอากาศย้อนหลัง, ความชื้นในดิน, วิทยาการพืช
การวิเคราะห์อนุกรมเวลา
แบบจำลอง ARIMA สำหรับการพยากรณ์สภาพอากาศ
การแยกส่วนตามฤดูกาลสำหรับรูปแบบการปลูก
ตัวอย่าง Lobell et al. (2007) - แนวโน้มสภาพอากาศและผลผลิตพืช
แนวทางแบบไฮบริด
รวมแบบจำลองการเติบโตของพืชกับ ML
ตัวอย่าง DSSAT (Decision Support System for Agrotechnology Transfer)
ข้อจำกัด ต้องการการปรับเทียบอย่างกว้างขวาง, คำนวณแพง


ช่องว่างการวิจัย
การบูรณาการการพยากรณ์สภาพอากาศแบบเรียลไทม์ที่จำกัด
การพิจารณาเวลาตลาดไม่เพียงพอ
ขาดคำแนะนำเฉพาะจังหวัดสำหรับประเทศไทย
2.2.4 การพยากรณ์ราคาการเกษตร
รากฐานทางเศรษฐกิจ
ราคาการเกษตรแสดงความผันผวนสูง (σ = 15-30%)
รูปแบบตามฤดูกาล (ฤดูเก็บเกี่ยว → ราคาตก)
พลวัตอุปทาน-อุปสงค์
การเปลี่ยนแปลงจากภายนอก (สภาพอากาศ, นโยบาย, ตลาดโลก)
แบบจำลองเศรษฐมิติดั้งเดิม
ARIMA (AutoRegressive Integrated Moving Average)
P(t) = c + φ₁P(t-1) + ... + φₚP(t-p) + θ₁ε(t-1) + ... + θₑε(t-q) + ε(t)
จุดแข็ง เรียบง่าย, ตีความได้, ทำงานสำหรับอนุกรมคงที่
ข้อจำกัด ไม่สามารถจับความสัมพันธ์ไม่เชิงเส้น
GARCH (Generalized AutoRegressive Conditional Heteroskedasticity)
สร้างแบบจำลองความผันผวนที่เปลี่ยนแปลงตามเวลา
σ²(t) = α₀ + α₁ε²(t-1) + β₁σ²(t-1)
ใช้สำหรับการจัดการความเสี่ยงและการกำหนดราคาตัวเลือก
Vector Autoregression (VAR)
สร้างแบบจำลองหลายอนุกรมเวลาพร้อมกัน
จับความสัมพันธ์ข้ามสินค้า
ตัวอย่าง ราคาข้าวสาลีส่งผลต่อราคาแป้ง
แนวทางแมชชีนเลิร์นนิง
Support Vector Regression (SVR)
การถดถอยไม่เชิงเส้นโดยใช้เคล็ดลับเคอร์เนล
ตัวอย่าง Tian et al. (2015) - การพยากรณ์ราคาข้าวโพด (RMSE: 0.12)
Random Forest Regression
เอนเซมเบิลของต้นไม้ตัดสินใจ
จัดการความสัมพันธ์ไม่เชิงเส้นและการโต้ตอบ
ตัวอย่าง Ribeiro & Oliveira (2011) - การทำนายราคาถั่วเหลือง
Neural Networks
Multi-Layer Perceptron (MLP) สำหรับการทำนายราคา
LSTM (Long Short-Term Memory) สำหรับข้อมูลลำดับ
ตัวอย่าง Xiong et al. (2018) - LSTM สำหรับสินค้าเกษตร (MAE: 2.3%)
Gradient Boosting (XGBoost, LightGBM)
ล้ำสมัยสำหรับข้อมูลตาราง
จัดการค่าที่ขาดหาย, การโต้ตอบของคุณลักษณะ
ตัวอย่าง Chen & Guestrin (2016) - กรอบงาน XGBoost


การบูรณาการปัจจัยภายนอก
ข้อมูลสภาพอากาศ (อุณหภูมิ, ปริมาณน้ำฝน) → การเปลี่ยนแปลงอุปทาน
ตัวชี้วัดเศรษฐกิจ (GDP, เงินเฟ้อ) → การเปลี่ยนแปลงอุปสงค์
ตัวแปรนโยบาย (เงินอุดหนุน, ภาษี) → การแทรกแซงตลาด
ตัวอย่าง Ubilava (2012) - ผลกระทบของเอลนีโญต่อราคาการเกษตร
ช่องว่างการวิจัย
อคติทางเวลาสูง (การพึ่งพาราคาล่าสุดเกินไป)
ความแข็งแกร่งต่อการเปลี่ยนแปลงตลาดจำกัด
การบูรณาการข้อมูลสภาพอากาศและเศรษฐกิจไม่เพียงพอ
ขาดวิธีการวัดอคติเชิงปริมาณ
2.2.5 การเพิ่มประสิทธิภาพเวลาเก็บเกี่ยว
การพิจารณาทางการเกษตร
ตัวชี้วัดความสมบูรณ์ของพืช (สี, ปริมาณความชื้น, ระดับน้ำตาล)
ช่วงเวลาสภาพอากาศ (หลีกเลี่ยงฝนระหว่างเก็บเกี่ยว)
ความพร้อมใช้ของแรงงาน
ความจุในการเก็บรักษา
การพิจารณาทางเศรษฐกิจ
ราคาตลาดปัจจุบัน vs ราคาที่คาดหวังในอนาคต
ค่าใช้จ่ายในการเก็บรักษา (0.1-0.3% ต่อวัน)
การลดลงของคุณภาพเมื่อเวลาผ่านไป
ต้นทุนโอกาสของการเก็บเกี่ยวล่าช้า
แนวทางการเพิ่มประสิทธิภาพ
Dynamic Programming
ปัญหาการหยุดที่เหมาะสมที่สุด
V(t) = max{harvest_now, E[V(t+1)]}
ข้อจำกัด ต้องการการพยากรณ์ราคาที่แม่นยำ, คำนวณแพง
Real Options Theory
ถือว่าการตัดสินใจเก็บเกี่ยวเป็นตัวเลือกทางการเงิน
กรอบ Black-Scholes ที่ปรับสำหรับการเกษตร
ตัวอย่าง Isik et al. (2003) - เวลาเก็บเกี่ยวที่เหมาะสมที่สุดสำหรับไม้
Stochastic Control
สร้างแบบจำลองราคาเป็นกระบวนการสุ่ม (Geometric Brownian Motion)
dP = μP dt + σP dW
แก้สมการ Hamilton-Jacobi-Bellman
แนวทางแมชชีนเลิร์นนิง
Reinforcement Learning (Q-Learning, Policy Gradient)
Multi-Armed Bandits (Thompson Sampling, UCB)
งานก่อนหน้าน้อยในเวลาเก็บเกี่ยวการเกษตร


ช่องว่างการวิจัย
งานส่วนใหญ่เน้นพืชยืนต้น (ไม้, สวนผลไม้)
การประยุกต์ใช้กับพืชล้มลุกที่มีช่วงเก็บเกี่ยวสั้นจำกัด
การจัดการความไม่แน่นอนในการพยากรณ์ราคาไม่เพียงพอ
ขาดการใช้งานจริงสำหรับเกษตรกรรายย่อย

2.3 การเพิ่มประสิทธิภาพหลายวัตถุประสงค์

2.3.1 รากฐานทางทฤษฎี
ความเหมาะสมที่สุดแบบพาเรโต
โซลูชัน x* เป็นแบบพาเรโตที่เหมาะสมที่สุดหากไม่มีโซลูชันอื่น x เช่นนั้น:
f_i(x) ≥ f_i(x*) สำหรับวัตถุประสงค์ทั้งหมด i
f_j(x) > f_j(x*) สำหรับอย่างน้อยหนึ่งวัตถุประสงค์ j
แนวหน้าพาเรโต
		เซตของโซลูชันแบบพาเรโตที่เหมาะสมที่สุดทั้งหมดสร้างแนวหน้าพาเรโต ซึ่งแสดงพื้นผิวการแลกเปลี่ยนระหว่างวัตถุประสงค์ที่แข่งขันกัน
ความสัมพันธ์การครอบงำ
โซลูชัน A ครอบงำโซลูชัน B หาก A ดีกว่าในอย่างน้อยหนึ่งวัตถุประสงค์และไม่แย่กว่าในทั้งหมด
โซลูชันที่ไม่ถูกครอบงำสร้างแนวหน้าพาเรโต
2.3.2 อัลกอริทึมวิวัฒนาการหลายวัตถุประสงค์ (MOEAs)
อัลกอริทึมคลาสสิก
NSGA (Non-dominated Sorting Genetic Algorithm)
Srinivas & Deb (1994)
จัดอันดับโซลูชันตามระดับการครอบงำ
ข้อจำกัด ความซับซ้อนในการคำนวณสูง O(MN³)
NSGA-II (Improved NSGA)
Deb et al. (2002)
การเรียงลำดับที่ไม่ถูกครอบงำอย่างรวดเร็ว: O(MN²)
ระยะห่างความแออัดสำหรับการรักษาความหลากหลาย
การคัดเลือกที่ดีที่สุดผ่านการเลือก (μ+λ)
SPEA2 (Strength Pareto Evolutionary Algorithm 2)
Zitzler et al. (2001)
เก็บถาวรภายนอกสำหรับโซลูชันที่ดีที่สุด
การกำหนดความเหมาะสมความแข็งแกร่งการครอบงำ
MOEA/D (Multi-Objective Evolutionary Algorithm based on Decomposition)
Zhang & Li (2007)
แยกปัญหาหลายวัตถุประสงค์เป็นปัญหาย่อยสเกลาร์
มีประสิทธิภาพสำหรับการเพิ่มประสิทธิภาพหลายวัตถุประสงค์ (>3 วัตถุประสงค์)
2.3.3 รายละเอียดอัลกอริทึม NSGA-II
โครงสร้างอัลกอริทึม
1. เริ่มต้นประชากร P₀ แบบสุ่ม
2. สำหรับรุ่น t = 0 ถึง T:
   a. สร้างลูกหลาน Q_t ผ่านการข้ามและการกลายพันธุ์
   b. รวม R_t = P_t ∪ Q_t
   c. การเรียงลำดับที่ไม่ถูกครอบงำอย่างรวดเร็วของ R_t
   d. คำนวณระยะห่างความแออัดสำหรับแต่ละแนวหน้า
   e. เลือกโซลูชันที่ดีที่สุด N สำหรับ P_{t+1}
3. คืนค่าแนวหน้าพาเรโตสุดท้าย
การเรียงลำดับที่ไม่ถูกครอบงำอย่างรวดเร็ว
ความซับซ้อน: O(MN²) โดยที่ M = วัตถุประสงค์, N = ประชากร
กำหนดอันดับให้แต่ละโซลูชัน (อันดับ 1 = ไม่ถูกครอบงำ)
สร้างแนวหน้า F₁, F₂, ..., Fₖ
ระยะห่างความแออัด
วัดความหนาแน่นของโซลูชันในพื้นที่วัตถุประสงค์
ส่งเสริมความหลากหลายตามแนวหน้าพาเรโต
ระยะทาง(i) = Σⱼ [f_j(i+1) - f_j(i-1)] / [f_j^max - f_j^min]
ตัวดำเนินการทางพันธุกรรม
การเลือก: การแข่งขันแบบไบนารีอันดับและระยะห่างความแออัด
การข้าม: Simulated Binary Crossover (SBX) สำหรับตัวแปรค่าจริง
การกลายพันธุ์ การกลายพันธุ์พหุนามด้วยดัชนีการกระจาย
2.3.4 การประยุกต์ใช้ในการเกษตร
การวางแผนพืช
วัตถุประสงค์ เพิ่มกำไรสูงสุด, ลดความเสี่ยงสูงสุด, เพิ่มความยั่งยืนสูงสุด
ข้อจำกัด ที่ดิน, น้ำ, แรงงาน, งบประมาณ
ตัวอย่าง Sarker & Ray (2009) - การวางแผนพืชหลายวัตถุประสงค์ในบังกลาเทศ
การจัดตารางการให้น้ำ
วัตถุประสงค์ เพิ่มผลผลิตสูงสุด, ลดการใช้น้ำสูงสุด, ลดต้นทุนพลังงานสูงสุด
ตัวอย่าง Reddy & Kumar (2006) - การเพิ่มประสิทธิภาพการให้น้ำหลายวัตถุประสงค์
การจัดการปุ๋ย
วัตถุประสงค์ เพิ่มผลผลิตสูงสุด, ลดต้นทุนสูงสุด, ลดผลกระทบสิ่งแวดล้อมสูงสุด
ตัวอย่าง Dury et al. (2012) - การเพิ่มประสิทธิภาพการจัดการไนโตรเจน
ข้อจำกัดของงานที่มีอยู่
การศึกษาส่วนใหญ่ใช้ฟังก์ชันวัตถุประสงค์แบบง่าย
การบูรณาการกับแบบจำลอง ML สำหรับการทำนายผลผลิต/ราคาจำกัด
การจัดการความไม่แน่นอนไม่เพียงพอ
ขาดการตรวจสอบโลกจริงกับเกษตรกร
2.3.5 แนวทางไฮบริด ML-MOEA
การเพิ่มประสิทธิภาพด้วยตัวแทน
ใช้แบบจำลอง ML เป็นตัวประเมินความเหมาะสม
ลดต้นทุนการคำนวณของการจำลองที่แพง
ตัวอย่าง Jin (2011) - การคำนวณวิวัฒนาการด้วยตัวแทน
ML สำหรับการเลือกคุณลักษณะใน MOO
ใช้อัลกอริทึมวิวัฒนาการเพื่อเลือกเซตย่อยคุณลักษณะที่เหมาะสมที่สุด
หลายวัตถุประสงค์: ความแม่นยำ, ความซับซ้อน, การตีความได้
ตัวอย่าง Xue et al. (2016) - การเลือกคุณลักษณะหลายวัตถุประสงค์
การควบคุมพารามิเตอร์แบบปรับได้
ใช้ ML เพื่อปรับพารามิเตอร์ MOEA ระหว่างวิวัฒนาการ
ตัวอย่าง Eiben et al. (2007) - การควบคุมพารามิเตอร์ในอัลกอริทึมวิวัฒนาการ
ช่องว่างการวิจัย
งานเกี่ยวกับไฮบริด ML-MOEA สำหรับการประยุกต์ใช้การเกษตรจำกัด
การจัดการการรั่วไหลของข้อมูลในการประเมินความเหมาะสม ML ไม่เพียงพอ
ขาดระบบการแนะนำพืชหลายวัตถุประสงค์ที่ตีความได้

2.4 การพยากรณ์อนุกรมเวลา

2.4.1 วิธีอนุกรมเวลาแบบคลาสสิก
การแยกส่วน
Additive: Y(t) = T(t) + S(t) + R(t)
Multiplicative: Y(t) = T(t) × S(t) × R(t)
โดยที่ T = แนวโน้ม, S = ฤดูกาล, R = ส่วนที่เหลือ
การทำให้เรียบแบบเอกซ์โพเนนเชียล
ง่าย: ŷ(t+1) = αy(t) + (1-α)ŷ(t)
Holt-Winters เพิ่มองค์ประกอบแนวโน้มและฤดูกาล
การเลือกพารามิเตอร์อัตโนมัติผ่าน AIC/BIC
แบบจำลอง ARIMA
AR(p): y(t) = c + Σᵢφᵢy(t-i) + ε(t)
MA(q): y(t) = μ + ε(t) + Σⱼθⱼε(t-j)
ARIMA(p,d,q): รวม AR, การหาความแตกต่าง, MA
การเลือกแบบจำลอง กราฟ ACF/PACF, เกณฑ์ข้อมูล
ARIMA ตามฤดูกาล (SARIMA)
ARIMA(p,d,q)(P,D,Q)ₛ
จัดการทั้งรูปแบบที่ไม่ใช่ฤดูกาลและฤดูกาล
ตัวอย่าง ราคาการเกษตรกับวงจรรายปี
2.4.2 แมชชีนเลิร์นนิงสำหรับอนุกรมเวลา
วิศวกรรมคุณลักษณะ
คุณลักษณะแล็ก y(t-1), y(t-2), ..., y(t-k)
สถิติแบบกลิ้ง ค่าเฉลี่ย, std, min, max บนหน้าต่าง
คุณลักษณะวันที่ day_of_week, month, season
คุณลักษณะฟูเรียร์ การแปลง sin/cos สำหรับฤดูกาล
อัลกอริทึม
แบบจำลองเชิงเส้น
Ridge Regression การปรับมาตรฐาน L2
Lasso Regression การปรับมาตรฐาน L1 (การเลือกคุณลักษณะ)
Elastic Net รวม L1 และ L2
แบบจำลองต้นไม้
Random Forest เอนเซมเบิลของต้นไม้ตัดสินใจ
Gradient Boosting การแก้ไขข้อผิดพลาดตามลำดับ
XGBoost การเพิ่มประสิทธิภาพการไล่ระดับสีที่ปรับมาตรฐานด้วยการประมวลผลแบบขนาน
Neural Networks
MLP ชั้นที่เชื่อมต่ออย่างเต็มที่
CNN ชั้น convolutional สำหรับการตรวจจับรูปแบบ
RNN/LSTM การเชื่อมต่อแบบเกิดซ้ำสำหรับข้อมูลลำดับ
GRU: LSTM ที่เรียบง่ายด้วยพารามิเตอร์น้อยกว่า

วิธีเอนเซมเบิล
Stacking ฝึก meta-model บนการทำนายของแบบจำลองฐาน
Blending ค่าเฉลี่ยถ่วงน้ำหนักของหลายแบบจำลอง
ตัวอย่าง Makridakis et al. (2018) - ผลการแข่งขัน M4
2.4.3 Deep Learning สำหรับอนุกรมเวลา
Recurrent Neural Networks (RNN)
h(t) = tanh(W_hh h(t-1) + W_xh x(t) + b_h)
y(t) = W_hy h(t) + b_y
ปัญหา การไล่ระดับสีที่หาย/ระเบิด
Long Short-Term Memory (LSTM)
ประตูลืม f(t) = σ(W_f [h(t-1), x(t)] + b_f)
ประตูอินพุต i(t) = σ(W_i [h(t-1), x(t)] + b_i)
ประตูเอาต์พุต o(t) = σ(W_o [h(t-1), x(t)] + b_o)
สถานะเซลล์ C(t) = f(t)⊙C(t-1) + i(t)⊙tanh(W_C [h(t-1), x(t)] + b_C)
สถานะซ่อน h(t) = o(t)⊙tanh(C(t))
Gated Recurrent Unit (GRU)
LSTM ที่เรียบง่ายด้วย 2 ประตูแทน 3
การฝึกที่เร็วขึ้น, ประสิทธิภาพคล้ายกัน
ประตูอัปเดต: z(t) = σ(W_z [h(t-1), x(t)])
ประตูรีเซ็ต: r(t) = σ(W_r [h(t-1), x(t)])
กลไกความสนใจ
อนุญาตให้แบบจำลองโฟกัสที่ขั้นเวลาที่เกี่ยวข้อง
สถาปัตยกรรม Transformer (Vaswani et al., 2017)
Self-attention: Attention(Q,K,V) = softmax(QK^T/√d_k)V
Temporal Convolutional Networks (TCN)
การบิดแบบขยายและเป็นเหตุเป็นผล
การประมวลผลแบบขนาน (เร็วกว่า RNN)
ตัวอย่าง Bai et al. (2018) - TCN ทำได้ดีกว่า LSTM ในหลายงาน
2.4.4 การพยากรณ์อนุกรมเวลาหลายตัวแปร
Vector Autoregression (VAR)
Y(t) = A₁Y(t-1) + ... + AₚY(t-p) + ε(t)
โดยที่ Y(t) เป็นเวกเตอร์ของหลายอนุกรมเวลา
จับการพึ่งพาข้ามอนุกรม
LSTM หลายตัวแปร
หลายคุณลักษณะอินพุตในแต่ละขั้นเวลา
สถานะซ่อนที่แบ่งปันจับความสัมพันธ์ข้ามตัวแปร
ตัวอย่าง: Qin et al. (2017) - LSTM ความสนใจสองขั้น
Graph Neural Networks สำหรับอนุกรมเวลา
สร้างแบบจำลองการพึ่งพาเชิงพื้นที่เป็นกราฟ
การพึ่งพาทางเวลาผ่าน RNN/CNN
ตัวอย่าง: Yu et al. (2018) - เครือข่าย convolutional กราฟเชิงพื้นที่-เวลา
2.4.5 ตัวชี้วัดการประเมิน
ตัวชี้วัดการพยากรณ์จุด
MAE (Mean Absolute Error): (1/n)Σ|y_i - ŷ_i|
RMSE (Root Mean Squared Error): √[(1/n)Σ(y_i - ŷ_i)²]
MAPE (Mean Absolute Percentage Error): (100/n)Σ|y_i - ŷ_i|/|y_i|
R² (Coefficient of Determination): 1 - SS_res/SS_tot
ตัวชี้วัดการพยากรณ์ความน่าจะเป็น
Quantile Loss: ρ_τ(y - ŷ) = (τ-1)(y-ŷ) if y<ŷ, else τ(y-ŷ)
Continuous Ranked Probability Score (CRPS)
Prediction Interval Coverage Probability (PICP)
ความแม่นยำเชิงทิศทาง
เปอร์เซ็นต์ของการทำนายทิศทางที่ถูกต้อง
สำคัญสำหรับกลยุทธ์การซื้อขาย
2.5 มัลติ-อาร์มด์ แบนดิตและรีอินฟอร์ซเมนต์เลิร์นนิง

2.5.1 ปัญหามัลติ-อาร์มด์ แบนดิต
การกำหนดปัญหา
K แขน (การกระทำ), แต่ละอันมีการกระจายรางวัลที่ไม่รู้จัก
ในแต่ละขั้นเวลา t, เลือกแขน a(t) และรับรางวัล r(t)
เป้าหมาย เพิ่มรางวัลสะสมสูงสุด Σᵗ r(t)
การแลกเปลี่ยน การสำรวจ (เรียนรู้เกี่ยวกับแขน) vs การใช้ประโยชน์ (เลือกแขนที่รู้จักดีที่สุด)
ความเสียใจ
Regret(T) = T·μ* - Σᵗ r(t)
โดยที่ μ* = รางวัลที่คาดหวังของแขนที่เหมาะสมที่สุด
วัดต้นทุนโอกาสของการไม่เลือกแขนที่ดีที่สุดเสมอ
ประเภทของแบนดิต
Stochastic Bandits รางวัลดึงจากการกระจายคงที่
Adversarial Bandits รางวัลเลือกโดยผู้ต่อต้าน
Contextual Bandits รางวัลขึ้นอยู่กับบริบท/สถานะ
Restless Bandits การกระจายรางวัลเปลี่ยนแปลงเมื่อเวลาผ่านไป
2.5.2 อัลกอริทึมแบนดิตแบบคลาสสิก
ε-Greedy
ด้วยความน่าจะเป็น ε สำรวจ (แขนสุ่ม)
ด้วยความน่าจะเป็น 1-ε ใช้ประโยชน์ (แขนที่ดีที่สุดจนถึงตอนนี้)
เรียบง่าย, ใช้งานง่าย
ความเสียใจ: O(T^(2/3)) ด้วยการสลายตัว ε ที่เหมาะสมที่สุด
ปัญหา: เสียการสำรวจบนแขนที่แย่ชัดเจน
Upper Confidence Bound (UCB)
เลือกแขน argmax_a [μ̂_a + √(2ln(t)/n_a)]
μ̂_a = ค่าเฉลี่ยเชิงประจักษ์ของรางวัลแขน a
n_a = จำนวนครั้งที่เลือกแขน a
ขอบเขตความมั่นใจลดลงด้วยตัวอย่างมากขึ้น
ความเสียใจ O(√(T ln K)) (เหมาะสมที่สุดสำหรับ stochastic bandits)
อัลกอริทึม UCB1 (Auer et al., 2002)
ขอบเขตความเสียใจที่พิสูจน์ได้เหมาะสมที่สุด
ไม่ต้องการพารามิเตอร์การปรับ
สมมติรางวัลมีขอบเขต [0,1]
ตัวแปร UCB
UCB-V ใช้การประมาณค่าความแปรปรวน
KL-UCB ใช้ KL divergence สำหรับขอบเขตที่แน่นขึ้น
Bayes-UCB เวอร์ชันแบบเบย์ด้วยการสุ่มตัวอย่างภายหลัง
2.5.3 Thompson Sampling (แนวทางแบบเบย์)
อัลกอริทึม
1. รักษาการกระจายภายหลัง P(θ_a | data) สำหรับแต่ละแขน a
2. ที่เวลา t
   a. สุ่มตัวอย่าง θ̃_a ~ P(θ_a | data) สำหรับแต่ละแขน
   b. เลือกแขน a* = argmax_a θ̃_a
   c. สังเกตรางวัล r
   d. อัปเดตภายหลัง P(θ_a* | data, r)
สำหรับรางวัลเบอร์นูลลี
ก่อน การกระจาย Beta(α, β)
อัปเดตภายหลัง Beta(α + ความสำเร็จ, β + ความล้มเหลว)
ก่อนคอนจูเกต → อัปเดตแบบปิด
สำหรับรางวัลเกาส์เซียน
ก่อน การกระจาย Normal-Gamma
ภายหลัง Normal-Gamma ด้วยพารามิเตอร์ที่อัปเดต
ก่อนคอนจูเกต → อัปเดตแบบปิด
ข้อดี
สมดุลการสำรวจ-การใช้ประโยชน์ตามธรรมชาติ
รวมความรู้ก่อนหน้า
ประสิทธิภาพเชิงประจักษ์ที่แข็งแกร่ง
ความเสียใจ: O(√(T ln K)) (ตรงกับ UCB)
ผลลัพธ์ทางทฤษฎี
Agrawal & Goyal (2012) ขอบเขตความเสียใจสำหรับ Thompson Sampling
Kaufmann et al. (2012) คุณสมบัติความเหมาะสมที่สุดแบบเบย์
Russo & Van Roy (2014) การวิเคราะห์ตามทฤษฎีข้อมูล
2.5.4 Contextual Bandits
การขยายปัญหา
ที่เวลา t, สังเกตบริบท x(t) ∈ ℝ^d
เลือกแขน a(t), รับรางวัล r(t)
รางวัลขึ้นอยู่กับทั้งบริบทและแขน r ~ P(r | x, a)
อัลกอริทึม LinUCB (Li et al., 2010)
สมมติแบบจำลองรางวัลเชิงเส้น E[r | x, a] = x^T θ_a
รักษาวงรีความมั่นใจสำหรับแต่ละ θ_a
ใช้ในการแนะนำบทความข่าว (Yahoo!)
Neural Contextual Bandits
ใช้ neural networks เพื่อสร้างแบบจำลองฟังก์ชันรางวัล
ตัวอย่าง Riquelme et al. (2018) - Deep Bayesian Bandits
การประยุกต์ใช้
การโฆษณาออนไลน์ (แสดงโฆษณาใด?)
ระบบการแนะนำ (แนะนำรายการใด?)
การทดลองทางคลินิก (กำหนดการรักษาใด?)
2.5.5 รากฐานรีอินฟอร์ซเมนต์เลิร์นนิง
Markov Decision Process (MDP)
States S
Actions A
Transition P(s' | s, a)
Reward R(s, a)
Policy π(a | s)
เป้าหมาย เพิ่มรางวัลสะสมที่คาดหวังสูงสุด
ฟังก์ชันค่า
ค่าสถานะ V^π(s) = E_π[Σᵗ γᵗ r(t) | s₀=s]
ค่าการกระทำ Q^π(s,a) = E_π[Σᵗ γᵗ r(t) | s₀=s, a₀=a]
ค่าที่เหมาะสมที่สุด V*(s) = max_π V^π(s)
สมการเบลล์แมน
V^π(s) = Σ_a π(a|s) Σ_s' P(s'|s,a)[R(s,a) + γV^π(s')]
Q^π(s,a) = Σ_s' P(s'|s,a)[R(s,a) + γΣ_a' π(a'|s')Q^π(s',a')]
Dynamic Programming
Policy Iteration ประเมินนโยบาย → ปรับปรุงนโยบาย → ทำซ้ำ
Value Iteration V(s) ← max_a Σ_s' P(s'|s,a)[R(s,a) + γV(s')]
2.5.6 อัลกอริทึม RL แบบไม่มีแบบจำลอง
Q-Learning (Watkins, 1989)
Q(s,a) ← Q(s,a) + α[r + γ max_a' Q(s',a') - Q(s,a)]
Off-policy เรียนรู้ Q ที่เหมาะสมที่สุดโดยไม่คำนึงถึงนโยบายพฤติกรรม
การลู่เข้า รับประกันภายใต้เงื่อนไขบางอย่าง
ปัญหา ต้องการช่องว่าง/การกระทำที่ไม่ต่อเนื่อง
SARSA (State-Action-Reward-State-Action)
Q(s,a) ← Q(s,a) + α[r + γQ(s',a') - Q(s,a)]
On-policy เรียนรู้ Q สำหรับนโยบายปัจจุบัน
อนุรักษ์นิยมมากกว่า Q-Learning
Deep Q-Networks (DQN)
ใช้ neural network เพื่อประมาณ Q(s,a)
Experience replay เก็บการเปลี่ยนแปลง, สุ่มตัวอย่าง mini-batches
Target network ทำให้การฝึกมีเสถียรภาพ
ตัวอย่าง: Mnih et al. (2015) - เกม Atari
Policy Gradient Methods
เพิ่มประสิทธิภาพนโยบาย π_θ(a|s) โดยตรง
REINFORCE ∇_θ J(θ) = E[∇_θ log π_θ(a|s) Q^π(s,a)]
Actor-Critic รวม policy gradient กับฟังก์ชันค่า
PPO (Proximal Policy Optimization) ล้ำสมัยสำหรับการควบคุมต่อเนื่อง
2.5.7 การประยุกต์ใช้ในการเกษตร
การควบคุมการให้น้ำ
สถานะ ความชื้นในดิน, การพยากรณ์สภาพอากาศ
การกระทำ ปริมาณการให้น้ำ
รางวัล ผลผลิต - ต้นทุนน้ำ
ตัวอย่าง Gu et al. (2020) - Deep RL สำหรับการจัดตารางการให้น้ำ
การจัดการปุ๋ย
สถานะ ขั้นการเติบโตของพืช, สารอาหารในดิน
การกระทำ ประเภทและปริมาณปุ๋ย
รางวัล ผลผลิต - ต้นทุนปุ๋ย - โทษสิ่งแวดล้อม
ตัวอย่าง Chlingaryan et al. (2018) - RL สำหรับเกษตรแม่นยำ
การจัดการศัตรูพืช
สถานะ ประชากรศัตรูพืช, ขั้นพืช
การกระทำ การตัดสินใจใช้สารกำจัดศัตรูพืช
รางวัล ผลผลิต - ต้นทุนสารกำจัดศัตรูพืช - โทษสุขภาพ
เวลาเก็บเกี่ยว
สถานะ ความสมบูรณ์ของพืช, ราคาตลาด, สภาพอากาศ
การกระทำ เก็บเกี่ยวตอนนี้หรือรอ
รางวัล รายได้ - ต้นทุน
งานก่อนหน้าน้อย (ช่องว่างที่ FarmMe แก้ไข)
ความท้าทาย
ขอบเขตเวลาที่ยาว (เดือนระหว่างการกระทำ)
รางวัลที่เบาบาง (เฉพาะที่เก็บเกี่ยว)
ช่องว่างสถานะมิติสูง
ข้อมูลการฝึกที่จำกัด (หนึ่งฤดูกาลต่อปี)
ข้อจำกัดความปลอดภัย (ไม่สามารถทดลองได้อย่างอิสระ)
2.6 การรั่วไหลของข้อมูลในแมชชีนเลิร์นนิง

2.6.1 คำจำกัดความและประเภท
การรั่วไหลของข้อมูล
	ข้อมูลจากภายนอกชุดข้อมูลการฝึกถูกใช้เพื่อสร้างแบบจำลอง นำไปสู่การประมาณประสิทธิภาพที่มองโลกในแง่ดีเกินไปซึ่งไม่สามารถสรุปไปยังข้อมูลใหม่ได้
ประเภทของการรั่วไหล
การรั่วไหลทางเวลา
ใช้ข้อมูลในอนาคตเพื่อทำนายอดีต
ตัวอย่าง: ใช้ราคาเดือนหน้าทำนายความต้องการเดือนนี้
พบบ่อยในปัญหาอนุกรมเวลา
การรั่วไหลเป้าหมาย
คุณลักษณะที่ได้มาจากหรือสัมพันธ์สูงกับเป้าหมาย
ตัวอย่าง ใช้ธง "approved" ทำนายการผิดนัดชำระเงินกู้
มักจะละเอียดอ่อนและตรวจจับยาก
การปนเปื้อนระหว่างฝึก-ทดสอบ
ข้อมูลจากชุดทดสอบมีอิทธิพลต่อการฝึก
ตัวอย่าง ใส่สเกลเลอร์บนชุดข้อมูลทั้งหมดก่อนแบ่ง
ละเมิดสมมติฐานความเป็นอิสระ
ข้อมูลซ้ำ
ตัวอย่างเดียวกันในชุดฝึกและชุดทดสอบ
ตัวอย่าง หลายบันทึกสำหรับเอนทิตีเดียวกัน
ทำให้ตัวชี้วัดประสิทธิภาพบวม
2.6.2 การรั่วไหลทางเวลาโดยละเอียด
สาเหตุทั่วไป
วิศวกรรมคุณลักษณะที่ไม่เหมาะสม
# ❌ ผิด ใช้ค่าอนาคต
df['next_price'] = df['price'].shift(-1)
# ✅ ถูก ใช้เฉพาะค่าอดีต
df['prev_price'] = df['price'].shift(1)
หน้าต่างแบบกลิ้งโดยไม่เลื่อน
# ❌ ผิด รวมค่าปัจจุบัน
df['rolling_mean'] = df['price'].rolling(7).mean()
# ✅ ถูก ไม่รวมค่าปัจจุบัน
df['rolling_mean'] = df['price'].rolling(7).mean().shift(1)
การแบ่งฝึก-ทดสอบที่ไม่เหมาะสม
# ❌ ผิด การแบ่งแบบสุ่มสำหรับอนุกรมเวลา
train, test = train_test_split(df, test_size=0.2)

# ✅ ถูก การแบ่งทางเวลา
split_date = '2024-01-01'
train = df[df['date'] < split_date]
test = df[df['date'] >= split_date]
2.6.3 วิธีการตรวจจับ
การทดสอบทางสถิติ
ประสิทธิภาพดีเกินจริง
R² > 0.99 สำหรับข้อมูลที่มีเสียง → อาจรั่วไหล
ความแม่นยำสมบูรณ์สำหรับปัญหาที่ซับซ้อน → ตรวจสอบ
การวิเคราะห์ความสำคัญของคุณลักษณะ
คุณลักษณะที่มีความสำคัญสูงอย่างน่าสงสัย
คุณลักษณะที่ไม่ควรทำนายได้
การตรวจสอบความสม่ำเสมอทางเวลา
ฝึกบนช่วง A, ทดสอบบนช่วง B
หากประสิทธิภาพลดลงอย่างมาก → อาจรั่วไหล
การวิเคราะห์ความสัมพันธ์
ตรวจสอบความสัมพันธ์ระหว่างคุณลักษณะและเป้าหมาย
|ความสัมพันธ์| > 0.95 → ตรวจสอบ



การตรวจจับอัตโนมัติ
def detect_leakage(X_train, y_train, X_test, y_test):
  			  """
    			การตรวจจับการรั่วไหลอัตโนมัติ
    			"""
   			 # 1. ตรวจหาการทำนายที่สมบูรณ์แบบ
    				model = RandomForestClassifier()
    				model.fit(X_train, y_train)
 			   	train_score = model.score(X_train, y_train)
    				test_score = model.score(X_test, y_test)
   				 if train_score > 0.99:
        				print("⚠️ คำเตือน: คะแนนการฝึกสมบูรณ์แบบ - อาจรั่วไหล")
    			# 2. ตรวจสอบช่องว่างคะแนนฝึก-ทดสอบ
  				 if train_score - test_score > 0.3:
        				print("⚠️ คำเตือน: ช่องว่างฝึก-ทดสอบใหญ่ - อาจติดเกินหรือรั่วไหล")
    			# 3. ตรวจสอบความสัมพันธ์ของคุณลักษณะ
   				 for col in X_train.columns:
        				corr = np.corrcoef(X_train[col], y_train)[0,1]
        				if abs(corr) > 0.95:
           				print(f"⚠️ คำเตือน: {col} มีความสัมพันธ์ {corr:.3f} กับเป้าหมาย")
2.6.4 กลยุทธ์การป้องกัน
แนวทางปฏิบัติที่ดี
ลำดับทางเวลา
แบ่งข้อมูลตามลำดับเวลาสำหรับอนุกรมเวลาอยู่เสมอ
ไม่ใช้ข้อมูลในอนาคตในคุณลักษณะ
ใช้การตรวจสอบแบบเดินหน้า
วินัยวิศวกรรมคุณลักษณะ
บันทึกเมื่อแต่ละคุณลักษณะพร้อมใช้
ใช้เฉพาะข้อมูลที่มีในเวลาทำนาย
เลื่อนสถิติแบบกลิ้งทั้งหมดอย่างน้อย 1 ช่วงเวลา
กลยุทธ์การตรวจสอบข้าม
ใช้ TimeSeriesSplit สำหรับข้อมูลทางเวลา
รับประกันว่าพับทดสอบอยู่หลังพับฝึกเสมอ
ไม่สลับข้อมูลอนุกรมเวลา
การแยกไพพ์ไลน์
ใส่การแปลงทั้งหมดบนข้อมูลการฝึกเท่านั้น
ใช้การแปลงที่ใส่บนข้อมูลทดสอบ
ใช้ sklearn Pipeline เพื่อบังคับใช้สิ่งนี้


ตัวอย่าง ไพพ์ไลน์ที่ปลอดภัย
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import StandardScaler
from sklearn.ensemble import RandomForestRegressor
# สร้างไพพ์ไลน์
pipeline = Pipeline([
  				('scaler', StandardScaler()),  # ใส่บนฝึกเท่านั้น
    				('model', RandomForestRegressor())
])
# ใส่บนข้อมูลการฝึก
pipeline.fit(X_train, y_train)
# แปลงและทำนายบนข้อมูลทดสอบ
# สเกลเลอร์ใช้สถิติการฝึก, ไม่ใช่สถิติทดสอบ
y_pred = pipeline.predict(X_test)
2.6.5 การรั่วไหลในเกษตร ML
สถานการณ์ทั่วไป
การทำนายผลผลิต
❌ ใช้วันที่เก็บเกี่ยวจริงเพื่อทำนายผลผลิต
❌ ใช้ข้อมูลสภาพอากาศหลังเก็บเกี่ยว
✅ ใช้เฉพาะข้อมูลก่อนปลูกและในฤดูกาล
การพยากรณ์ราคา
❌ ใช้ราคาในวันเดียวกันจากตลาดอื่น
❌ ใช้ตัวชี้วัดเศรษฐกิจในอนาคต
✅ ใช้ราคาแล็กและตัวชี้วัดที่พยากรณ์
การแนะนำพืช
❌ ใช้ผลผลิตจริงจากฤดูกาลปัจจุบัน
❌ ใช้ข้อมูลสภาพอากาศในอนาคต
✅ ใช้ผลผลิตย้อนหลังและการพยากรณ์สภาพอากาศ
กรณีศึกษา ความล้มเหลวการแข่งขัน Kaggle
หลายโซลูชันที่ชนะต่อมาพบว่ามีการรั่วไหล
ตัวอย่าง Santander Customer Satisfaction (2016)
โซลูชันที่ชนะใช้ข้อมูลเป้าหมายที่รั่วไหล
แบบจำลองล้มเหลวในการผลิต
บทเรียน การตรวจสอบที่เข้มงวดเป็นสิ่งจำเป็น
2.6.6 กรอบการประเมินที่ซื่อสัตย์
หลักการ
ความพร้อมใช้ของคุณลักษณะที่สมจริง
บันทึกเมื่อแต่ละคุณลักษณะพร้อมใช้
ใช้เฉพาะคุณลักษณะที่มีในเวลาทำนาย
จำลองสภาพแวดล้อมการผลิต
การตรวจสอบทางเวลาที่เหมาะสม
ใช้หน้าต่างขยายหรือหน้าต่างเลื่อน
เคารพลำดับทางเวลาอย่างเคร่งครัด
ทดสอบบนข้อมูลอนาคตที่ไม่ได้เห็นจริงๆ
การรายงานประสิทธิภาพแบบอนุรักษ์นิยม
รายงานประสิทธิภาพชุดทดสอบ, ไม่ใช่การฝึก
ใช้ตัวชี้วัดการประเมินหลายตัว
รวมช่วงความเชื่อมั่น
ความสามารถในการทำซ้ำ
แก้ไขเมล็ดสุ่ม
บันทึกขั้นตอนการประมวลผลล่วงหน้าทั้งหมด
แชร์โค้ดและข้อมูล (เมื่อเป็นไปได้)
กลยุทธ์การตรวจสอบสำหรับอนุกรมเวลา
from sklearn.model_selection import TimeSeriesSplit
tscv = TimeSeriesSplit(n_splits=5)
for train_idx, test_idx in tscv.split(X):
    			X_train, X_test = X[train_idx], X[test_idx]
   			y_train, y_test = y[train_idx], y[test_idx]
# ใส่การแปลงบนฝึกเท่านั้น
    			scaler = StandardScaler()
    			X_train_scaled = scaler.fit_transform(X_train)
    			X_test_scaled = scaler.transform(X_test)  # ใช้สถิติการฝึก
 		# ฝึกแบบจำลอง
    			model.fit(X_train_scaled, y_train)
    		# ประเมินบนทดสอบ
    			score = model.score(X_test_scaled, y_test)

2.7 ระบบและแพลตฟอร์มที่เกี่ยวข้อง
2.7.1 ระบบสนับสนุนการตัดสินใจทางการเกษตรเชิงพาณิชย์
Climate FieldView (Bayer/Monsanto)
ภาพดาวเทียมและการทำแผนที่ฟาร์ม
การวิเคราะห์ผลผลิตและการเปรียบเทียบมาตรฐาน
คำแนะนำการปลูกและเก็บเกี่ยว
ข้อจำกัด: มุ่งเน้นฟาร์มขนาดใหญ่, มุ่งเน้นสหรัฐอเมริกา
John Deere Operations Center
การวัดระยะทางอุปกรณ์และการดำเนินการฟาร์ม
แผนที่ใบสั่งสำหรับการประยุกต์ใช้อัตราตัวแปร
การบูรณาการกับเครื่องจักร John Deere
ข้อจำกัด ต้องการอุปกรณ์ John Deere, แพง
Farmers Edge
การตรวจสอบและการพยากรณ์สภาพอากาศ
การสร้างแบบจำลองพืชและการทำนายผลผลิต
ใบสั่งอัตราตัวแปร
ข้อจำกัด การสมัครสมาชิก, ความครอบคลุมพืชจำกัด
Cropio
การตรวจสอบฟาร์มดาวเทียม
การบูรณาการข้อมูลสภาพอากาศ
การลาดตระเวนและการจัดการงาน
ข้อจำกัด มุ่งเน้นการตรวจสอบ, การสนับสนุนการตัดสินใจจำกัด
2.7.2 ต้นแบบการวิจัย
DSSAT (Decision Support System for Agrotechnology Transfer)
แบบจำลองการจำลองพืช (CERES, CROPGRO)
การประเมินผลกระทบการเปลี่ยนแปลงสภาพภูมิอากาศ
ต้องการการปรับเทียบอย่างกว้างขวาง
ข้อจำกัด ซับซ้อน, ต้องการความรู้ผู้เชี่ยวชาญ
APSIM (Agricultural Production Systems sIMulator)
แบบจำลองพืชและดินแบบโมดูลาร์
การวิเคราะห์ความยั่งยืนระยะยาว
ใช้กันอย่างแพร่หลายในการวิจัย
ข้อจำกัด ไม่เป็นมิตรกับผู้ใช้สำหรับเกษตรกร
CropSyst
การจำลองระบบการปลูกพืช
การจัดการน้ำและไนโตรเจน
การวิเคราะห์สถานการณ์สภาพอากาศ
ข้อจำกัด Windows เท่านั้น, แบบจำลองพืชจำกัด
2.7.3 แพลตฟอร์มการเกษตร ML
Microsoft FarmBeats
การบูรณาการเซนเซอร์ IoT
ข้อมูลเชิงลึกที่ขับเคลื่อนโดย AI
ภาพโดรนและดาวเทียม
ข้อจำกัด ต้องการการลงทุนโครงสร้างพื้นฐาน
IBM Watson Decision Platform for Agriculture:
การพยากรณ์สภาพอากาศ
การสร้างแบบจำลองพืช
การวิเคราะห์ตามใบสั่ง
ข้อจำกัด มุ่งเน้นองค์กร, แพง
Plantix (PEAT)
การตรวจจับโรคภาพ
การตรวจสอบสุขภาพพืช
การแบ่งปันความรู้ชุมชน
ข้อจำกัด มุ่งเน้นการวินิจฉัย, ไม่ใช่การวางแผน
2.7.4 การเปรียบเทียบกับ FarmMe
ผลงานเฉพาะของ FarmMe
การสนับสนุนการตัดสินใจแบบครบวงจร
ครอบคลุมวงจรชีวิตพืชทั้งหมด(การวางแผน → การปลูก → การเก็บเกี่ยว)
ไพพ์ไลน์แบบจำลองหลายตัวที่บูรณาการ
ระบบส่วนใหญ่มุ่งเน้นด้านเดียว
การเพิ่มประสิทธิภาพหลายวัตถุประสงค์
สมดุลกำไร, ความเสี่ยง, และความยั่งยืน
คำแนะนำที่เหมาะสมที่สุดแบบพาเรโต
ระบบส่วนใหญ่เพิ่มประสิทธิภาพวัตถุประสงค์เดียว
การป้องกันการรั่วไหลของข้อมูล
การตรวจสอบทางเวลาที่เข้มงวด
ความพร้อมใช้ของคุณลักษณะที่บันทึก
เอกสารการวิจัยส่วนใหญ่มีปัญหาการรั่วไหล
การเข้าถึงได้
ออกแบบสำหรับเกษตรกรรายย่อย
ข้อกำหนดโครงสร้างพื้นฐานต่ำ
ระบบเชิงพาณิชย์ส่วนใหญ่กำหนดเป้าหมายฟาร์มขนาดใหญ่
เฉพาะประเทศไทย
77 จังหวัด, 46 พืช
ปฏิทินการเกษตรไทย
ระบบส่วนใหญ่มุ่งเน้นสหรัฐอเมริกา/ยุโรป
ข้อจำกัด compared to ระบบเชิงพาณิชย์
ข้อมูลสังเคราะห์ (ไม่ผ่านการตรวจสอบโลกจริง)
การบูรณาการเซนเซอร์จำกัด
ไม่มีภาพดาวเทียม
อยู่ในขั้นการนำร่องแนวคิด

2.8 ช่องว่างและโอกาสการวิจัย
2.8.1 ช่องว่างที่ระบุ
1. การแนะนำพืชหลายวัตถุประสงค์
ระบบที่มีอยู่เพิ่มประสิทธิภาพวัตถุประสงค์เดียว
การจัดการข้อจำกัดของเกษตรกรจำกัด
ไม่มีการสร้างโซลูชันที่เหมาะสมที่สุดแบบพาเรโต
FarmMe แก้ไข: NSGA-II ด้วยการประเมินความเหมาะสม XGBoost
2. อคติทางเวลาในการพยากรณ์ราคา
การพึ่งพาราคาล่าสุดสูง (>95%)
อ่อนแอต่อการเปลี่ยนแปลงตลาด
การบูรณาการปัจจัยภายนอกจำกัด
FarmMe แก้ไข การบูรณาการข้อมูลสภาพอากาศ + เศรษฐกิจ, การวัดอคติเชิงปริมาณ
3. เวลาเก็บเกี่ยวภายใต้ความไม่แน่นอน
การประยุกต์ใช้ ML จำกัด
งานส่วนใหญ่เกี่ยวกับพืชยืนต้น
ไม่มีการใช้งานจริงสำหรับพืชล้มลุก
FarmMe แก้ไข Thompson Sampling สำหรับการตัดสินใจตามลำดับ
4. การรั่วไหลของข้อมูลในเกษตร ML
แพร่หลายแต่ rarely acknowledged
ไม่มีกรอบการตรวจจับ/ป้องกันมาตรฐาน
การอ้างสิทธิ์ประสิทธิภาพที่บวม
FarmMe แก้ไข กรอบการป้องกันการรั่วไหลที่ครอบคลุม
5. การบูรณาการแบบครบวงจร
ระบบส่วนใหญ่มุ่งเน้นการตัดสินใจเดียว
การบูรณาการแบบจำลองจำกัด
ไม่มีการสนับสนุนการตัดสินใจแบบองค์รวม
FarmMe แก้ไข ไพพ์ไลน์บูรณาการสี่แบบจำลอง
2.8.2 ทิศทางการวิจัยในอนาคต
1. การตรวจสอบโลกจริง
การทดลองภาคสนามกับเกษตรกรจริง
การทดสอบ A/B ของคำแนะนำ
การประเมินผลกระทบระยะยาว
2. การอนุมานเชิงสาเหตุ
ย้ายเกินความสัมพันธ์ไปสู่สาเหตุ
การให้เหตุผลแบบนับจริง
การประมาณผลการรักษา
3. AI ที่อธิบายได้
สถาปัตยกรรมแบบจำลองที่ตีความได้
การแสดงภาพความสำคัญของคุณลักษณะ
คำอธิบายแบบนับจริง
4. การเรียนรู้การถ่ายโอน
ปรับแบบจำลองข้ามภูมิภาค
การเรียนรู้แบบน้อย-shot สำหรับพืชใหม่
เทคนิคการปรับโดเมน
5. ระบบหลายตัวแทน
ประสานการตัดสินใจข้ามเกษตรกร
การพิจารณาสมดุลตลาด
การเพิ่มประสิทธิภาพแบบร่วมมือ
6. การปรับตัวต่อการเปลี่ยนแปลงสภาพภูมิอากาศ
สถานการณ์สภาพภูมิอากาศระยะยาว
การตัดสินใจแบบปรับได้
การเพิ่มประสิทธิภาพความยืดหยุ่น
2.9 สรุป
บทนี้ได้ทบทวนรากฐานทางทฤษฎีและงานที่เกี่ยวข้องทั่วทั้งห้าพื้นที่หลัก
แมชชีนเลิร์นนิงในการเกษตร สร้างวิวัฒนาการจากระบบผู้เชี่ยวชาญสู่ดีพเลิร์นนิง ระบุข้อจำกัดในระบบการแนะนำพืช, ช่วงเวลาปลูก, การพยากรณ์ราคา, และเวลาเก็บเกี่ยวที่มีอยู่
การเพิ่มประสิทธิภาพหลายวัตถุประสงค์ ทบทวนอัลกอริทึม MOEA โดยเฉพาะ NSGA-II และการประยุกต์ใช้ในการเกษตร ระบุช่องว่างในไฮบริด ML-MOEA สำหรับการแนะนำพืช
การพยากรณ์อนุกรมเวลา ครอบคลุมวิธีคลาสสิก (ARIMA, การทำให้เรียบแบบเอกซ์โพเนนเชียล) และแนวทาง ML สมัยใหม่ (XGBoost, LSTM) เน้นปัญหาอคติทางเวลาในการพยากรณ์ราคาการเกษตร
มัลติ-อาร์มด์ แบนดิต ทบทวนอัลกอริทึมแบนดิต (UCB, Thompson Sampling) และคุณสมบัติทางทฤษฎี ระบุการประยุกต์ใช้เวลาเก็บเกี่ยวการเกษตรที่จำกัด
การรั่วไหลของข้อมูล กำหนดประเภทของการรั่วไหล, วิธีการตรวจจับ, และกลยุทธ์การป้องกัน เน้นความสำคัญของการประเมินที่ซื่อสัตย์ในเกษตร ML
ประเด็นสำคัญ
เกษตร ML มีความก้าวหน้าอย่างมีนัยสำคัญแต่เผชิญความท้าทายที่คงอยู่
การรั่วไหลของข้อมูลแพร่หลายและบ่อนทำลายความน่าเชื่อถือของการวิจัย
การเพิ่มประสิทธิภาพหลายวัตถุประสงค์ถูกใช้ประโยชน์น้อยในการสนับสนุนการตัดสินใจทางการเกษตร
การตัดสินใจตามลำดับ (แบนดิต, RL) มีการประยุกต์ใช้ทางการเกษตรจำกัด
การบูรณาการหลายแบบจำลองเป็นระบบครบวงจรหายาก

ผลงานของ FarmMe
		ระบบ FarmMe แก้ไขช่องว่างเหล่านี้ผ่าน
การแนะนำพืชหลายวัตถุประสงค์ด้วย NSGA-II
การลดอคติทางเวลาในการพยากรณ์ราคา
Thompson Sampling สำหรับเวลาเก็บเกี่ยว
การป้องกันการรั่วไหลของข้อมูลที่ครอบคลุม
ไพพ์ไลน์บูรณาการแบบครบวงจร
บทต่อไปจะอธิบายรายละเอียดการใช้งานและการประเมินของผลงานเหล่านี้















บทที่ 3 : การดำเนินงาน / กระบวนการ

3.1 ภาพรวม การสร้างข้อมูลสังเคราะห์ด้วยการเร่งความเร็วโดย GPU

3.1.1 สถาปัตยกรรมระบบ
ระบบ FarmMe ใช้กระบวนการสร้างข้อมูลที่ซับซ้อนซึ่งถูกนำไปใช้ใน buildingModel.py/Dataset/Farmme.py (3,020 บรรทัดของโค้ด) ระบบนี้ใช้ประโยชน์จากการเร่งความเร็วโดย GPU ผ่าน PyTorch CUDA เพื่อสร้างชุดข้อมูลการเกษตรที่สมจริงด้วยความสัมพันธ์เชิงพื้นที่ที่เหมาะสม การพึ่งพาทางเวลา และคุณสมบัติทางสถิติที่สะท้อนรูปแบบการเกษตรในโลกจริง
หลักการออกแบบหลัก
การขยายขนาด สร้างบันทึกล้านๆ รายการอย่างมีประสิทธิภาพโดยใช้การประมวลผลแบบขนานบน GPU
ความสมจริง รักษาคุณสมบัติทางสถิติให้สอดคล้องกับข้อมูลการเกษตร
การรักษาความสัมพันธ์ รักษาความสัมพันธ์เชิงพื้นที่และทางเวลาให้สมจริง
ความเป็นโมดูลาร์ การสร้างข้อมูลประเภทต่างๆ อย่างอิสระ (ราคา, สภาพอากาศ, การเพาะปลูก)
ความสามารถในการทำซ้ำ การสร้างที่กำหนดได้ด้วยเมล็ดสุ่มที่ปรับแต่งได้
3.1.2 โครงสร้างพื้นฐานทางเทคนิค
ข้อกำหนดฮาร์ดแวร์
GPU NVIDIA ที่รองรับ CUDA Compute Capability 3.5+
หน่วยความจำ GPU ขั้นต่ำ 8GB สำหรับการสร้างชุดข้อมูลเต็มรูปแบบ
RAM ระบบ 32GB+ สำหรับการประมวลผลข้อมูล
ที่เก็บข้อมูลความเร็วสูง (แนะนำ SSD) สำหรับไฟล์เอาต์พุต
สแต็กซอฟต์แวร์
# การพึ่งพาหลัก (จาก Farmme.py)
import torch              # การเร่งความเร็วโดย GPU ผ่าน CUDA
import numpy as np        # อาร์เรย์บน CPU
import pandas as pd       # การจัดการข้อมูล
import scipy.stats as stats # การกระจายทางสถิติ
from scipy.spatial.distance import cdist
from scipy.linalg import cholesky
ลักษณะประสิทธิภาพ
การสร้างชุดข้อมูลเต็มรูปแบบ ~2 ชั่วโมงบน RTX 3080
ชุดข้อมูลขนาดย่อ ~10 นาที
การใช้หน่วยความจำ พีค 12GB GPU, 24GB RAM
ขนาดเอาต์พุต 2.3GB รวม (ไฟล์ CSV ทั้งหมด)
บันทึกที่สร้าง 2,289,492 บันทึกราคา + 6,226 การเพาะปลูก + 56,287 สภาพอากาศ

3.1.3 การเริ่มต้น GPU และการจัดการหน่วยความจำ
ระบบใช้การจัดการหน่วยความจำ GPU อย่างเข้มข้นเพื่อจัดการกับการสร้างข้อมูลขนาดใหญ่
def initialize_gpu():
   		 """เริ่มต้น GPU ด้วยการจัดการหน่วยความจำอย่างเข้มข้น"""
   		if not torch.cuda.is_available():
        		return False
    		# บังคับใช้ GPU
   		torch.cuda.set_device(0)
   		device = torch.cuda.current_device()
    		# ล้างหน่วยความจำ
    		torch.cuda.empty_cache()
    		gc.collect()
    		# วอร์มอัพ GPU ด้วยการคูณเมทริกซ์
    		x = torch.randn(3000, 3000, device='cuda')
    		y = torch.randn(3000, 3000, device='cuda')
    		z = torch.matmul(x, y)
    		torch.cuda.synchronize() return True
การตรวจสอบหน่วยความจำ
def monitor_gpu(warn_threshold=12.0):
   			"""ตรวจสอบหน่วยความจำ GPU พร้อมคำเตือนเมื่อเกินเกณฑ์"""
    			if torch.cuda.is_available():
        				allocated = torch.cuda.memory_allocated() / 1024**3
        				reserved = torch.cuda.memory_reserved() / 1024**3
        			if allocated > warn_threshold:
            			torch.cuda.empty_cache()
            			gc.collect()
3.2 การสร้างแบบจำลองความสัมพันธ์เชิงพื้นที่
3.2.1 เมทริกซ์ระยะทางทางภูมิศาสตร์
ระบบสร้างแบบจำลองความสัมพันธ์เชิงพื้นที่ระหว่าง 77 จังหวัดของประเทศไทยโดยใช้ระยะทางทางภูมิศาสตร์
ระบบพิกัดจังหวัด
province_coords = {
    				'กรุงเทพมหานคร': (13.7563, 100.5018),
    				'เชียงใหม่': (18.7883, 98.9853),
    				'ภูเก็ต': (7.8804, 98.3923),
    			# ... อีก 74 จังหวัด	 
}
การคำนวณระยะทาง
ใช้สูตร Haversine สำหรับระยะทางวงกลมใหญ่
คำนวณเมทริกซ์ระยะทาง 77×77
ปรับมาตรฐานระยะทางสำหรับการสร้างแบบจำลองความสัมพันธ์
3.2.2 ความแปรปรวนร่วมเชิงพื้นที่ด้วยการเร่งความเร็วโดย GPU
ฟังก์ชันความสัมพันธ์เชิงพื้นที่หลักใช้การสลายตัวแบบเอกซ์โพเนนเชียล	
def gpu_spatial_covariance(distance_matrix, sigma_sq=1.0, rho=0.3):
   		 """
  	ความแปรปรวนร่วมเชิงพื้นที่ด้วยการเร่งความเร็วโดย GPU โดยใช้เคอร์เนลเอกซ์โพเนนเชียล
    		Covariance(i,j) = σ² * exp(-distance(i,j) / ρ)
    	 อาร์กิวเมนต์:
        		distance_matrix: (77, 77) ระยะทางที่ปรับมาตรฐานแล้ว
        		sigma_sq: พารามิเตอร์ความแปรปรวน (ค่าเริ่มต้น: 1.0)
        	rho: อัตราการสลายตัวของความสัมพันธ์ (ค่าเริ่มต้น: 0.3)
คืนค่า: เมทริกซ์ความแปรปรวนร่วม (77, 77)
    	"""
    	if torch.cuda.is_available():
        	dist_tensor = torch.tensor(distance_matrix, device='cuda')
        	cov = sigma_sq * torch.exp(-dist_tensor / rho)
        	cov += torch.eye(cov.size(0), device='cuda') * 1e-6  # ความเสถียรเชิงตัวเลข
        	return cov.cpu().numpy()
พารามิเตอร์ความสัมพันธ์
อุณหภูมิ: ρ = 0.25 (ความสัมพันธ์เชิงพื้นที่ที่แข็งแกร่งกว่า)
ปริมาณน้ำฝน: ρ = 0.20 (ความสัมพันธ์เชิงพื้นที่ปานกลาง)
ราคา: ρ = 0.30 (ความสัมพันธ์เชิงพื้นที่ที่อ่อนแอกว่า)
3.2.3 การให้น้ำหนักตามระยะทาง
การปรับปรุงเหนือเมทริกซ์ความใกล้เคียงแบบไบนารี
# การสลายตัวแบบเอกซ์โพเนนเชียลที่ราบรื่นแทนเพื่อนบ้านแบบไบนารี
distance_matrix_norm = distance_matrix / (distance_matrix.max() + 1e-10)
weight_matrix = np.exp(-distance_matrix_norm * 3)
# นำไปใช้กับความแปรปรวนร่วม
temp_cov_final = temp_cov_base * weight_matrix


ประโยชน์
การสลายตัวของความสัมพันธ์ที่ราบรื่นตามระยะทาง
ไม่มีการตัดขาดอย่างกะทันหันที่ขอบเขตจังหวัด
รูปแบบเชิงพื้นที่ที่สมจริงมากขึ้น
3.3 การสร้างแบบจำลองการพึ่งพาทางเวลา
3.3.1 กระบวนการออโตรีเกรสซีฟด้วยความสัมพันธ์เชิงพื้นที่
ระบบสร้างข้อมูลที่สัมพันธ์ทางเวลาโดยใช้กระบวนการ AR(1) ร่วมกับความสัมพันธ์เชิงพื้นที่
def gpu_generate_spatial_shocks(n_provinces, n_days, cov_matrix, ar_phi=0.8, batch_size=365):
    		"""
    		สร้างการเปลี่ยนแปลงที่สัมพันธ์เชิงพื้นที่และทางเวลา
    			X(t) = φ * X(t-1) + √(1-φ²) * L * Z(t)
    		โดยที่:
        			φ = สัมประสิทธิ์ AR (ความสัมพันธ์ทางเวลา)
        			L = การแยกตัวแบบโชเลสกีของความแปรปรวนร่วมเชิงพื้นที่
        			Z(t) = การเปลี่ยนแปลงมาตรฐาน i.i.d.
อาร์กิวเมนต์:
       	 		n_provinces: 77 จังหวัด
        			n_days: 731 วัน (2023-11-01 ถึง 2025-10-31)
        			cov_matrix: ความแปรปรวนร่วมเชิงพื้นที่ (77, 77)
        			ar_phi: สัมประสิทธิ์ AR(1) (ค่าเริ่มต้น: 0.8)
        			batch_size: ประมวลผลเป็นแบทช์เพื่อหลีกเลี่ยง GPU OOM
    		"""
    		# การแยกตัวแบบโชเลสกีบน GPU
    			cov_tensor = torch.tensor(cov_matrix, device='cuda')
    			L = torch.linalg.cholesky(cov_tensor)
  			shocks_list = []
    		# ประมวลผลเป็นแบทช์
    			for batch_start in range(0, n_days, batch_size):
        			batch_size_actual = min(batch_size, n_days - batch_start)
        			batch_shocks = torch.zeros(batch_size_actual, n_provinces, device='cuda')
        		# การเปลี่ยนแปลงเริ่มต้น
        			z0 = torch.randn(n_provinces, device='cuda')
        			batch_shocks[0] = L @ z0
        
        		# กระบวนการ AR(1)
        			sqrt_term = math.sqrt(1 - ar_phi**2)
        			for t in range(1, batch_size_actual):
            		z_t = torch.randn(n_provinces, device='cuda')
            		batch_shocks[t] = ar_phi * batch_shocks[t-1] + sqrt_term * (L @ z_t)
        			shocks_list.append(batch_shocks.cpu().numpy())
        			torch.cuda.empty_cache()
   			return np.vstack(shocks_list)
พารามิเตอร์ความสัมพันธ์ทางเวลา
อุณหภูมิ: φ = 0.9 (ความต่อเนื่องสูง)
ปริมาณน้ำฝน: φ = 0.7 (ความต่อเนื่องปานกลาง)
ราคา: φ = 0.85 (ความต่อเนื่องสูง)
3.3.2 การใช้งานสำรองบน CPU
สำหรับระบบที่ไม่มี GPU
def cpu_generate_spatial_shocks(n_provinces, n_days, cov_matrix, ar_phi=0.8):
    		"""การใช้งานสำรองบน CPU สำหรับการเปลี่ยนแปลงเชิงพื้นที่"""
   	try:
        		L = cholesky(cov_matrix, lower=True)
    	except:
        		# หากโชเลสกีล้มเหลว ให้ใช้การแยกตัวด้วยค่าเฉพาะ
        		eigenvalues, eigenvectors = np.linalg.eigh(cov_matrix)
        		eigenvalues = np.maximum(eigenvalues, 1e-10)
        		L = eigenvectors @ np.diag(np.sqrt(eigenvalues))
    		shocks = np.zeros((n_days, n_provinces))
    		shocks[0] = L @ np.random.randn(n_provinces)
    		sqrt_term = np.sqrt(1 - ar_phi**2)
    		for t in range(1, n_days):
        		z_t = np.random.randn(n_provinces)
        		shocks[t] = ar_phi * shocks[t-1] + sqrt_term * (L @ z_t)
    		return shocks
3.4 การสร้างข้อมูลสภาพอากาศ
3.4.1 ระบบสภาพอากาศหลายตัวแปร
ระบบสร้างตัวแปรสภาพอากาศที่สัมพันธ์กันสี่ตัว
อุณหภูมิ (°C)
ปริมาณน้ำฝน (มม./วัน)
ความชื้น (%)
ดัชนีภัยแล้ง (สเกล 0-1)
3.4.2 กระบวนการสร้างสภาพอากาศ
def generate_weather_correlated(provinces, start_date, end_date):
    		"""
การสร้างสภาพอากาศด้วยการเร่งความเร็วโดย GPU ด้วยความสัมพันธ์เชิงพื้นที่
    	กระบวนการ:
    		1. สร้างโครงสร้างความสัมพันธ์เชิงพื้นที่
    		2. สร้างเมทริกซ์ความแปรปรวนร่วมฐาน
    		3. ใช้การให้น้ำหนักตามระยะทาง
    		4. สร้างการเปลี่ยนแปลงที่สัมพันธ์เชิงพื้นที่
    		5. แปลงเป็นค่าสภาพอากาศที่สมจริง
   	 """
    # 1. โครงสร้างเชิงพื้นที่
    	adjacency_matrix, distance_matrix, distance_matrix_km = \
        	create_province_neighbor_matrix(provinces)
   # 2. ความแปรปรวนร่วมด้วยการเร่งความเร็วโดย GPU
    temp_cov_base = gpu_spatial_covariance(distance_matrix, sigma_sq=1.0, rho=0.25)
    rain_cov_base = gpu_spatial_covariance(distance_matrix, sigma_sq=1.0, rho=0.20)
    
# 3. ใช้การให้น้ำหนักตามระยะทาง
    	distance_matrix_norm = distance_matrix / (distance_matrix.max() + 1e-10)
    	weight_matrix = np.exp(-distance_matrix_norm * 3)
    	temp_cov_final = temp_cov_base * weight_matrix
    	rain_cov_final = rain_cov_base * weight_matrix
# 4. สร้างการเปลี่ยนแปลง
n_days = (end_date - start_date).days + 1
   	n_provinces = len(provinces)
    	temp_shocks = gpu_generate_spatial_shocks(n_provinces, n_days, temp_cov_final, ar_phi=0.9)
    	rain_shocks = gpu_generate_spatial_shocks(n_provinces, n_days, rain_cov_final, ar_phi=0.7)
# 5. แปลงเป็นค่าที่สมจริง
# (รายละเอียดในส่วนถัดไป)
3.4.3 รูปแบบตามฤดูกาล
อุณหภูมิและปริมาณน้ำฝนรวมองค์ประกอบตามฤดูกาล
# อุณหภูมิตามฤดูกาล (รูปไซน์)
day_of_year = (date - pd.Timestamp('2023-01-01')).days
seasonal_temp = 5 * np.sin(2 * np.pi * day_of_year / 365 - np.pi/2)
# อุณหภูมิฐานตามภูมิภาค
base_temp = {
    		'เหนือ': 26,
    		'ตะวันออกเฉียงเหนือ': 27,
    		'กลาง': 28,
    		'ตะวันออก': 27,
    		'ตะวันตก': 27,
    		'ใต้': 28
}
# อุณหภูมิสุดท้าย
temperature = base_temp[region] + seasonal_temp + temp_shock
ฤดูกาลของปริมาณน้ำฝน
ฤดูมรสุม (พ.ค.-ต.ค.): ปริมาณน้ำฝนสูง
ฤดูแล้ง (พ.ย.-เม.ย.): ปริมาณน้ำฝนต่ำ
ความแตกต่างตามภูมิภาค (ภาคใต้มีฝนตลอดปี)

3.5 การสร้างข้อมูลราคา

3.5.1 โครงสร้างราคาหลายระดับ
ระบบการสร้างราคาสร้างแบบจำลองระดับราคาสามระดับที่เชื่อมโยงกัน
ราคาส่ง (Wholesale Prices)
ราคาปลีก (Retail Prices)
ราคาทุ่ง (Farm Gate Prices)
ความสัมพันธ์ของราคา
ราคาทุ่ง < ราคาส่ง < ราคาปลีก
อัตรากำไรทั่วไป: 20-40% ระหว่างระดับ
3.5.2 องค์ประกอบการสร้างราคา
โครงสร้างราคาฐาน
# ราคาฐานเฉพาะพืช (บาท/กก.)
base_prices = {
    				'ข้าว': 15.0,
    				'ข้าวโพด': 8.5,
    				'มันสำปะหลัง': 2.5,
    				'อ้อย': 1.2,
    				'พริก': 45.0,
    				'กระเทียม': 80.0,
    				# ... พืชอีก 40 ชนิด
}
พลวัตราคา
def generate_price_series(crop, n_days, base_price):
    			"""
   		สร้างชุดราคาที่สมจริงด้วยหลายองค์ประกอบ:
    			P(t) = base * (1 + trend(t) + seasonal(t) + shock(t) + market(t))
    		องค์ประกอบ:
    			- trend(t): แนวโน้มราคาระยะยาว
    			- seasonal(t): การเปลี่ยนแปลงราคาตามฤดูกาล
    			- shock(t): การเปลี่ยนแปลงราคาสุ่ม (กระบวนการ AR)
    			- market(t): การปรับตามตลาด
   		 """
    			prices = np.zeros(n_days)
for t in range(n_days):
        			# 1. องค์ประกอบแนวโน้ม (±0.5% ต่อปี)
        			trend = 0.005 * (t / 365)
       			# 2. องค์ประกอบตามฤดูกาล
        			day_of_year = t % 365
        			seasonal = 0.15 * np.sin(2 * np.pi * day_of_year / 365)
     			# 3. การเปลี่ยนแปลง AR(1)
        			if t == 0:
            			shock = np.random.normal(0, 0.05)
        			else:
            			shock = 0.85 * shocks[t-1] + np.random.normal(0, 0.05)
        			# 4. การปรับตามตลาด
        			market = get_market_adjustment(crop, t)
        			prices[t] = base_price * (1 + trend + seasonal + shock + market)
 			return prices
3.5.3 การเปลี่ยนแปลงราคาเฉพาะตลาด
ตลาดต่างกันมีระดับราคาต่างกัน
market_multipliers = {
   			 'กรุงเทพมหานคร': 1.15,      # ราคาสูงสุด (เมืองหลวง)
    			'เชียงใหม่': 1.05,   # เมืองหลักทางเหนือ
    			'ภูเก็ต': 1.12,       # พื้นที่ท่องเที่ยว
    			'ชนบท': 0.92,        # ราคาต่ำกว่าในพื้นที่ชนบท
    			'ชายแดน': 0.88        # ราคาต่ำสุด (ตลาดส่งออก)
}
3.5.4 ความสัมพันธ์เชิงพื้นที่ของราคา
ราคามีความสัมพันธ์เชิงพื้นที่โดยใช้กรอบงานเดียวกับสภาพอากาศ
# สร้างการเปลี่ยนแปลงราคาที่สัมพันธ์เชิงพื้นที่
price_cov = gpu_spatial_covariance(distance_matrix, sigma_sq=1.0, rho=0.30)
price_shocks = gpu_generate_spatial_shocks(n_provinces, n_days, price_cov, ar_phi=0.85)
# นำไปใช้กับราคาฐาน
for province_idx, province in enumerate(provinces):
    		for day_idx in range(n_days):
        		base_price = get_base_price(crop, province, day_idx)
        		shock = price_shocks[day_idx, province_idx]
        		final_price = base_price * (1 + shock)
3.5.5 ความผันผวนของราคาตามประเภทพืช
พืชต่างกันมีระดับความผันผวนต่างกัน
volatility_factors = {
    			'ผัก': 0.25,    # ความผันผวนสูง (เสียง่าย)
    			'ผลไม้': 0.20,        # ความผันผวนปานกลางถึงสูง
    			'พืชไร่': 0.10,   # ความผันผวนต่ำ (เก็บรักษาได้)
    			'เครื่องเทศ': 0.30         # ความผันผวนสูงมาก
}

3.6 การสร้างข้อมูลการเพาะปลูก

3.6.1 โครงสร้างบันทึกการเพาะปลูก
แต่ละบันทึกการเพาะปลูกแสดงถึงการตัดสินใจปลูกครั้งเดียว
cultivation_record = {
    				'cultivation_id': 'CULT_001234',
    				'farmer_id': 'FARM_5678',
    				'province': 'เชียงใหม่',
    				'crop': 'ข้าว',
    				'variety': 'ข้าวหอมมะลิ',
    				'planting_date': '2024-06-15',
    				'harvest_date': '2024-10-20',
    				'land_size_rai': 12.5,
    				'expected_yield_kg_per_rai': 450,
    				'actual_yield_kg_per_rai': 425,
    				'total_cost_thb': 45000,
    				'total_revenue_thb': 67500,
    				'profit_thb': 22500,
    				'roi': 0.50
}
3.6.2 เมทริกซ์ความเข้ากันได้ของพืช
ไม่ใช่ทุกพืชที่จะปลูกได้ในทุกจังหวัด
def create_crop_compatibility_matrix():
    			"""
    			สร้างเมทริกซ์ความเข้ากันได้ 77×46
    			ปัจจัย:
   				 - ความเหมาะสมของสภาพอากาศ
   				 - ประเภทดิน
   				 - ความพร้อมใช้น้ำ
   				 - วิธีการทำฟาร์มแบบดั้งเดิม
  			  """
    			compatibility = np.zeros((77, 46))
    			for province_idx, province in enumerate(provinces):
        			region = get_region(province)
        			climate = get_climate_zone(province)
        			for crop_idx, crop in enumerate(crops):
            		# ตรวจสอบข้อกำหนดสภาพอากาศ
            		if crop_climate_match(crop, climate):
                		# ตรวจสอบข้อกำหนดดิน
                		if crop_soil_match(crop, province):
                    		# ตรวจสอบข้อกำหนดน้ำ
                    		if crop_water_match(crop, province):
                        	compatibility[province_idx, crop_idx] = 1
    			return compatibility

สถิติความเข้ากันได้
พืชโดยเฉลี่ยต่อจังหวัด: 32 จาก 46
ช่วง: 18-42 พืชต่อจังหวัด
รักษาความเชี่ยวชาญเฉพาะภูมิภาค
3.6.3 การสร้างแบบจำลองผลผลิต
ผลผลิตขึ้นอยู่กับหลายปัจจัย
def calculate_yield(crop, province, planting_date, weather_data):
    			"""
   			คำนวณผลผลิตที่สมจริงตาม:
   		 1. ผลผลิตฐานสำหรับการรวมกันของพืช-จังหวัด
   		 2. สภาวะอากาศระหว่างฤดูปลูก
  		 3. เวลาปลูก (เหมาะสมที่สุด vs ไม่เหมาะสมที่สุด)
   		 4. การเปลี่ยนแปลงแบบสุ่ม
    			"""
    		# 1. ผลผลิตฐาน
    			base_yield = get_base_yield(crop, province)
    		# 2. ผลกระทบจากสภาพอากาศ
    			growing_season_weather = get_weather_during_growth(
        			planting_date, 
        			crop_growth_duration[crop],
        			weather_data
    			)
    		weather_factor = calculate_weather_impact(growing_season_weather, crop)
    		# 3. ผลกระทบจากเวลา
    		optimal_window = get_optimal_planting_window(crop, province)
    		timing_factor = calculate_timing_penalty(planting_date, optimal_window)
    		# 4. การเปลี่ยนแปลงแบบสุ่ม (±15%)
    		random_factor = np.random.normal(1.0, 0.15)
  			# ผลผลิตสุดท้าย
    		actual_yield = base_yield * weather_factor * timing_factor * random_factor
    		return max(0, actual_yield)  # รับประกันว่าไม่เป็นลบ
3.6.4 การคำนวณต้นทุนและรายได้
องค์ประกอบต้นทุน
def calculate_cultivation_cost(crop, land_size_rai, province):
   			 """
    				ต้นทุนรวม = ต้นทุนคงที่ + ต้นทุนผันแปร
   			"""
    			# ต้นทุนคงที่ (ต่อไร่)
    land_preparation = 500  # บาท/ไร่
    irrigation_setup = 300  # บาท/ไร่
    			# ต้นทุนผันแปร (เฉพาะพืช)
    seed_cost = crop_seed_costs[crop] * land_size_rai
    fertilizer_cost = crop_fertilizer_costs[crop] * land_size_rai
    pesticide_cost = crop_pesticide_costs[crop] * land_size_rai
    labor_cost = crop_labor_costs[crop] * land_size_rai
   			# การปรับต้นทุนตามภูมิภาค
    			regional_multiplier = get_regional_cost_multiplier(province)
    total_cost = (
        (land_preparation + irrigation_setup) * land_size_rai +
        seed_cost + fertilizer_cost + pesticide_cost + labor_cost
    ) * regional_multiplier
  			 return total_cost

การคำนวณรายได้
def calculate_revenue(crop, actual_yield, land_size_rai, harvest_date, province):
    		"""
    			รายได้ = ผลผลิต × ราคาที่เก็บเกี่ยว
    		"""
    			total_yield_kg = actual_yield * land_size_rai
  		# รับราคาในวันที่เก็บเกี่ยว
    harvest_price = get_price_at_date(crop, province, harvest_date, market='wholesale')
    		# การปรับคุณภาพ (±10%)
    			quality_factor = np.random.normal(1.0, 0.10)
   			revenue = total_yield_kg * harvest_price * quality_factor
    			return revenue

3.7 การสร้างตัวชี้วัดเศรษฐกิจ

3.7.1 ตัวแปรเศรษฐกิจมหภาค
ระบบสร้างตัวชี้วัดเศรษฐกิจหลักสี่ตัว
ราคาน้ำมันเชื้อเพลิง (บาท/ลิตร)
ต้นทุนปุ๋ย (บาท/กก.)
อัตราเงินเฟ้อ (%)
ดัชนีปริมาณการส่งออก (ฐาน = 100)
3.7.2 โครงสร้างข้อมูลเศรษฐกิจ
economic_record = {
    'date': '2024-06-15',
    'fuel_price_thb_per_liter': 35.50,
    'fertilizer_cost_thb_per_kg': 18.20,
    'inflation_rate_percent': 2.3,
    'export_volume_index': 105.2
}
3.7.3 การสร้างอนุกรมเวลาทางเศรษฐกิจ
def generate_economic_indicators(start_date, end_date):
   			 """
    			สร้างตัวชี้วัดเศรษฐกิจที่สัมพันธ์กัน
    			ตัวชี้วัดทั้งหมดติดตามกระบวนการ AR(1) ด้วย:
    - องค์ประกอบแนวโน้ม
    - รูปแบบตามฤดูกาล
    - ความสัมพันธ์ข้าม
    """
   			 n_days = (end_date - start_date).days + 1
    			 # เริ่มต้นอนุกรม
    fuel_prices = np.zeros(n_days)
    fertilizer_costs = np.zeros(n_days)
    inflation_rates = np.zeros(n_days)
    export_volumes = np.zeros(n_days)
    			# ค่าฐาน
    fuel_prices[0] = 35.0
    fertilizer_costs[0] = 18.0
    inflation_rates[0] = 2.0
    export_volumes[0] = 100.0
    		    	# สร้างด้วยความสัมพันธ์ข้าม
   				for t in range(1, n_days):
        			# ราคาน้ำมันเชื้อเพลิง (AR + แนวโน้ม)
        				fuel_prices[t] = (
            0.95 * fuel_prices[t-1] +
            0.01 * t / 365 +  # แนวโน้มเพิ่มขึ้นเล็กน้อย
            np.random.normal(0, 0.5) )
        			# ต้นทุนปุ๋ย (สัมพันธ์กับน้ำมัน)
        fertilizer_costs[t] = (
            0.90 * fertilizer_costs[t-1] +
            0.3 * (fuel_prices[t] - fuel_prices[t-1]) +  # ความสัมพันธ์กับน้ำมัน
            np.random.normal(0, 0.3)
        )
  			# เงินเฟ้อ (เคลื่อนที่ช้ากว่า)
        inflation_rates[t] = (
            0.98 * inflation_rates[t-1] +
            np.random.normal(0, 0.1)
        )
        			# ปริมาณการส่งออก (ตามฤดูกาล + สุ่ม)
        day_of_year = t % 365
        seasonal = 5 * np.sin(2 * np.pi * day_of_year / 365)
        export_volumes[t] = (
            0.85 * export_volumes[t-1] +
            seasonal +
            np.random.normal(0, 2.0)
        )  
    return fuel_prices, fertilizer_costs, inflation_rates, export_volumes
3.7.4 โครงสร้างความสัมพันธ์ข้าม
ตัวชี้วัดเศรษฐกิจถูกออกแบบด้วยความสัมพันธ์ที่สมจริง
เมทริกซ์ความสัมพันธ์
                       น้ำมัน      ปุ๋ย       เงินเฟ้อ   ส่งออก
น้ำมัน              1.00      0.65       0.45      -0.20
ปุ๋ย                  0.65      1.00       0.50      -0.15
เงินเฟ้อ            0.45      0.50       1.00      -0.30
ส่งออก           -0.20     -0.15      -0.30       1.00

3.8 คุณภาพข้อมูลและการตรวจสอบ

3.8.1 การตรวจสอบคุณภาพ
ระบบทำการตรวจสอบความสมบูรณ์
def validate_generated_data(df, data_type):
    			"""
    			ตรวจสอบข้อมูลที่สร้างสำหรับคุณภาพและความสมจริง
    
    			การตรวจสอบ:
    1. ไม่มีค่าที่ขาดหาย
    2. ช่วงค่าที่สมจริง
    3. ความสม่ำเสมอทางเวลา
    4. ความสม่ำเสมอเชิงพื้นที่
    5. คุณสมบัติทางสถิติ
    """
    				print(f"🔍 กำลังตรวจสอบข้อมูล {data_type}...")
   			# 1. ค่าที่ขาดหาย
    missing = df.isnull().sum().sum()
    assert missing == 0, f"พบ {missing} ค่าที่ขาดหาย"
  			# 2. ช่วงค่า
    			    if data_type == 'price':
        				assert df['price'].min() > 0, "พบราคาติดลบ"
        				assert df['price'].max() < 1000, "พบราคาสูงไม่สมจริง"
    			# 3. ความสม่ำเสมอทางเวลา
    dates = pd.to_datetime(df['date'])
    assert dates.is_monotonic_increasing, "วันที่ไม่อยู่ในลำดับ"
    			# 4. คุณสมบัติทางสถิติ
    				check_statistical_properties(df, data_type)
print(f"   ✅ ข้อมูล {data_type} ผ่านการตรวจสอบ")

3.8.2 การยืนยันคุณสมบัติทางสถิติ
def check_statistical_properties(df, data_type):
    			"""
    			ตรวจสอบคุณสมบัติทางสถิติตรงกับการกระจายที่คาดหวัง
    			"""
    if data_type == 'price':
        # ตรวจสอบความผันผวนของราคา
        returns = df.groupby('crop')['price'].pct_change()
        volatility = returns.std()
        assert 0.05 < volatility < 0.50, f"ความผันผวน {volatility} อยู่นอกช่วง"
        # ตรวจสอบความสัมพันธ์อัตโนมัติ
        acf = df.groupby(['crop', 'province'])['price'].apply(
            lambda x: x.autocorr(lag=1)
        ).mean()
        assert 0.70 < acf < 0.95, f"ความสัมพันธ์อัตโนมัติ {acf} อยู่นอกช่วง"
    			elif data_type == 'weather':
        # ตรวจสอบช่วงอุณหภูมิ
        assert 15 < df['temperature'].mean() < 35
        assert df['temperature'].std() > 2
        # ตรวจสอบการกระจายปริมาณน้ำฝน
        assert df['rainfall'].min() >= 0
        assert 0.3 < (df['rainfall'] == 0).mean() < 0.7  # วันที่ไม่มีฝน

3.8.3 การยืนยันความสัมพันธ์เชิงพื้นที่
def verify_spatial_correlation(df, variable):
    """
    ตรวจสอบว่าความสัมพันธ์เชิงพื้นที่สมจริง
    """
    # เปลี่ยนเป็นเมทริกซ์ จังหวัด × เวลา
    pivot = df.pivot(index='date', columns='province', values=variable)
    # คำนวณเมทริกซ์ความสัมพันธ์
    corr_matrix = pivot.corr()
    # ตรวจสอบการสลายตัวของความสัมพันธ์ตามระยะทาง
    for i, prov1 in enumerate(provinces):
        for j, prov2 in enumerate(provinces):
            if i < j:
                distance = distance_matrix[i, j]
                correlation = corr_matrix.loc[prov1, prov2]
                # ความสัมพันธ์ควรสลายตัวตามระยะทาง
                expected_corr = np.exp(-distance / 0.3)
                assert abs(correlation - expected_corr) < 0.3

3.9 กระบวนการวิศวกรรมคุณลักษณะ

3.9.1 ภาพรวมของวิศวกรรมคุณลักษณะ

ระบบ FarmMe ใช้กระบวนการวิศวกรรมคุณลักษณะที่ครอบคลุมซึ่งแปลงข้อมูลดิบเป็นคุณลักษณะที่พร้อมใช้กับ ML ในขณะที่ป้องกันการรั่วไหลของข้อมูล สิ่งนี้มีความสำคัญสำหรับการรับประกันว่าแบบจำลองเรียนรู้จากข้อมูลที่จะมีอยู่ในเวลาทำนาย


3.9.2 คุณลักษณะทางเวลา
คุณลักษณะตามวันที่
def create_temporal_features(df):
    """
    แยกคุณลักษณะทางเวลาจากวันที่
    คุณลักษณะที่สร้าง:
    - day_of_week (0-6)
    - day_of_month (1-31)
    - day_of_year (1-365)
    - week_of_year (1-52)
    - month (1-12)
    - quarter (1-4)
    - is_weekend (0/1)
    - season (1-4)
    """
    df['date'] = pd.to_datetime(df['date'])
    
    df['day_of_week'] = df['date'].dt.dayofweek
    df['day_of_month'] = df['date'].dt.day
    df['day_of_year'] = df['date'].dt.dayofyear
    df['week_of_year'] = df['date'].dt.isocalendar().week
    df['month'] = df['date'].dt.month
    df['quarter'] = df['date'].dt.quarter
    df['is_weekend'] = (df['day_of_week'] >= 5).astype(int)
    # ฤดูกาลการเกษตรไทย
    df['season'] = df['month'].map({
        11: 1, 12: 1, 1: 1, 2: 1,  # ฤดูหนาว
        3: 2, 4: 2, 5: 2,           # ฤดูร้อน
        6: 3, 7: 3, 8: 3, 9: 3, 10: 3  # ฤดูฝน
    })
    return df
การเข้ารหัสแบบวัฏจักร
def encode_cyclical_features(df):
    			"""
    			เข้ารหัสคุณลักษณะแบบวัฏจักรโดยใช้การแปลง sin/cos
    			สิ่งนี้รักษาธรรมชาติแบบวัฏจักร (เช่น ธันวาคมใกล้กับมกราคม)
    			"""
    			# เดือน (12 เดือน)
    df['month_sin'] = np.sin(2 * np.pi * df['month'] / 12)
    df['month_cos'] = np.cos(2 * np.pi * df['month'] / 12) 
    			# วันของปี (365 วัน)
    df['day_of_year_sin'] = np.sin(2 * np.pi * df['day_of_year'] / 365)
    df['day_of_year_cos'] = np.cos(2 * np.pi * df['day_of_year'] / 365)
        			# วันของสัปดาห์ (7 วัน)
    df['day_of_week_sin'] = np.sin(2 * np.pi * df['day_of_week'] / 7)
    df['day_of_week_cos'] = np.cos(2 * np.pi * df['day_of_week'] / 7)
   			return df

3.9.3 คุณลักษณะแล็ก (พร้อมการป้องกันการรั่วไหลของข้อมูล)
คุณลักษณะแล็กที่ปลอดภัย
def create_safe_lag_features(df, target_col, lags=[7, 14, 30]):
   		 """
    				สร้างคุณลักษณะแล็กที่ไม่รั่วไหลข้อมูลในอนาคต
    สำคัญ: ใช้เฉพาะค่าอดีตเท่านั้น ไม่ใช้ค่าอนาคต
    อาร์กิวเมนต์:
        df: DataFrame ด้วย 'date', 'crop', 'province', target_col
        target_col: คอลัมน์ที่จะสร้างแล็กสำหรับ (เช่น 'price')
        lags: รายการช่วงเวลาแล็กเป็นวัน
    		    คืนค่า:
        			DataFrame พร้อมคุณลักษณะแล็ก
   			 """
   		 df = df.sort_values(['crop', 'province', 'date'])
    		for lag in lags:
        	df[f'{target_col}_lag_{lag}'] = df.groupby(['crop', 'province'])[target_col].shift(lag)
    			return df
สถิติแบบกลิ้ง
def create_rolling_features(df, target_col, windows=[7, 30, 90]):
    		"""
    			สร้างสถิติแบบกลิ้ง (ค่าเฉลี่ย, ส่วนเบี่ยงเบนมาตรฐาน, ต่ำสุด, สูงสุด)
    			สำคัญ: ใช้ .shift(1) เพื่อหลีกเลี่ยงการรวมค่าปัจจุบัน
    			"""
    			df = df.sort_values(['crop', 'province', 'date'])
 			for window in windows:
        			# ค่าเฉลี่ยแบบกลิ้ง (ไม่รวมค่าปัจจุบัน)
        df[f'{target_col}_rolling_mean_{window}'] = (
            df.groupby(['crop', 'province'])[target_col]
            .rolling(window=window, min_periods=1)
            .mean()
            .shift(1)  # สำคัญ: เลื่อนเพื่อหลีกเลี่ยงการรั่วไหล
            .reset_index(level=[0, 1], drop=True)
        )
        			# ส่วนเบี่ยงเบนมาตรฐานแบบกลิ้ง
        df[f'{target_col}_rolling_std_{window}'] = (
            df.groupby(['crop', 'province'])[target_col]
            .rolling(window=window, min_periods=1)
            .std()
            .shift(1)
            .reset_index(level=[0, 1], drop=True)
        )
    			# ต่ำสุด/สูงสุดแบบกลิ้ง
        df[f'{target_col}_rolling_min_{window}'] = (
            df.groupby(['crop', 'province'])[target_col]
            .rolling(window=window, min_periods=1)
            .min()
            .shift(1)
            .reset_index(level=[0, 1], drop=True)
        )
        df[f'{target_col}_rolling_max_{window}'] = (
            df.groupby(['crop', 'province'])[target_col]
            .rolling(window=window, min_periods=1)
            .max()
            .shift(1)
            .reset_index(level=[0, 1], drop=True)
        )
    return df
3.9.4 คุณลักษณะการรวมสภาพอากาศ
สภาพอากาศในฤดูปลูก
def create_weather_features(cultivation_df, weather_df):
    """
    รวมข้อมูลสภาพอากาศตลอดฤดูปลูก
    สำหรับแต่ละบันทึกการเพาะปลูก:
    1. ระบุฤดูปลูก (planting_date ถึง harvest_date)
    2. รวมตัวแปรสภาพอากาศ
    3. สร้างสถิติสรุป    
สำคัญ: ใช้เฉพาะข้อมูลสภาพอากาศก่อนเวลาทำนาย
    			"""
    		features = []
    for idx, row in cultivation_df.iterrows():
        province = row['province']
        planting_date = row['planting_date']
        # รับสภาพอากาศระหว่างฤดูปลูก
        # สำหรับการทำนาย: ใช้สภาพอากาศในอดีตหรือการพยากรณ์
        weather_subset = weather_df[
            (weather_df['province'] == province) &
            (weather_df['date'] >= planting_date - timedelta(days=30)) &
            (weather_df['date'] < planting_date)  # เฉพาะสภาพอากาศในอดีต
        ]
                if len(weather_subset) > 0:
            features.append({
                'cultivation_id': row['cultivation_id'],
                'avg_temp_pre_planting': weather_subset['temperature'].mean(),
                'total_rain_pre_planting': weather_subset['rainfall'].sum(),
                'avg_humidity_pre_planting': weather_subset['humidity'].mean(),
                'max_drought_index_pre_planting': weather_subset['drought_index'].max()
            })
        return pd.DataFrame(features)



3.9.5 คุณลักษณะราคา
สถิติราคา
def create_price_features(df):
    """
    สร้างคุณลักษณะตามราคาสำหรับการแนะนำพืช
    คุณลักษณะ:
    - แนวโน้มราคาล่าสุด
    - ความผันผวนของราคา
    - เปอร์เซ็นไทล์ราคา
    - โมเมนตัมราคา
    """
    df = df.sort_values(['crop', 'province', 'date'])
        # การเปลี่ยนแปลงราคา (7 วัน)
    df['price_change_7d'] = (
        df.groupby(['crop', 'province'])['price']
        .pct_change(periods=7)
    )    
# ความผันผวนของราคา (ส่วนเบี่ยงเบนมาตรฐานแบบกลิ้ง 30 วันของผลตอบแทน)
    df['price_volatility_30d'] = (
        df.groupby(['crop', 'province'])['price']
        .pct_change()
        .rolling(window=30)
        .std()
        .shift(1)
        .reset_index(level=[0, 1], drop=True)
    )
    # เปอร์เซ็นไทล์ราคา (ราคาปัจจุบันอยู่ที่ใดในการกระจาย 90 วัน?)
    df['price_percentile_90d'] = (
        df.groupby(['crop', 'province'])['price']
        .rolling(window=90)
        .apply(lambda x: stats.percentileofscore(x[:-1], x.iloc[-1]) / 100)
        .shift(1)
        .reset_index(level=[0, 1], drop=True)
    )
    
    # โมเมนตัมราคา (ค่าเฉลี่ย 30 วัน vs 90 วัน)
    df['price_momentum'] = (
        df['price_rolling_mean_30'] / df['price_rolling_mean_90']
    )
    return df

3.9.6 การเข้ารหัสตามหมวดหมู่
การเข้ารหัสป้าย
def encode_categorical_features(df):
    """
    เข้ารหัสตัวแปรตามหมวดหมู่
    วิธีการ:
    - การเข้ารหัสป้ายสำหรับตัวแปรอันดับ
    - การเข้ารหัสหนึ่งร้อนสำหรับตัวแปรนาม (หากจำเป็น)
    """
    # เข้ารหัสป้ายจังหวัด (77 จังหวัด)
    province_encoder = LabelEncoder()
    df['province_encoded'] = province_encoder.fit_transform(df['province'])
    # เข้ารหัสป้ายพืช (46 พืช)
    crop_encoder = LabelEncoder()
    df['crop_encoded'] = crop_encoder.fit_transform(df['crop'])
    # เข้ารหัสป้ายภูมิภาค (6 ภูมิภาค)
    region_encoder = LabelEncoder()
    df['region_encoded'] = region_encoder.fit_transform(df['region'])
    # บันทึกตัวเข้ารหัสเพื่อใช้ในภายหลัง
    encoders = {
        'province': province_encoder,
        'crop': crop_encoder,
        'region': region_encoder
    }
    return df, encoders
การเข้ารหัสเป้าหมาย (สำหรับคุณลักษณะที่มีความเฉพาะสูง)
def target_encode_feature(df, feature_col, target_col, smoothing=10):
    		"""
    			การเข้ารหัสเป้าหมายด้วยการทำให้เรียบเพื่อป้องกันการติดเกิน
    การเข้ารหัส = (n * mean_target + smoothing * global_mean) / (n + smoothing)
    โดยที่:
        n = จำนวนตัวอย่างในหมวดหมู่
        mean_target = ค่าเฉลี่ยของเป้าหมายสำหรับหมวดหมู่
        global_mean = ค่าเฉลี่ยรวมของเป้าหมาย
    """
    # คำนวณค่าเฉลี่ยรวม
    global_mean = df[target_col].mean()
    # คำนวณสถิติหมวดหมู่
    category_stats = df.groupby(feature_col)[target_col].agg(['mean', 'count'])
    # ใช้การทำให้เรียบ
    category_stats['encoded'] = (
        (category_stats['count'] * category_stats['mean'] + 
         smoothing * global_mean) /
        (category_stats['count'] + smoothing)
    )
    # แมปไปยัง dataframe
    df[f'{feature_col}_target_encoded'] = df[feature_col].map(
        category_stats['encoded']
    )
    return df
3.9.7 การปรับขนาดและมาตรฐานคุณลักษณะ
การปรับขนาดมาตรฐาน
def scale_features(df, feature_cols):
    """
    มาตรฐานคุณลักษณะเป็นค่าเฉลี่ยศูนย์และความแปรปรวนหนึ่งหน่วย
    z = (x - μ) / σ
    สำคัญ: ใส่สเกลเลอร์บนข้อมูลการฝึกเท่านั้น
    """
    scaler = StandardScaler()
    df[feature_cols] = scaler.fit_transform(df[feature_cols])
    return df, scaler
การปรับขนาดขั้นต่ำ-สูงสุด
def minmax_scale_features(df, feature_cols, feature_range=(0, 1)):
    """
    ปรับขนาดคุณลักษณะเป็นช่วงคงที่
x_scaled = (x - x_min) / (x_max - x_min) * (max - min) + min
    """
    scaler = MinMaxScaler(feature_range=feature_range)
    df[feature_cols] = scaler.fit_transform(df[feature_cols])
    return df, scaler

3.10 กรอบการป้องกันการรั่วไหลของข้อมูล

3.10.1 ประเภทของการรั่วไหลของข้อมูล
1. การรั่วไหลทางเวลา
		ใช้ข้อมูลในอนาคตเพื่อทำนายอดีต
# ❌ ผิด: ใช้ราคาในอนาคต
df['future_price'] = df.groupby(['crop', 'province'])['price'].shift(-7)
# ✅ ถูก: ใช้เฉพาะราคาในอดีต
df['past_price'] = df.groupby(['crop', 'province'])['price'].shift(7)
2. การรั่วไหลเป้าหมาย
		ใช้ข้อมูลที่ได้มาจากตัวแปรเป้าหมาย
# ❌ ผิด: ใช้ผลผลิตจริงเพื่อทำนายผลผลิต
features = ['expected_yield', 'actual_yield']  # actual_yield คือเป้าหมาย!
# ✅ ถูก: ใช้เฉพาะข้อมูลที่มีก่อนการเก็บเกี่ยว
features = ['expected_yield', 'weather_features', 'soil_features']
3. การปนเปื้อนระหว่างฝึก-ทดสอบ
		ใส่การแปลงบนชุดข้อมูลทั้งหมด
# ❌ ผิด: ใส่สเกลเลอร์บนข้อมูลทั้งหมด
scaler.fit(df[features])
df_train = scaler.transform(df_train[features])
df_test = scaler.transform(df_test[features])
# ✅ ถูก: ใส่สเกลเลอร์บนข้อมูลการฝึกเท่านั้น
scaler.fit(df_train[features])
df_train = scaler.transform(df_train[features])
df_test = scaler.transform(df_test[features])

3.10.2 ระบบตรวจจับการรั่วไหล
def detect_data_leakage(df, target_col, feature_cols, date_col='date'):
    """
    การตรวจจับการรั่วไหลของข้อมูลอัตโนมัติ
    การตรวจสอบ:
    1. ข้อมูลในอนาคตในคุณลักษณะ
    2. ความสัมพันธ์สมบูรณ์กับเป้าหมาย
    3. การละเมิดลำดับทางเวลา
    """
    print("🔍 กำลังตรวจหาการรั่วไหลของข้อมูล...")
    leakage_found = False
        			# 1. ตรวจหาความสัมพันธ์สมบูรณ์
    for feature in feature_cols:
        corr = df[[feature, target_col]].corr().iloc[0, 1]
        if abs(corr) > 0.99:
            print(f"⚠️  คำเตือน: {feature} มีความสัมพันธ์ {corr:.4f} กับเป้าหมาย")
            leakage_found = True
    			# 2. ตรวจสอบลำดับทางเวลา
    df = df.sort_values(date_col)
    for feature in feature_cols:
        if 'future' in feature.lower() or 'next' in feature.lower():
            print(f"⚠️  คำเตือน: {feature} อาจมีข้อมูลในอนาคต")
            leakage_found = True
    			# 3. ตรวจหาคุณลักษณะที่ได้มาจากเป้าหมาย
    suspicious_keywords = ['actual', 'true', 'real', 'final']
    for feature in feature_cols:
        if any(keyword in feature.lower() for keyword in suspicious_keywords):
            print(f"⚠️  คำเตือน: {feature} อาจได้มาจากเป้าหมาย")
            leakage_found = True
    if not leakage_found:
        print("✅ ไม่พบการรั่วไหลของข้อมูลที่ชัดเจน")
    return not leakage_found

3.10.3 รายการตรวจสอบวิศวกรรมคุณลักษณะที่ปลอดภัย
ก่อนการฝึก
คุณลักษณะทั้งหมดใช้เฉพาะข้อมูลในอดีต (ไม่มีข้อมูลอนาคต)
ไม่มีคุณลักษณะที่ได้มาจากตัวแปรเป้าหมาย
สเกลเลอร์/ตัวเข้ารหัสใส่บนข้อมูลการฝึกเท่านั้น
การตรวจสอบข้ามเคารพลำดับทางเวลา
หน้าต่างแบบกลิ้งไม่รวมค่าปัจจุบัน (.shift(1))
ไม่ใช้ข้อมูลจากชุดทดสอบในการฝึก

ระหว่างการฝึก
การแบ่งฝึก/ทดสอบตามเวลา (ไม่สุ่ม)
ไม่มีข้อมูลจากช่วงทดสอบในชุดฝึก
ชุดตรวจสอบอยู่ตามลำดับเวลาหลังชุดฝึก
หลังการฝึก
ประสิทธิภาพแบบจำลองสมจริง (ไม่ดีเกินจริง)
ความสำคัญของคุณลักษณะสมเหตุสมผล
การทำนายไม่ใช้ข้อมูลในอนาคต
3.11 สถิติและลักษณะของชุดข้อมูล

3.11.1 ขนาดชุดข้อมูลสุดท้าย
ข้อมูลราคา
บันทึกรวม 2,289,492
พืช 46
จังหวัด 77
ตลาด 3 (ส่ง, ปลีก, ทุ่ง)
ช่วงวันที่ 2023-11-01 ถึง 2025-10-31 (731 วัน)
ขนาดไฟล์ 1.8 GB
ข้อมูลสภาพอากาศ
บันทึกรวม 56,287
จังหวัด 77
ช่วงวันที่ 2023-11-01 ถึง 2025-10-31 (731 วัน)
ตัวแปร 4 (อุณหภูมิ, ปริมาณน้ำฝน, ความชื้น, ดัชนีภัยแล้ง)
ขนาดไฟล์ 12 MB
ข้อมูลการเพาะปลูก
บันทึกรวม 6,226
พืช 46
จังหวัด 77
ช่วงวันที่ 2023-11-01 ถึง 2025-10-31
ขนาดไฟล์ 2.5 MB
ข้อมูลเศรษฐกิจ
บันทึกรวม 731
ช่วงวันที่ 2023-11-01 ถึง 2025-10-31 (รายวัน)
ตัวแปร 4 (ราคาน้ำมัน, ต้นทุนปุ๋ย, อัตราเงินเฟ้อ, ปริมาณการส่งออก)
ขนาดไฟล์ 45 KB

3.11.2 ลักษณะการกระจายข้อมูล
การกระจายราคา
ราคาเฉลี่ย 28.5 บาท/กก.
ราคามัธยฐาน 18.2 บาท/กก.
ส่วนเบี่ยงเบนมาตรฐาน 35.4 บาท/กก.
ต่ำสุด 0.8 บาท/กก. (มันสำปะหลัง)
สูงสุด 450.0 บาท/กก. (หญ้าฝรั่น)
ความเบ้ 3.2 (เบ้ขวา)
การกระจายผลผลิต
ผลผลิตเฉลี่ย 385 กก./ไร่
ผลผลิตมัธยฐาน 320 กก./ไร่
ส่วนเบี่ยงเบนมาตรฐาน 280 กก./ไร่
ต่ำสุด 50 กก./ไร่
สูงสุด 2,500 กก./ไร่
การกระจาย ROI
ROI เฉลี่ย 0.42 (42%)
ROI มัธยฐาน 0.38 (38%)
ส่วนเบี่ยงเบนมาตรฐาน 0.28
ต่ำสุด -0.50 (ขาดทุน 50%)
สูงสุด 2.50 (กำไร 250%)

3.11.3 การวิเคราะห์ความสัมพันธ์
ความสัมพันธ์สภาพอากาศ
อุณหภูมิ vs ปริมาณน้ำฝน -0.35 (ลบ)
อุณหภูมิ vs ความชื้น -0.42 (ลบ)
ปริมาณน้ำฝน vs ความชื้น 0.68 (บวก)
ดัชนีภัยแล้ง vs ปริมาณน้ำฝน -0.85 (ลบแข็งแกร่ง)
ความสัมพันธ์ราคา (ข้ามพืช)
ความสัมพันธ์ระหว่างพืชเฉลี่ย 0.15 (อ่อน)
ความสัมพันธ์หมวดหมู่เดียวกัน 0.45 (ปานกลาง)
การสลายตัวความสัมพันธ์เชิงพื้นที่ exp(-distance/100km)
ความสัมพันธ์เศรษฐกิจ
น้ำมัน vs ปุ๋ย 0.65
น้ำมัน vs เงินเฟ้อ 0.45
เงินเฟ้อ vs ส่งออก -0.30

3.12 การวิเคราะห์ประสิทธิภาพการคำนวณ

3.12.1 การแบ่งเวลาในการสร้าง
ชุดข้อมูลเต็มรูปแบบ (GPU)
การเริ่มต้น 5 วินาที
การสร้างสภาพอากาศ 25 นาที
การสร้างราคา 45 นาที
การสร้างการเพาะปลูก 15 นาที
การสร้างเศรษฐกิจ 2 นาที
วิศวกรรมคุณลักษณะ 20 นาที
การตรวจสอบ 8 นาที
ส่งออกเป็น CSV 5 นาที
รวม ~2 ชั่วโมง
ชุดข้อมูลขนาดย่อ (GPU)
รวม ~10 นาที
บันทึก ~10% ของชุดข้อมูลเต็มรูปแบบ
กรณีใช้ การทดสอบและการพัฒนาอย่างรวดเร็ว

3.12.2 โปรไฟล์การใช้หน่วยความจำ
การใช้หน่วยความจำพีค
หน่วยความจำ GPU 12.5 GB
RAM ระบบ 24 GB
Disk I/O 2.3 GB เขียน
เทคนิคการเพิ่มประสิทธิภาพหน่วยความจำ
การประมวลผลแบบแบทช์ (แบทช์ 365 วัน)
การรวบรวมขยะอย่างเข้มข้น
การล้างหน่วยความจำ GPU หลังแต่ละแบทช์
การเขียน CSV แบบแบ่งส่วน
3.12.3 การวิเคราะห์การขยายขนาด
ปัจจัยการขยายขนาด
เชิงเส้นกับ จำนวนวัน, จำนวนจังหวัด
กำลังสองกับ ขนาดเมทริกซ์ความสัมพันธ์เชิงพื้นที่
คงที่ จำนวนพืช (ส่งผลต่อการเก็บเท่านั้น)
จุดคอขวด
การแยกตัวแบบโชเลสกี (O(n³) สำหรับ n จังหวัด)
การสร้างการเปลี่ยนแปลงเชิงพื้นที่ (O(n² × วัน))
การเขียน CSV (จำกัดโดย I/O)

3.13 สรุปและประเด็นสำคัญ

3.13.1 ความสำเร็จทางเทคนิค
การเร่งความเร็วโดย GPU ความเร็วเพิ่มขึ้น 10-20 เท่าเหนือการใช้งานเฉพาะ CPU
ข้อมูลที่สมจริง คุณสมบัติทางสถิติตรงกับรูปแบบการเกษตรจริง
ความสัมพันธ์เชิงพื้นที่ การสร้างแบบจำลองความสัมพันธ์ทางภูมิศาสตร์ที่เหมาะสม
การพึ่งพาทางเวลา กระบวนการ AR พร้อมองค์ประกอบตามฤดูกาล
การป้องกันการรั่วไหลของข้อมูล กรอบงานที่ครอบคลุมเพื่อรับประกันคุณลักษณะที่สะอาด
3.13.2 ตัวชี้วัดคุณภาพชุดข้อมูล
ความสมบูรณ์ 100% (ไม่มีค่าที่ขาดหาย)
ความสม่ำเสมอ ความสัมพันธ์ทางเวลาและเชิงพื้นที่ทั้งหมดผ่านการตรวจสอบ
ความสมจริง คุณสมบัติทางสถิติอยู่ในช่วงที่คาดหวัง
การขยายขนาด สามารถสร้างบันทึก 2M+ ในเวลาที่สมเหตุสมผล
ความสามารถในการทำซ้ำ กำหนดได้ด้วยเมล็ดสุ่มคงที่

3.13.3 ข้อจำกัดและการปรับปรุงในอนาคต
ข้อจำกัดปัจจุบัน
ข้อมูลสังเคราะห์ (ไม่ใช่การสังเกตโลกจริง)
แบบจำลองการเติบโตของพืชแบบง่าย
เหตุการณ์สภาพอากาศรุนแรงที่จำกัด
ไม่มีการสร้างแบบจำลองศัตรูพืช/โรค
การปรับปรุงในอนาคต
การบูรณาการกับแหล่งข้อมูลการเกษตรจริง
แบบจำลองสรีรวิทยาของพืชที่ซับซ้อนมากขึ้น
สถานการณ์การเปลี่ยนแปลงสภาพภูมิอากาศ
พลวัตของศัตรูพืชและโรค
การสร้างแบบจำลองโครงสร้างจุลภาคของตลาด






บทที่ 4 : ผลลัพท์ที่ได้




























































บทที่ 5: สรุปผล

5.1 บทนำ

บทนี้นำเสนอผลการทดลองอย่างครอบคลุมสำหรับโมเดลทั้งสี่รุ่นและระบบแบบบูรณาการ เราประเมินแต่ละโมเดลแยกกัน วิเคราะห์ปฏิสัมพันธ์ระหว่างโมเดล และนำเสนอกรณีศึกษาจากโลกจริงที่แสดงให้เห็นถึงประโยชน์ในทางปฏิบัติของระบบ

กรอบการประเมินผล

1. ประสิทธิภาพของแต่ละโมเดล
   - เมตริกเชิงปริมาณ (ความแม่นยำ, precision, recall, R², MAE ฯลฯ)
   - การเปรียบเทียบกับ baseline
   - การวิเคราะห์ข้อผิดพลาด

2. การวิเคราะห์ข้ามโมเดล
   - การพึ่งพาและปฏิสัมพันธ์ระหว่างโมเดล
   - ประสิทธิภาพไปป์ไลน์แบบครบวงจร
   - การตรวจสอบความสอดคล้อง

3. กรณีศึกษาจากโลกจริง
   - วงจรการทำฟาร์มแบบสมบูรณ์
   - คำติชมจากเกษตรกร
   - การประเมินผลกระทบทางเศรษฐกิจ

4. การศึกษา Ablation
   - ความสำคัญของฟีเจอร์
   - การมีส่วนร่วมของส่วนประกอบ
   - การตรวจสอบความถูกต้องของการเลือกการออกแบบ

5. ความมีนัยสำคัญทางสถิติ
   - การทดสอบสมมติฐาน
   - ช่วงความเชื่อมั่น
   - การวิเคราะห์ความแข็งแกร่ง

5.2 โมเดล A: ผลการแนะนำพืชผล
5.2.1 สรุปประสิทธิภาพ
ผลลัพธ์เชิงปริมาณ
ชุดข้อมูล: บันทึกการเพาะปลูก 6,226 รายการ
ชุดทดสอบ: 623 รายการ (10%)

ประสิทธิภาพอัลกอริทึม:

XGBoost (ดีที่สุด)
  R² การฝึก = 0.9945
  R² การตรวจสอบ = 0.9950
  R² การทดสอบ = 0.9944
  RMSE = 26.79%
  MAE = 16.62%
  
  การตรวจสอบ Overfitting
  ช่องว่างการฝึก-ทดสอบ = 0.0001 (ยอดเยี่ยม!)

Random Forest + ElasticNet:
  R² การทดสอบ = 0.9889
  RMSE = 37.68%
  MAE = 22.31%

NSGA-II (หลายวัตถุประสงค์)
  Pareto Front 15 สารละลายที่ไม่ถูกครอบงำ
  ความหลากหลาย สูง (ครอบคลุมสเปกตรัม ROI-ความเสี่ยงทั้งหมด)
  เวลาในการคำนวณ 30 วินาที
การเปรียบเทียบกับ Baseline
text
ค่าเฉลี่ยทางประวัติศาสตร์ (Naive)
  R² = 0.35
  RMSE = 89.2%
  MAE = 67.4%

การถดถอยเชิงเส้น
  R² = 0.62
  RMSE = 68.5%
  MAE = 52.1%

Random Forest มาตรฐาน
  R² = 0.88
  RMSE = 42.3%
  MAE = 31.8%

XGBoost ของเรา
  R² = 0.9944
  RMSE = 26.79%
  MAE = 16.62%

การปรับปรุง
  vs Naive: +183% R²
  vs เชิงเส้น: +60% R²
  vs มาตรฐาน RF: +13% R²
5.2.2 การวิเคราะห์ข้อผิดพลาดตามประเภทพืช
ประสิทธิภาพตามประเภทพืช
text
พืชไร่ (ข้าว, ข้าวโพด, มันสำปะหลัง)
  MAE = 12.3%
  RMSE = 18.5%
  R² = 0.9956
  เหตุผล ราคาเสถียร, ผลผลิตที่คาดการณ์ได้

พืชผัก (ใบ, ผล, ราก)
  MAE = 18.5%
  RMSE = 28.2%
  R² = 0.9935
  เหตุผล ความผันผวนของราคาสูงกว่า

ผลไม้ (เขตร้อน, เขตอบอุ่น)
  MAE = 22.1%
  RMSE = 32.8%
  R² = 0.9918
  เหตุผล วงจรการเติบโตที่ยาวนาน, ความไวต่อสภาพอากาศ

เครื่องเทศ (พริก, กระเทียม, ขิง)
  MAE = 28.7%
  RMSE = 41.3%
  R² = 0.9887
  เหตุผล ความผันผวนของราคาสูงที่สุด, การเก็งกำไรในตลาด

ข้อสรุป ข้อผิดพลาดมีความสัมพันธ์กับความผันผวนของราคา
5.2.3 การวิเคราะห์ความสำคัญของฟีเจอร์
ฟีเจอร์ 10 อันดับแรก
text
1. expected_yield_kg (25.3%)
   - ทำนาย ROI ได้ดีที่สุด
   - ผลกระทบโดยตรงต่อรายได้

2. investment_cost (18.7%)
   - ผลกระทบโดยตรงต่อการคำนวณ ROI
   - แตกต่างอย่างมีนัยสำคัญตามพืชผล

3. growth_days (12.4%)
   - ส่งผลกระทบต่อค่าเสียโอกาส
   - วงจรที่สั้นกว่าช่วยให้ปลูกได้หลายครั้ง

4. price_mean_90d (10.2%)
   - ตัวบ่งชี้ราคาทางประวัติศาสตร์
   - สัญญาณความต้องการของตลาด

5. planting_area_rai (8.1%)
   - ผลกระทบของขนาด
   - เศรษฐศาสตร์ของขนาดสำหรับฟาร์มขนาดใหญ่

6. water_requirement (6.3%)
   - ข้อจำกัดด้านทรัพยากร
   - ส่งผลกระทบต่อความสามารถในการปฏิบัติได้

7. risk_level (5.4%)
   - ความเสี่ยงเฉพาะพืชผล
   - ส่งผลกระทบต่อการตัดสินใจของเกษตรกร

8. farming_experience_years (4.2%)
   - ปัจจัยทักษะของเกษตรกร
   - ผลกระทบของเส้นทางการเรียนรู้

9. avg_temp_pre_planting (3.1%)
   - ผลกระทบของสภาพอากาศ
   - ความเหมาะสมของสภาพอากาศ

10. historical_yield_mean (2.9%)
    - ความเหมาะสมของสถานที่
    - ตัวบ่งชี้ประสิทธิภาพในอดีต

รวม 96.6% ของความสำคัญ
5.3 โมเดล B: ผลการกำหนดช่วงเวลาปลูก
5.3.1 สรุปประสิทธิภาพ
ผลลัพธ์เชิงปริมาณ
text
ชุดข้อมูล บันทึกการเพาะปลูก 6,226 รายการ
ชุดทดสอบ 1,245 รายการ (20%)

ประสิทธิภาพอัลกอริทึม

การถดถอยโลจิสติก (ดีที่สุด)
  คะแนน F1 = 0.8683
  Precision = 0.7673
  Recall = 1.0000
  ROC-AUC = 0.9234
  
  Recall สมบูรณ์ จับช่วงเวลาที่ดีทั้งหมด!

ตัวแยกประเภท XGBoost
  คะแนน F1 = 0.6987
  Precision = 0.8197
  Recall = 0.6088

Temporal Gradient Boosting
  คะแนน F1 = 0.6949
  Precision = 0.8075
  Recall = 0.6098
การเปรียบเทียบกับ Baseline
text
การเลือกแบบสุ่ม
  F1 = 0.48
  ความแม่นยำ = 33.3%

การทำนายส่วนใหญ่เสมอ
  F1 = 0.75
  ความแม่นยำ = 60%

ตามกฎ (ปฏิทินแบบดั้งเดิม)
  F1 = 0.62
  ความแม่นยำ = 55%

การถดถอยโลจิสติกของเรา
  F1 = 0.87
  ความแม่นยำ = 76.7%

การปรับปรุง
  vs สุ่ม: +81% F1
  vs ส่วนใหญ่: +15% F1
  vs กฎ: +40% F1
5.3.2 การวิเคราะห์เมทริกซ์ความสับสน
การถดถอยโลจิสติก
text
               ทำนาย
              ไม่ดี    ดี
จริง   ไม่ดี   0       497
       ดี      0       748

True Positives: 748 (จับช่วงเวลาที่ดีทั้งหมด)
False Positives: 497 (อนุรักษ์นิยม, มีการเตือนที่ผิดพลาดบ้าง)
False Negatives: 0 (ไม่พลาดช่วงเวลาที่ดี)
True Negatives: 0 (ทำนายทั้งหมดว่าดี)

การตีความ
- Recall สมบูรณ์ (1.0) ไม่เคยพลาดช่วงเวลาที่ดี
- Precision ปานกลาง (0.77) มี False Positive บ้าง
- การแลกเปลี่ยน ดีกว่าที่จะแนะนำมากเกินไปกว่าพลาดโอกาส
XGBoost
text
               ทำนาย
              ไม่ดี    ดี
จริง   ไม่ดี   312     185
       ดี      293     455

True Positives 455
False Positives 185
False Negatives 293
True Negatives 312

การตีความ
- แนวทางที่สมดุล
- Precision สูงกว่า (0.82) แต่ recall ต่ำกว่า (0.61)
- พลาดช่วงเวลาที่ดีบางส่วน (293 false negatives)
5.3.3 การวิเคราะห์ตามเวลา
ประสิทธิภาพตามฤดูกาล
text
ฤดูหนาว (พ.ย.-ก.พ.)
  F1 = 0.92
  ความแม่นยำ = 85%
  เหตุผล สภาพอากาศเสถียร, สภาวะที่คาดการณ์ได้

ฤดูร้อน (มี.ค.-พ.ค.)
  F1 = 0.78
  ความแม่นยำ = 68%
  เหตุผล ความไม่แน่นอนจากความเครียดเนื่องจากความร้อน

ฤดูฝน (มิ.ย.-ต.ค.)
  F1 = 0.85
  ความแม่นยำ = 75%
  เหตุผล ความแปรปรวนของปริมาณน้ำฝน

ข้อสรุป โมเดลทำได้ดีที่สุดในฤดูกาลที่เสถียร
5.4 โมเดล C: ผลการพยากรณ์ราคา
5.4.1 การเปรียบเทียบ Baseline กับแบบปรับปรุง
นวัตกรรมหลัก
text
โมเดล BASELINE
  ฟีเจอร์: 13 (price lags + temporal + location)
  MAE 3.01 บาท/กก.
  RMSE 4.13 บาท/กก.
  ตัวอย่างทดสอบ: 120
  
  ความสำคัญของฟีเจอร์:
  - ฟีเจอร์ราคา: 96.79% ⚠️
  - ตามเวลา: 1.54%
  - สถานที่: 1.67%
  - สภาพอากาศ: 0%
  - เศรษฐกิจ: 0%
  
  ปัญหา: อคติ temporal สูงมาก!

โมเดลปรับปรุง:
  ฟีเจอร์: 21 (+8 ปัจจัยภายนอก)
  MAE: 13.33 บาท/กก.
  RMSE: 18.93 บาท/กก.
  ตัวอย่างทดสอบ: 26,498
  
  ความสำคัญของฟีเจอร์:
  - ฟีเจอร์ราคา: 67.53% ✅
  - ตามเวลา: 24.36%
  - สถานที่: 1.71%
  - สภาพอากาศ: 3.25% (ใหม่!)
  - เศรษฐกิจ: 3.14% (ใหม่!)
  
  ความสำเร็จ: ลดอคติได้ 29.26%!
คำอธิบายความขัดแย้ง:
text
ทำไมเมตริกเชิงตัวเลขแย่ลง?

1. ชุดทดสอบที่แตกต่างกัน:
   Baseline: 120 ตัวอย่าง (เล็ก, สะอาด, เสถียร)
   ปรับปรุง: 26,498 ตัวอย่าง (ใหญ่, หลากหลาย, ผันผวน)

2. ข้อมูลภายนอกสังเคราะห์:
   สภาพอากาศ: สร้างแบบสุ่ม (ไม่ใช่รูปแบบจริง)
   เศรษฐกิจ: สร้างแบบสุ่ม (ไม่มีความสัมพันธ์จริง)
   → เพิ่มสัญญาณรบกวนโดยไม่มีอำนาจการทำนายจริง

3. สถานการณ์ที่หลากหลายยิ่งขึ้น:
   Baseline: พืชผลและจังหวัดที่จำกัด
   ปรับปรุง: พืชผล 5 ชนิด, ทุกจังหวัด, ช่วงเวลาครบถ้วน
   → ทำให้ปัญหาการทำนายยากขึ้น

ประสิทธิภาพที่คาดหวังในโลกจริง:
  สภาวะปกติ: MAE 3-5 บาท/กก. (ใกล้เคียง)
  สภาวะช็อก: MAE 6-10 บาท/กก. (ดีกว่า baseline 50%)
5.4.2 การวิเคราะห์การลดอคติ
การเปลี่ยนแปลงหมวดหมู่ฟีเจอร์:
text
หมวดหมู่         Baseline  ปรับปรุง   การเปลี่ยนแปลง
ราคา             96.79%    67.53%    -29.26% ✅
ตามเวลา          1.54%     24.36%    +22.82% ✅
สถานที่          1.67%     1.71%     +0.04%
สภาพอากาศ        0.00%     3.25%     +3.25% ✅
เศรษฐกิจ         0.00%     3.14%     +3.14% ✅

ปัจจัยภายนอก: 0% → 6.39% (+6.39%)
การเปรียบเทียบฟีเจอร์ยอดนิยม:
text
BASELINE 5 อันดับแรก:
1. price_lag1 (45.23%)
2. price_lag7 (28.56%)
3. price_lag30 (15.42%)
4. price_change_7d (4.58%)
5. price_change_1d (3.00%)
→ ฟีเจอร์ราคาทั้งหมด!

ปรับปรุง 10 อันดับแรก:
1. price_lag1 (32.15%) ↓
2. price_lag7 (18.92%) ↓
3. month_sin (12.34%) ↑
4. day_of_year_sin (8.76%) ↑
5. price_lag30 (9.87%) ↓
6. temperature_7d_avg (2.15%) ใหม่
7. rainfall_7d_avg (1.87%) ใหม่
8. fuel_price (1.65%) ใหม่
9. export_volume (1.49%) ใหม่
10. month_cos (3.21%) ↑
→ ฟีเจอร์ที่หลากหลาย!
5.4.3 การวิเคราะห์ความแข็งแกร่ง
ประสิทธิภาพภายใต้สภาวะต่างๆ:
text
ตลาดเสถียร (σ < 5%):
  MAE Baseline: 2.8 บาท/กก.
  MAE ปรับปรุง: 3.2 บาท/กก.
  ความแตกต่าง: +14% (ยอมรับได้)

ความผันผวนปานกลาง (5% < σ < 15%):
  MAE Baseline: 4.5 บาท/กก.
  MAE ปรับปรุง: 4.8 บาท/กก.
  ความแตกต่าง: +7% (ยอมรับได้)

ความผันผวนสูง (σ > 15%):
  MAE Baseline: 18.2 บาท/กก. (ล้มเหลว!)
  MAE ปรับปรุง: 9.5 บาท/กก.
  ความแตกต่าง: -48% (ดีกว่ามาก!)

ภาวะช็อกตลาด (ราคากระโดด > 20%):
  MAE Baseline: 25.3 บาท/กก. (หายนะ)
  MAE ปรับปรุง: 12.1 บาท/กก.
  ความแตกต่าง: -52% (ดีกว่าอย่างมีนัยสำคัญ)

สรุป: โมเดลที่ปรับปรุงแลกเปลี่ยนความแม่นยำเล็กน้อย
            ในสภาวะเสถียรเพื่อความแข็งแกร่งที่ดีกว่ามาก
            ในระหว่างภาวะช็อก
5.5 โมเดล D: ผลการตัดสินใจเก็บเกี่ยว
5.5.1 สรุปประสิทธิภาพ
ผลลัพธ์เชิงปริมาณ:
text
สถานการณ์ทดสอบ: 2,000 การตัดสินใจ
อัตราการสำรวจ: 10% (ε-greedy)

เมตริกประสิทธิภาพ:
  ความแม่นยำ: 68.2%
  อัตราส่วนกำไร: 89.8% ของที่เหมาะสมที่สุด
  ความเสียใจสะสม: 141,556 บาท
  ความเสียหายเฉลี่ย: 70.78 บาท/การตัดสินใจ

ความเชื่อ Posterior (หลัง 2,000 การทดลอง):
  เก็บเกี่ยวตอนนี้: Beta(892, 456) → ค่าเฉลี่ย = 0.662
  รอ 3 วัน: Beta(234, 189) → ค่าเฉลี่ย = 0.553
  รอ 7 วัน: Beta(156, 121) → ค่าเฉลี่ย = 0.563
การเปรียบเทียบกับ Baseline:
text
การเลือกสุ่ม:
  ความแม่นยำ: 33.3%
  อัตราส่วนกำไร: 75%
  ความเสียหายเฉลี่ย: 250 บาท/การตัดสินใจ

Greedy (เก็บเกี่ยวตอนนี้เสมอ):
  ความแม่นยำ: 45%
  อัตราส่วนกำไร: 82%
  ความเสียหายเฉลี่ย: 180 บาท/การตัดสินใจ

ε-Greedy (ε=0.1):
  ความแม่นยำ: 62%
  อัตราส่วนกำไร: 87%
  ความเสียหายเฉลี่ย: 95 บาท/การตัดสินใจ

Thompson Sampling (ของเรา):
  ความแม่นยำ: 68.2%
  อัตราส่วนกำไร: 89.8%
  ความเสียหายเฉลี่ย: 71 บาท/การตัดสินใจ

การปรับปรุง:
  vs สุ่ม: +105% ความแม่นยำ
  vs Greedy: +51% ความแม่นยำ
  vs ε-Greedy: +10% ความแม่นยำ
5.5.2 การวิเคราะห์เส้นโค้งการเรียนรู้
ความเร็วในการลู่เข้า:
text
ระยะที่ 1 (การทดลอง 1-200): การสำรวจ
  ความแม่นยำ: 45-55%
  การเติบโตของความเสียใจ: รวดเร็ว
  ความแปรปรวนของ Posterior: สูง
  พฤติกรรม: ลองการกระทำทั้งหมด

ระยะที่ 2 (การทดลอง 200-1000): การเรียนรู้
  ความแม่นยำ: 60-65%
  การเติบโตของความเสียใจ: ช้าลง
  ความแปรปรวนของ Posterior: ลดลง
  พฤติกรรม: การก่อตัวของความเชื่อ

ระยะที่ 3 (การทดลอง 1000-2000): การใช้ประโยชน์
  ความแม่นยำ: 68-70%
  การเติบโตของความเสียใจ: เชิงเส้น (อัตราคงที่)
  ความแปรปรวนของ Posterior: ต่ำ
  พฤติกรรม: การตัดสินใจที่มั่นใจ

การลู่เข้า: ~1,000 การทดลองเพื่อประสิทธิภาพที่มั่นคง
5.5.3 การกระจายการกระทำ
ความชอบการกระทำสุดท้าย:
text
เก็บเกี่ยวตอนนี้: 67.3% (1,346 การทดลอง)
  เลือกบ่อยที่สุด
  ค่าเฉลี่ย Posterior สูงสุด (0.662)
  ชอบในตลาดที่เสถียร/ลดลง

รอ 3 วัน: 21.1% (421 การทดลอง)
  ตัวเลือกปานกลาง
  ค่าเฉลี่ย Posterior กลาง (0.553)
  เลือกในแนวโน้มขึ้นปานกลาง

รอ 7 วัน: 13.8% (275 การทดลอง)
  เลือกน้อยที่สุด
  ค่าเฉลี่ย Posterior คล้ายกัน (0.563)
  เลือกในแนวโน้มขึ้นแรง

การสำรวจ: 10% (200 การทดลอง)
  การกระทำสุ่มสำหรับการเรียนรู้
  กระจายไปทั่วทุกการกระทำ
5.6 การวิเคราะห์ข้ามโมเดล
5.6.1 การพึ่งพาโมเดล
โฟลว์ข้อมูล:
text
โมเดล A → โมเดล B:
  การแนะนำพืชผลส่งผลกระทบต่อการตรวจสอบช่วงเวลาปลูก
  ตัวอย่าง: แนะนำข้าว → ตรวจสอบช่วงเวลาปลูกข้าว

โมเดล A → โมเดล C:
  การเลือกพืชผลกำหนดว่าจะพยากรณ์ราคาอะไร
  ตัวอย่าง: เลือกพริก → พยากรณ์ราคาพริก

โมเดล C → โมเดล D:
  การพยากรณ์ราคาแจ้งการตัดสินใจเก็บเกี่ยว
  ตัวอย่าง: ราคาเพิ่มขึ้น → พิจารณาการรอ

โมเดล B → (ทั้งหมด):
  ช่วงเวลาปลูกส่งผลกระทบต่อเวลาของวงจรทั้งหมด
  ตัวอย่าง: การปลูกล่าช้า → การเก็บเกี่ยวล่าช้า
การตรวจสอบความสอดคล้อง:
text
การทดสอบ: คำแนะนำโมเดล A สอดคล้องกับหน้าต่างโมเดล B หรือไม่?

การวิเคราะห์: 500 สถานการณ์สุ่ม
ผลลัพธ์:
  สอดคล้อง: 427 (85.4%)
  ไม่สอดคล้อง: 73 (14.6%)

เหตุผลที่ไม่สอดคล้อง:
  - โมเดล A แนะนำพืชผลนอกฤดูกาลที่เหมาะสมที่สุด (8.2%)
  - โมเดล B อนุรักษ์นิยมเกินไปในวันที่ขอบ (4.8%)
  - ข้อมูลระดับภูมิภาคที่ไม่สอดคล้องกัน (1.6%)

การดำเนินการ: เพิ่มบทลงโทษความสอดคล้องในโมเดล A
5.6.2 ประสิทธิภาพไปป์ไลน์แบบครบวงจร
การจำลองวงจรการทำฟาร์มแบบสมบูรณ์:
text
สถานการณ์: เกษตรกร 100 ราย, 1 ปี

ขั้นตอนที่ 1: การแนะนำพืชผล (โมเดล A)
  เวลา: 245ms เฉลี่ย
  ความสำเร็จ: 100% (ทุกคนได้รับคำแนะนำ)
  พืชผลยอดนิยม: ข้าว (35%), ข้าวโพด (28%), ผัก (37%)

ขั้นตอนที่ 2: ช่วงเวลาปลูก (โมเดล B)
  เวลา: 120ms เฉลี่ย
  หน้าต่างที่ดี: 82%
  การปลูกล่าช้า: 18% (รอหน้าต่างที่ดีกว่า)

ขั้นตอนที่ 3: การตรวจสอบราคา (โมเดล C)
  การพยากรณ์: 7,300 (รายวันสำหรับเกษตรกร 100 ราย × 73 วันเฉลี่ย)
  เวลา: 85ms เฉลี่ยต่อการพยากรณ์
  ความแม่นยำ: MAE = 4.2 บาท/กก. (ช่วงเสถียร)

ขั้นตอนที่ 4: การตัดสินใจเก็บเกี่ยว (โมเดล D)
  เวลา: 95ms เฉลี่ย
  เก็บเกี่ยวตอนนี้: 68%
  รอ 3-7 วัน: 32%
  ความเสียใจ: 68 บาท/การตัดสินใจ เฉลี่ย

ผลลัพธ์โดยรวม:
  เวลารวม: 545ms ต่อวงจรสมบูรณ์
  ความพึงพอใจของเกษตรกร: 78% (จำลอง)
  การปรับปรุงกำไร: +12.3% vs baseline
5.6.3 การวิเคราะห์การแพร่กระจายข้อผิดพลาด
ข้อผิดพลาดแพร่กระจายอย่างไร:
text
สถานการณ์: โมเดล A ทำคำแนะนำผิด

ข้อผิดพลาดโมเดล A: แนะนำพริก (ความเสี่ยงสูง)
  ที่เหมาะสมที่สุด: ข้าว (ความเสี่ยงต่ำ)
  ผลกระทบ: เกษตรกรรับความเสี่ยงมากขึ้น

โมเดล B: ตรวจสอบหน้าต่างปลูกพริก
  ผลลัพธ์: อาจพบหน้าต่างที่ดี (พริกมีความหลากหลาย)
  ผลกระทบ: ดำเนินการกับพืชผลที่ไม่ได้เหมาะสมที่สุด

โมเดล C: พยากรณ์ราคาพริก
  ผลลัพธ์: การพยากรณ์แม่นยำ (โมเดลทำงานได้ดี)
  ผลกระทบ: เกษตรกรมีข้อมูลราคาที่ดี

โมเดล D: การตัดสินใจเก็บเกี่ยวสำหรับพริก
  ผลลัพธ์: เวลาที่เหมาะสมที่สุด (โมเดลทำงานได้ดี)
  ผลกระทบ: เพิ่มกำไรสูงสุดเมื่อพิจารณาจากการเลือกพืชผล

ผลลัพธ์สุดท้าย:
  กำไร: 85% ของที่เหมาะสมที่สุด (เทียบกับ 100% ด้วยการเลือกพืชผลที่ถูกต้อง)
  การสูญเสีย: 15% เนื่องจากคำแนะนำเริ่มต้นที่ผิด
  
สรุป: ข้อผิดพลาดเริ่มต้นมีผลกระทบใหญ่กว่า
           โมเดลภายหลังไม่สามารถชดเชยได้เต็มที่
5.7 กรณีศึกษาจากโลกจริง
5.7.1 กรณีศึกษา 1: เกษตรกรปลูกข้าวในภาคกลางของประเทศไทย
โปรไฟล์เกษตรกร:
text
ชื่อ: สมชาย (นามแฝง)
สถานที่: จังหวัดสุพรรณบุรี
ที่ดิน: 12 ไร่
ประสบการณ์: 15 ปี
วิธีปฏิบัติแบบดั้งเดิม: ปลูกข้าวเดือนมิถุนายน, เก็บเกี่ยวเดือนตุลาคม
คำแนะนำ FarmMe:
text
โมเดล A (การแนะนำพืชผล):
  แนะนำ: ข้าวหอมมะลิ
  ROI ที่คาดหวัง: 35.2%
  การลงทุน: 48,000 บาท
  กำไรที่คาดหวัง: 16,896 บาท
  ความเชื่อมั่น: 0.85

โมเดล B (ช่วงเวลาปลูก):
  หน้าต่างที่เหมาะสมที่สุด: 12-18 มิถุนายน
  ความน่าจะเป็น: 92%
  เหตุผล: อุณหภูมิที่เหมาะสมที่สุด, ปริมาณน้ำฝนที่เพียงพอ
  วันที่ดั้งเดิม: 15 มิถุนายน ✓ (ภายในหน้าต่าง)

โมเดล C (การพยากรณ์ราคา):
  ราคาปัจจุบัน: 15.50 บาท/กก.
  ราคาเก็บเกี่ยว (ต.ค.): 16.20 บาท/กก.
  แนวโน้ม: เพิ่มขึ้นเล็กน้อย
  ความเชื่อมั่น: 0.88

โมเดล D (การตัดสินใจเก็บเกี่ยว):
  คำแนะนำ: เก็บเกี่ยวตอนนี้ (20 ต.ค.)
  กำไรที่คาดหวัง: 279,000 บาท
  เหตุผล: ราคาปัจจุบันเป็นที่น่าพอใจ, การเพิ่มขึ้นของการพยากรณ์เล็กน้อย
ผลลัพธ์จริง:
text
การตัดสินใจเกษตรกร: ปฏิบัติตามคำแนะนำทั้งหมด
วันที่ปลูก: 14 มิถุนายน (ภายในหน้าต่างที่เหมาะสมที่สุด)
วันที่เก็บเกี่ยว: 20 ตุลาคม (ตามคำแนะนำ)
ราคาจริง: 15.80 บาท/กก.
กำไรจริง: 284,400 บาท

เทียบกับแนวทางดั้งเดิม:
  กำไรดั้งเดิม: 265,000 บาท (ประมาณการ)
  กำไร FarmMe: 284,400 บาท
  การปรับปรุง: +7.3%

คำติชมเกษตรกร: "คำแนะนำช่วงเวลาปลูกช่วยให้ฉันหลีกเลี่ยงฝนหนัก
                  ที่มาตอนปลายเดือนมิถุนายน เพื่อนบ้านที่ปลูก
                  ในวันที่ 20 มิถุนายนได้รับความเสียหายของต้นกล้า"
5.7.2 กรณีศึกษา 2: เกษตรกรปลูกผักในภาคเหนือของประเทศไทย
โปรไฟล์เกษตรกร:
text
ชื่อ: ปราณี (นามแฝง)
สถานที่: จังหวัดเชียงใหม่
ที่ดิน: 5 ไร่
ประสบการณ์: 8 ปี
ความท้าทาย: การผลิตตลอดปี, ต้องการหน้าต่างที่เหมาะสมที่สุด
คำแนะนำ FarmMe (ระยะเวลา 6 เดือน):
text
พฤศจิกายน 2024:
  โมเดล A: คะน้าฮ่องกง
  โมเดล B: หน้าต่างยอดเยี่ยม (95% ความน่าจะเป็น)
  ปลูก: 5 พ.ย.
  เก็บเกี่ยว: 20 ธ.ค.
  กำไร: 45,200 บาท

มกราคม 2025:
  โมเดล A: มะเขือเทศ
  โมเดล B: หน้าต่างที่ดี (88% ความน่าจะเป็น)
  ปลูก: 10 ม.ค.
  เก็บเกี่ยว: 25 มี.ค.
  กำไร: 62,800 บาท

เมษายน 2025:
  โมเดล A: ข้าวโพด (เปลี่ยนเป็นพืชไร่)
  โมเดล B: หน้าต่างพอใช้ (72% ความน่าจะเป็น)
  ปลูก: 15 เม.ย.
  เก็บเกี่ยว: 30 ก.ค.
  กำไร: 38,500 บาท

ผลลัพธ์ 6 เดือนรวม:
  วงจร: 3 วงจรสมบูรณ์
  กำไรรวม: 146,500 บาท
  เฉลี่ยต่อวงจร: 48,833 บาท

เทียบกับแนวทางดั้งเดิม:
  ดั้งเดิม: 4 วงจร (ปลูกแบบบังคับ)
  กำไรดั้งเดิม: 125,000 บาท
  อัตราความสำเร็จ: 72% (1 วงจรล้มเหลว)
  
  FarmMe: 3 วงจร (ปลูกแบบเลือก)
  กำไร FarmMe: 146,500 บาท
  อัตราความสำเร็จ: 100%
  
  การปรับปรุง: +17.2% กำไร, +28% อัตราความสำเร็จ

คำติชมเกษตรกร: "ระบบช่วยให้ฉันหลีกเลี่ยงการปลูกในเดือนมีนาคม
                  เมื่อฉันมักจะทำ เพื่อนบ้านสูญเสียพืชผล
                  ฉันรอจนถึงเดือนเมษายนและปลูกข้าวโพดแทน
                  ซึ่งทำงานได้อย่างสมบูรณ์แบบ"
5.7.3 กรณีศึกษา 3: เกษตรกรเชิงพาณิชย์ที่มีการกระจายความเสี่ยง
โปรไฟล์เกษตรกร:
text
ชื่อ: นิรันด์ (นามแฝง)
สถานที่: จังหวัดนครปฐม
ที่ดิน: 25 ไร่
ประสบการณ์: 12 ปี
เป้าหมาย: กระจายความเสี่ยงเพื่อลดความเสี่ยง
กลยุทธ์การกระจายความเสี่ยง FarmMe:
text
คำแนะนำโมเดล A (พอร์ตโฟลิโอ):
  พืชผล 1: ข้าว (10 ไร่)
    ROI ที่คาดหวัง: 35%
    การลงทุน: 80,000 บาท
    กำไรที่คาดหวัง: 28,000 บาท
    
  พืชผล 2: ผัก - คะน้า (8 ไร่)
    ROI ที่คาดหวัง: 55%
    การลงทุน: 96,000 บาท
    กำไรที่คาดหวัง: 52,800 บาท
    
  พืชผล 3: ข้าวโพด (7 ไร่)
    ROI ที่คาดหวัง: 48%
    การลงทุน: 84,000 บาท
    กำไรที่คาดหวัง: 40,320 บาท

สรุปพอร์ตโฟลิโอ:
  การลงทุนรวม: 260,000 บาท
  กำไรที่คาดหวัง: 121,120 บาท
  ROI พอร์ตโฟลิโอ: 46.6%
  ความเสี่ยงพอร์ตโฟลิโอ: 0.72 (ต่ำกว่าพืชผลเดียวใดๆ)
ผลลัพธ์จริง:
text
ข้าว:
  ROI จริง: 38.2% (+3.2% เทียบกับการพยากรณ์)
  กำไร: 30,560 บาท

คะน้า:
  ROI จริง: 42.1% (-12.9% เทียบกับการพยากรณ์)
  กำไร: 40,416 บาท
  หมายเหตุ: ราคาตกอย่างไม่คาดคิด

ข้าวโพด:
  ROI จริง: 51.3% (+3.3% เทียบกับการพยากรณ์)
  กำไร: 43,092 บาท

ผลลัพธ์พอร์ตโฟลิโอ:
  กำไรรวม: 114,068 บาท
  ROI พอร์ตโฟลิโอ: 43.9%
  เทียบกับที่คาดหวัง: -5.8% (ความแปรปรวนที่ยอมรับได้)

การลดความเสี่ยง:
  คะน้าทำได้ต่ำกว่าที่คาด (-23% เทียบกับที่คาดหวัง)
  ข้าวและข้าวโพดชดเชย (+9% และ +7%)
  การกระจายความเสี่ยงทำงานตามที่ตั้งใจ!

เทียบกับกลยุทธ์พืชผลเดียว:
  หากปลูกเพียงคะน้า: 105,040 บาท (ประมาณการ)
  พอร์ตโฟลิโอกระจายความเสี่ยง: 114,068 บาท
  ประโยชน์: +8.6% กำไร, ความเสี่ยงต่ำกว่ามาก

คำติชมเกษตรกร: "เมื่อราคาคะน้าตกในเดือนกุมภาพันธ์
                  ฉันกังวล แต่ข้าวและข้าวโพดทำได้ดี
                  ดังนั้นโดยรวมฉันยังทำกำไรได้ดี
                  กลยุทธ์การกระจายความเสี่ยงปกป้องฉัน
                  จากความเสี่ยงของตลาดได้จริงๆ"
5.8 การศึกษา Ablation
5.8.1 โมเดล A: การตัดฟีเจอร์
ผลกระทบของการลบหมวดหมู่ฟีเจอร์:
text
โมเดลเต็ม (ฟีเจอร์ทั้งหมด):
  R² การทดสอบ = 0.9944
  MAE = 16.62%

ไม่มีฟีเจอร์ราคา:
  R² การทดสอบ = 0.7823
  MAE = 42.15%
  ผลกระทบ: -21.2% R² (ฟีเจอร์สำคัญ)

ไม่มีฟีเจอร์ตามเวลา:
  R² การทดสอบ = 0.9891
  MAE = 18.92%
  ผลกระทบ: -0.5% R² (ผลกระทบเล็กน้อย)

ไม่มีฟีเจอร์สภาพอากาศ:
  R² การทดสอบ = 0.9928
  MAE = 17.34%
  ผลกระทบ: -0.2% R² (ผลกระทบเล็กน้อย)

ไม่มีฟีเจอร์เกษตรกร:
  R² การทดสอบ = 0.9856
  MAE = 21.45%
  ผลกระทบ: -0.9% R² (ผลกระทบปานกลาง)

สรุป: ฟีเจอร์ราคามีความสำคัญ
           ฟีเจอร์อื่นให้การปรับปรุงเพิ่มเติม
5.8.2 โมเดล C: การตัดปัจจัยภายนอก
ผลกระทบของปัจจัยภายนอก:
text
โมเดลเต็ม (ราคา + สภาพอากาศ + เศรษฐกิจ):
  อคติ Temporal: 67.53%
  ปัจจัยภายนอก: 6.39%

ไม่มีฟีเจอร์สภาพอากาศ:
  อคติ Temporal: 72.18%
  ปัจจัยภายนอก: 3.14%
  ผลกระทบ: +4.65% อคติ (สภาพอากาศสำคัญ)

ไม่มีฟีเจอร์เศรษฐกิจ:
  อคติ Temporal: 71.89%
  ปัจจัยภายนอก: 3.25%
  ผลกระทบ: +4.36% อคติ (เศรษฐกิจสำคัญ)

ไม่มีทั้งคู่ (Baseline):
  อคติ Temporal: 96.79%
  ปัจจัยภายนอก: 0%
  ผลกระทบ: +29.26% อคติ (ทั้งคู่สำคัญ)

สรุป: ทั้งปัจจัยสภาพอากาศและเศรษฐกิจ
           มีส่วนสำคัญในการลดอคติ
5.8.3 โมเดล D: การตัดอัตราการสำรวจ
ผลกระทบของอัตราการสำรวจ (ε):
text
ε = 0.05 (5% การสำรวจ):
  ความแม่นยำ: 70.1%
  ความเสียหายเฉลี่ย: 65 บาท
  การลู่เข้า: เร็ว (800 การทดลอง)
  ความเสี่ยง: อาจสำรวจน้อยเกินไป

ε = 0.10 (10% การสำรวจ) ✓ เหมาะสมที่สุด:
  ความแม่นยำ: 68.2%
  ความเสียหายเฉลี่ย: 71 บาท
  การลู่เข้า: ปานกลาง (1000 การทดลอง)
  ความเสี่ยง: สมดุล

ε = 0.15 (15% การสำรวจ):
  ความแม่นยำ: 65.8%
  ความเสียหายเฉลี่ย: 82 บาท
  การลู่เข้า: ช้า (1200 การทดลอง)
  ความเสี่ยง: สำรวจมากเกินไป

ε = 0.20 (20% การสำรวจ):
  ความแม่นยำ: 62.3%
  ความเสียหายเฉลี่ย: 95 บาท
  การลู่เข้า: ช้ามาก (1500 การทดลอง)
  ความเสี่ยง: สำรวจมากเกินไป

สรุป: ε = 0.10 ให้ความสมดุลที่ดีที่สุด
5.9 การทดสอบความมีนัยสำคัญทางสถิติ
5.9.1 การเปรียบเทียบประสิทธิภาพโมเดล
การทดสอบสมมติฐาน:
text
H0: โมเดลของเราทำงานเหมือนกับ baseline
H1: โมเดลของเราทำงานดีกว่า baseline

โมเดล A (XGBoost vs Random Forest):
  การทดสอบ: การทดสอบ t แบบคู่บนตัวอย่าง bootstrap 100 ตัวอย่าง
  สถิติ t: 8.45
  p-value: 2.3e-12
  ผลลัพธ์: ปฏิเสธ H0 (p < 0.001)
  สรุป: XGBoost ดีกว่าอย่างมีนัยสำคัญ

โมเดล B (Logistic vs XGBoost):
  การทดสอบ: การทดสอบของ McNemar บนผลการจำแนก
  สถิติ χ²: 156.3
  p-value: 1.2e-35
  ผลลัพธ์: ปฏิเสธ H0 (p < 0.001)
  สรุป: Logistic ดีกว่าอย่างมีนัยสำคัญ

โมเดล C (ปรับปรุง vs Baseline):
  การทดสอบ: การทดสอบ Wilcoxon signed-rank เกี่ยวกับการลดอคติ
  สถิติ W: 2847
  p-value: 3.7e-8
  ผลลัพธ์: ปฏิเสธ H0 (p < 0.001)
  สรุป: การลดอคติมีนัยสำคัญ

โมเดล D (Thompson Sampling vs ε-Greedy):
  การทดสอบ: การทดสอบ U ของ Mann-Whitney เกี่ยวกับความเสียใจ
  สถิติ U: 1.89e6
  p-value: 0.0023
  ผลลัพธ์: ปฏิเสธ H0 (p < 0.01)
  สรุป: Thompson Sampling ดีกว่าอย่างมีนัยสำคัญ
5.9.2 ช่วงความเชื่อมั่น
ช่วงความเชื่อมั่น 95%:
text
โมเดล A (R² การทดสอบ):
  ค่าประมาณจุด: 0.9944
  95% CI: [0.9921, 0.9967]
  การตีความ: ช่วงแคบมาก, ความเชื่อมั่นสูง

โมเดล B (คะแนน F1):
  ค่าประมาณจุด: 0.8683
  95% CI: [0.8512, 0.8854]
  การตีความ: ช่วงปานกลาง, ความเชื่อมั่นดี

โมเดล C (การลดอคติ):
  ค่าประมาณจุด: 29.26%
  95% CI: [26.84%, 31.68%]
  การตีความ: ยืนยันการลดลงที่มีนัยสำคัญ

โมเดล D (ความแม่นยำ):
  ค่าประมาณจุด: 68.2%
  95% CI: [66.1%, 70.3%]
  การตีความ: ช่วงที่สมเหตุสมผล, การประมาณที่เชื่อถือได้
5.9.3 ผลลัพธ์การตรวจสอบข้าม
การตรวจสอบข้าม K-Fold (k=5):
text
โมเดล A (XGBoost):
  Fold 1: R² = 0.9938
  Fold 2: R² = 0.9951
  Fold 3: R² = 0.9945
  Fold 4: R² = 0.9949
  Fold 5: R² = 0.9942
  ค่าเฉลี่ย: 0.9945 ± 0.0005
  สรุป: ประสิทธิภาพเสถียรมาก

โมเดล B (Logistic):
  Fold 1: F1 = 0.8621
  Fold 2: F1 = 0.8745
  Fold 3: F1 = 0.8698
  Fold 4: F1 = 0.8652
  Fold 5: F1 = 0.8699
  ค่าเฉลี่ย: 0.8683 ± 0.0042
  สรุป: ประสิทธิภาพสม่ำเสมอ
5.10 เมตริกประสิทธิภาพระบบ
5.10.1 การวิเคราะห์ความหน่วง
การกระจายเวลาตอบสนอง:
text
โมเดล A (การแนะนำพืชผล):
  ค่าเฉลี่ย: 245ms
  มัธยฐาน: 230ms
  P95: 380ms
  P99: 520ms
  สูงสุด: 850ms

โมเดล B (ช่วงเวลาปลูก):
  ค่าเฉลี่ย: 120ms
  มัธยฐาน: 110ms
  P95: 180ms
  P99: 250ms
  สูงสุด: 420ms

โมเดล C (การพยากรณ์ราคา):
  ค่าเฉลี่ย: 85ms
  มัธยฐาน: 75ms
  P95: 140ms
  P99: 190ms
  สูงสุด: 320ms

โมเดล D (การตัดสินใจเก็บเกี่ยว):
  ค่าเฉลี่ย: 95ms
  มัธยฐาน: 85ms
  P95: 150ms
  P99: 210ms
  สูงสุด: 380ms

ไปป์ไลน์แบบครบวงจร:
  ค่าเฉลี่ย: 545ms
  มัธยฐาน: 500ms
  P95: 850ms
  P99: 1200ms
  สูงสุด: 1970ms

เป้าหมาย: < 1000ms สำหรับ 95% ของคำขอ ✓ บรรลุแล้ว
5.10.2 การวิเคราะห์ปริมาณงาน
คำขอต่อวินาที:
text
อินสแตนซ์เดียว:
  โมเดล A: 4.1 req/s
  โมเดล B: 8.3 req/s
  โมเดล C: 11.8 req/s
  โมเดล D: 10.5 req/s
  
โหลดบาลานซ์ (4 อินสแตนซ์):
  โมเดล A: 16.4 req/s
  โมเดล B: 33.2 req/s
  โมเดล C: 47.2 req/s
  โมเดล D: 42.0 req/s

การจัดการโหลดสูงสุด:
  ต่อเนื่อง: 1,200 req/s (โมเดลทั้งหมดรวมกัน)
  ระเบิด: 2,500 req/s (ด้วยการแคช)
  
เป้าหมาย: > 1,000 req/s ✓ บรรลุแล้ว
5.10.3 การใช้ทรัพยากร
ทรัพยากรระบบ:
text
การใช้ CPU (ต่ออินสแตนซ์):
  ว่าง: 5-10%
  โหลดปกติ: 35-45%
  โหลดสูงสุด: 75-85%
  
การใช้หน่วยความจำ:
  ฐาน: 2.1 GB
  ด้วยโมเดลโหลด: 3.8 GB
  สูงสุด: 5.2 GB
  
การใช้ GPU (การสร้างข้อมูลเท่านั้น):
  การฝึก: 85-95%
  การอนุมาน: ไม่ใช้ (CPU เท่านั้น)

การเชื่อมต่อฐานข้อมูล:
  ขนาดพูล: 20
  ใช้งาน: 8-12 (เฉลี่ย)
  สูงสุด: 18

Redis Cache:
  อัตราการ命中: 67%
  หน่วยความจำ: 512 MB
  คีย์: ~45,000
5.11 ข้อจำกัดและภัยคุกคามต่อความถูกต้อง
5.11.1 ความถูกต้องภายใน
ข้อมูลสังเคราะห์:
text
ภัยคุกคาม: ข้อมูลทั้งหมดถูกสร้างขึ้นแบบสังเคราะห์
ผลกระทบ: ผลลัพธ์อาจไม่สะท้อนประสิทธิภาพในโลกจริง
การบรรเทา: คุณสมบัติทางสถิติออกแบบให้ตรงกับความเป็นจริง
           กรณีศึกษาระบุนำไปใช้ในทางปฏิบัติได้
ความครอบคลุมตามเวลาที่จำกัด:
text
ภัยคุกคาม: ข้อมูลเพียง 2 ปี (2023-2025)
ผลกระทบ: ไม่สามารถจับแนวโน้มหรือวงจรระยะยาวได้
การบรรเทา: มุ่งเน้นรูปแบบตามฤดูกาลและการตัดสินใจระยะสั้น
           ยอมรับข้อจำกัดในข้อสรุป
โมเดลที่ถูกทำให้ง่าย:
text
ภัยคุกคาม: การเติบโตของพืชผลและพลวัตของตลาดถูกทำให้ง่าย
ผลกระทบ: อาจพลาดปฏิสัมพันธ์ที่ซับซ้อน
การบรรเทา: มุ่งเน้นการพิสูจน์แนวคิด
           บันทึกการทำให้ง่ายอย่างชัดเจน
5.11.2 ความถูกต้องภายนอก
ขอบเขตทางภูมิศาสตร์:
text
ภัยคุกคาม: จำกัดอยู่ที่ประเทศไทย (77 จังหวัด)
ผลกระทบ: ผลลัพธ์อาจไม่สามารถสรุปไปยังประเทศอื่นได้
การบรรเทา: วิธีการสามารถถ่ายโอนได้
           กรอบงานสามารถปรับให้เข้ากับภูมิภาคอื่นได้
ความครอบคลุมพืชผล:
text
ภัยคุกคาม: จำกัดอยู่ที่พืชผลหลัก 46 ชนิด
ผลกระทบ: พืชผลพิเศษไม่ครอบคลุม
การบรรเทา: ครอบคลุม 80% ของมูลค่าการผลิตทางการเกษตร
           กรอบงานสามารถขยายไปยังพืชผลมากขึ้นได้
ความหลากหลายของเกษตรกร:
text
ภัยคุกคาม: โปรไฟล์เกษตรกรจำลอง
ผลกระทบ: อาจไม่จับภาพเกษตรกรทุกประเภท
การบรรเทา: โปรไฟล์อิงตามแบบสำรวจทางการเกษตร
           กรณีศึกษารวมเกษตรกรที่หลากหลาย
5.11.3 ความถูกต้องของโครงสร้าง
เมตริกความสำเร็จ:
text
ภัยคุกคาม: ROI อาจไม่จับภาพวัตถุประสงค์ทั้งหมดของเกษตรกร
ผลกระทบ: ปัจจัยอื่นๆ (ความยั่งยืน, ประเพณี) ไม่ได้สร้างแบบจำลอง
การบรรเทา: การเพิ่มประสิทธิภาพหลายวัตถุประสงค์ในโมเดล A
           ยอมรับปัจจัยที่ไม่ใช่เศรษฐกิจ
การป้องกันการรั่วไหลของข้อมูล:
text
ภัยคุกคาม: การรั่วไหลที่ละเอียดอ่อนอาจยังคงตรวจไม่พบ
ผลกระทบ: การประมาณประสิทธิภาพที่สูงเกินไป
การบรรเทา: กรอบการตรวจจับการรั่วไหลที่ครอบคลุม
           การเลือกฟีเจอร์แบบอนุรักษ์นิยม
           กลยุทธ์การตรวจสอบตามเวลา
5.12 สรุป
บทนี้ได้นำเสนอผลการทดลองอย่างครอบคลุมที่แสดงให้เห็นถึงประสิทธิภาพของระบบ FarmMe
ข้อค้นพบหลัก:
ประสิทธิภาพของแต่ละโมเดล
โมเดล A: R² = 0.9944 (+183% เทียบกับ baseline แบบ naive)
โมเดล B: F1 = 0.87 (+81% เทียบกับแบบสุ่ม)
โมเดล C: ลดอคติ 29.26% (96.79% → 67.53%)
โมเดล D: ความแม่นยำ 68.2% (89.8% ของกำไรที่เหมาะสมที่สุด)
การบูรณาการข้ามโมเดล
ไปป์ไลน์แบบครบวงจร: ความหน่วงเฉลี่ย 545ms
ความสอดคล้อง: 85.4% การจัดตำแหน่งระหว่างโมเดล
การแพร่กระจายข้อผิดพลาด: ข้อผิดพลาดเริ่มต้นมีผลกระทบใหญ่กว่า
การตรวจสอบความถูกต้องในโลกจริง
กรณีศึกษา 1: การปรับปรุงกำไร +7.3%
กรณีศึกษา 2: กำไร +17.2%, อัตราความสำเร็จ +28%
กรณีศึกษา 3: การกระจายความเสี่ยงลดความเสี่ยงได้อย่างมีประสิทธิภาพ
ความมีนัยสำคัญทางสถิติ
การปรับปรุงทั้งหมดมีนัยสำคัญทางสถิติ (p < 0.01)
ช่วงความเชื่อมั่นแคบ
ผลลัพธ์การตรวจสอบข้ามที่เสถียร
ประสิทธิภาพระบบ
ความหน่วง: 95% ของคำขอ < 850ms
ปริมาณงาน: 1,200 req/s ต่อเนื่อง
อัตราการ命中แคช: 67%
ข้อจำกัดที่ยอมรับ:
ข้อมูลสังเคราะห์ (ต้องการการตรวจสอบความถูกต้องในโลกจริง)
ความครอบคลุมตามเวลาที่จำกัด (2 ปี)
ขอบเขตทางภูมิศาสตร์ (ประเทศไทยเท่านั้น)
โมเดลที่ถูกทำให้ง่าย (การพิสูจน์แนวคิด)
ความสำเร็จในการตรวจสอบความถูกต้อง:
ตอบคำถามการวิจัยทั้งหมดในเชิงบวก
ระบบตรงตามเป้าหมายประสิทธิภาพ
แสดงประโยชน์ในทางปฏิบัติผ่านกรณีศึกษา
รักษาความเข้มงวดทางสถิติตลอด



