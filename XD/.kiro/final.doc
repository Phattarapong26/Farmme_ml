บทที่ 1 : บทนำ

1.1 ความเป็นมาและความสำคัญของปัญหา

ภาคการเกษตรเป็นรากฐานสำคัญของเศรษฐกิจไทยมาอย่างยาวนาน โดยมีบทบาทสำคัญทั้งในด้านการสร้างรายได้ การจ้างงาน และการสร้างความมั่นคงทางอาหารของประเทศ ตามข้อมูลของสำนักงานเศรษฐกิจการเกษตร กระทรวงเกษตรและสหกรณ์ พบว่ามีเกษตรกรไทยมากกว่า 11 ล้านครัวเรือนที่พึ่งพาการเกษตรเป็นอาชีพหลัก คิดเป็นสัดส่วนประมาณร้อยละ 30 ของประชากรทั้งประเทศ ภาคการเกษตรมีส่วนสำคัญต่อผลิตภัณฑ์มวลรวมในประเทศ (GDP) และเป็นแหล่งสร้างรายได้จากการส่งออกที่สำคัญของประเทศ

อย่างไรก็ตาม แม้ว่าภาคการเกษตรจะมีความสำคัญต่อเศรษฐกิจของประเทศ แต่เกษตรกรส่วนใหญ่ยังคงเผชิญกับปัญหาและความท้าทายหลายประการที่ส่งผลกระทบต่อประสิทธิภาพการผลิต รายได้ และคุณภาพชีวิต ปัญหาเหล่านี้สามารถจำแนกได้เป็น 4 ประเด็นหลัก ดังนี้

ประการแรก การตัดสินใจเลือกพืชที่ไม่เหมาะสมเป็นปัญหาพื้นฐานที่พบได้บ่อยในภาคการเกษตรไทย เกษตรกรส่วนใหญ่มักเลือกปลูกพืชตามประสบการณ์ที่สั่งสมมา หรือตามกระแสของตลาดในขณะนั้น โดยไม่ได้พิจารณาปัจจัยสำคัญอย่างครบถ้วนและเป็นระบบ เช่น ความเหมาะสมของสภาพดินในพื้นที่ สภาพอากาศและฤดูกาล งบประมาณที่มีอยู่ ความต้องการของตลาด และแนวโน้มราคาในอนาคต การตัดสินใจที่ขาดข้อมูลประกอบที่เพียงพอส่งผลให้ผลผลิตไม่เป็นไปตามที่คาดหวัง มีคุณภาพต่ำ หรือไม่สามารถขายได้ในราคาที่เหมาะสม ซึ่งนำไปสู่ความสูญเสียทางเศรษฐกิจและหนี้สินที่เพิ่มขึ้น

ประการที่สอง การกำหนดช่วงเวลาปลูกที่ไม่เหมาะสมเป็นอีกหนึ่งปัญหาสำคัญที่ส่งผลกระทบต่อผลผลิตและรายได้ของเกษตรกร การปลูกพืชในช่วงเวลาที่ไม่เหมาะสมอาจทำให้พืชเจริญเติบโตไม่ดี ได้รับผลกระทบจากภัยธรรมชาติ เช่น ฝนแล้ง น้ำท่วม หรือโรคระบาด หรือเก็บเกี่ยวในช่วงที่ราคาตกต่ำเนื่องจากผลผลิตออกสู่ตลาดพร้อมกันเป็นจำนวนมาก ตัวอย่างเช่น การปลูกข้าวนอกฤดูกาลอาจทำให้ต้องเผชิญกับปัญหาขาดแคลนน้ำ ในขณะที่การปลูกผักในช่วงฤดูฝนอาจทำให้ผลผลิตเสียหายจากน้ำท่วมหรือโรคพืช การเลือกช่วงเวลาปลูกที่เหมาะสมจึงเป็นปัจจัยสำคัญที่ส่งผลต่อความสำเร็จของการเพาะปลูก

ประการที่สาม ความไม่แน่นอนและความผันผวนของราคาผลผลิตทางการเกษตรเป็นปัญหาที่สร้างความยากลำบากให้กับเกษตรกรอย่างมาก ราคาผลผลิตทางการเกษตรมีความผันผวนสูงเนื่องจากได้รับอิทธิพลจากหลายปัจจัย ทั้งปัจจัยด้านอุปทานและอุปสงค์ สภาพอากาศ ต้นทุนการผลิต นโยบายของรัฐบาล และสถานการณ์ตลาดโลก เกษตรกรไม่สามารถคาดการณ์ราคาในอนาคตได้อย่างแม่นยำ ทำให้การวางแผนการผลิตและการบริหารจัดการทางการเงินเป็นไปได้ยาก ในบางกรณี เกษตรกรอาจต้องขายผลผลิตในราคาที่ต่ำกว่าต้นทุนการผลิต ส่งผลให้เกิดความสูญเสียและหนี้สินสะสม การมีระบบพยากรณ์ราคาที่เชื่อถือได้จึงเป็นสิ่งที่เกษตรกรต้องการอย่างยิ่ง

ประการที่สี่ การตัดสินใจเก็บเกี่ยวที่ไม่เหมาะสมส่งผลกระทบโดยตรงต่อรายได้ของเกษตรกร การเก็บเกี่ยวเร็วเกินไปอาจทำให้ผลผลิตมีคุณภาพต่ำ น้ำหนักไม่เต็มที่ หรือราคาขายต่ำ ในขณะที่การเก็บเกี่ยวช้าเกินไปอาจทำให้ผลผลิตเสื่อมคุณภาพ เน่าเสีย หรือพลาดโอกาสในการขายในช่วงที่ราคาดี นอกจากนี้ เกษตรกรยังต้องตัดสินใจว่าควรขายผลผลิตทันทีหลังเก็บเกี่ยว หรือควรเก็บรักษาไว้เพื่อรอขายในช่วงที่ราคาสูงขึ้น ซึ่งเป็นการตัดสินใจที่มีความเสี่ยงและต้องอาศัยข้อมูลประกอบการตัดสินใจที่ดี

ปัญหาทั้งสี่ประการที่กล่าวมาข้างต้นส่งผลให้เกษตรกรมีรายได้ที่ไม่แน่นอน ประสบปัญหาหนี้สิน และไม่สามารถพัฒนาคุณภาพชีวิตได้อย่างยั่งยืน ในยุคปัจจุบันที่เทคโนโลยีดิจิทัลและปัญญาประดิษฐ์ (Artificial Intelligence) ได้รับการพัฒนาอย่างก้าวกระโดดและมีการนำไปประยุกต์ใช้ในหลากหลายอุตสาหกรรม การนำเทคโนโลยีเหล่านี้มาประยุกต์ใช้ในภาคการเกษตรจึงเป็นแนวทางที่มีศักยภาพสูงในการแก้ไขปัญหาดังกล่าว โดยเฉพาะการใช้ Machine Learning ในการวิเคราะห์ข้อมูลขนาดใหญ่ ค้นหาความสัมพันธ์ที่ซับซ้อน และสนับสนุนการตัดสินใจของเกษตรกรด้วยข้อมูลที่มีความน่าเชื่อถือ

ระบบสนับสนุนการตัดสินใจที่ใช้ปัญญาประดิษฐ์สามารถช่วยเกษตรกรในการวิเคราะห์ปัจจัยต่างๆ ที่มีผลต่อการเพาะปลูก เช่น สภาพดิน สภาพอากาศ ราคาตลาด และแนวโน้มทางเศรษฐกิจ เพื่อให้คำแนะนำที่เหมาะสมในแต่ละขั้นตอนของการเพาะปลูก ตั้งแต่การเลือกพืช การกำหนดช่วงเวลาปลูก การพยากรณ์ราคา ไปจนถึงการตัดสินใจเก็บเกี่ยว ซึ่งจะช่วยเพิ่มประสิทธิภาพการผลิต ลดความเสี่ยง และสนับสนุนให้เกษตรกรสามารถวางแผนการเพาะปลูกได้อย่างมีประสิทธิภาพมากขึ้น


1.2 วัตถุประสงค์ของโครงการ

จากปัญหาและความท้าทายที่เกษตรกรไทยเผชิญอยู่ในปัจจุบัน โครงการนี้จึงมีวัตถุประสงค์หลักเพื่อพัฒนาระบบปัญญาประดิษฐ์สำหรับการเกษตรอัจฉริยะ (Farmme: Farm Management with Machine Learning and Explainable AI) ที่ใช้เทคโนโลยี Machine Learning ในการวิเคราะห์ข้อมูลและสนับสนุนการตัดสินใจของเกษตรกรตลอดวงจรการเพาะปลูก ตั้งแต่ขั้นตอนการวางแผนก่อนการปลูก การเลือกพืชที่เหมาะสม การกำหนดช่วงเวลาปลูกที่เหมาะสมที่สุด การพยากรณ์ราคาผลผลิตในอนาคต ไปจนถึงการตัดสินใจเก็บเกี่ยวในเวลาที่เหมาะสม ระบบนี้ได้รับการออกแบบให้เป็นระบบแบบครบวงจร (End-to-End System) ที่สามารถให้คำแนะนำที่เชื่อมโยงกันและสอดคล้องกันตลอดกระบวนการเพาะปลูก โดยมีวัตถุประสงค์เฉพาะดังนี้

1.2.1 วัตถุประสงค์เฉพาะ

1) พัฒนาระบบแนะนำพืช (Crop Recommendation System - Model A) ที่ใช้อัลกอริทึม XGBoost และ NSGA-II ในการวิเคราะห์ข้อมูลหลายมิติ ได้แก่ ข้อมูลฟาร์ม (ขนาดพื้นที่ ประสบการณ์ของเกษตรกร) สภาพดิน (ค่า pH ความอุดมสมบูรณ์) สภาพอากาศ (อุณหภูมิ ปริมาณน้ำฝน) และงบประมาณที่มีอยู่ เพื่อคาดการณ์ผลตอบแทนจากการลงทุน (Return on Investment: ROI) และแนะนำพืชที่เหมาะสมที่สุด 3-5 อันดับแรก พร้อมทั้งแสดงข้อมูลเปรียบเทียบระหว่างพืชแต่ละชนิด ทั้งในด้านกำไรที่คาดว่าจะได้รับ ความเสี่ยง ระยะเวลาในการเพาะปลูก และความเหมาะสมกับสภาพพื้นที่ ระบบนี้ช่วยให้เกษตรกรสามารถเลือกปลูกพืชได้อย่างมีเหตุผล มีข้อมูลประกอบการตัดสินใจที่ชัดเจน และคุ้มค่าทางเศรษฐกิจ

2) พัฒนาระบบพยากรณ์ช่วงเวลาปลูก (Planting Window Prediction - Model B) ที่ใช้อัลกอริทึม Logistic Regression และ XGBoost ในการวิเคราะห์ความเหมาะสมของช่วงเวลาในการปลูกพืชแต่ละชนิด โดยพิจารณาจากข้อมูลสภาพอากาศย้อนหลังและการพยากรณ์สภาพอากาศในอนาคต ข้อมูลสภาพดิน และข้อมูลทางประวัติศาสตร์ของการเพาะปลูกในพื้นที่นั้นๆ ระบบสามารถจำแนกช่วงเวลาออกเป็น "เหมาะสม" หรือ "ไม่เหมาะสม" พร้อมทั้งให้คะแนนความเชื่อมั่นของการพยากรณ์ เพื่อลดโอกาสที่พืชจะได้รับความเสียหายจากภัยธรรมชาติ เช่น ฝนแล้ง น้ำท่วม หรือโรคระบาดตามฤดูกาล ซึ่งจะช่วยเพิ่มโอกาสความสำเร็จในการเพาะปลูกและลดความเสี่ยงจากการสูญเสียผลผลิต

3) พัฒนาระบบพยากรณ์ราคา (Price Forecasting System - Model C) ที่ใช้เทคนิคการพยากรณ์อนุกรมเวลา (Time Series Forecasting) ร่วมกับการวิเคราะห์ปัจจัยภายนอก เพื่อพยากรณ์ราคาผลผลิตทางการเกษตรในอนาคต โดยระบบจะวิเคราะห์ข้อมูลราคาย้อนหลัง ข้อมูลสภาพอากาศที่มีผลต่ออุปทาน ตัวชี้วัดทางเศรษฐกิจที่มีผลต่ออุปสงค์ เช่น ราคาน้ำมันเชื้อเพลิง ต้นทุนปุ๋ย อัตราเงินเฟ้อ และปริมาณการส่งออก รวมถึงปัจจัยตามฤดูกาลและแนวโน้มของตลาด ระบบนี้ช่วยให้เกษตรกรสามารถวางแผนการขายล่วงหน้า คาดการณ์รายได้ที่จะได้รับ และตัดสินใจว่าควรขายผลผลิตทันทีหรือเก็บรักษาไว้เพื่อรอขายในช่วงที่ราคาสูงขึ้น

4) พัฒนาระบบตัดสินใจเก็บเกี่ยว (Harvest Decision System - Model D) ที่ใช้อัลกอริทึม Thompson Sampling ซึ่งเป็นเทคนิคจากกลุ่ม Multi-Armed Bandit ในการตัดสินใจภายใต้ความไม่แน่นอน ระบบจะวิเคราะห์ว่าควรเก็บเกี่ยวผลผลิตในปัจจุบันหรือรอช่วงเวลาที่เหมาะสมกว่า โดยพิจารณาจากการพยากรณ์ราคาในอนาคต ต้นทุนการเก็บรักษา ความเสี่ยงจากการเสื่อมคุณภาพของผลผลิต และโอกาสในการขายในราคาที่ดีกว่า ระบบจะคำนวณกำไรที่คาดว่าจะได้รับในแต่ละทางเลือกและแนะนำทางเลือกที่ให้ผลตอบแทนสูงสุด เพื่อเพิ่มรายได้จากการเลือกจังหวะเก็บเกี่ยวที่เหมาะสม

5) บูรณาการระบบทั้ง 4 ส่วนเข้าด้วยกัน เป็น End-to-End Pipeline ที่โมเดลแต่ละส่วนสามารถทำงานร่วมกันและส่งผ่านข้อมูลระหว่างกันได้อย่างมีประสิทธิภาพ โดยผลลัพธ์จากโมเดลหนึ่งสามารถนำไปใช้เป็นข้อมูลเข้าของโมเดลอื่นได้ เช่น พืชที่แนะนำจาก Model A จะถูกนำไปใช้ในการพยากรณ์ช่วงเวลาปลูกใน Model B และการพยากรณ์ราคาใน Model C ซึ่งจะช่วยให้ระบบสามารถให้คำแนะนำแบบครบวงจรและสอดคล้องกันตลอดกระบวนการเพาะปลูก ตั้งแต่ก่อนปลูกจนถึงหลังเก็บเกี่ยว

6) พัฒนาแอปพลิเคชันเว็บและแดชบอร์ด (Dashboard) ที่มีส่วนติดต่อผู้ใช้ (User Interface) ที่ออกแบบมาให้ใช้งานง่าย เข้าใจได้ง่าย และเหมาะสมกับผู้ใช้ที่มีความรู้ทางเทคโนโลยีในระดับต่างๆ โดยใช้เทคโนโลยี React สำหรับ Frontend และ FastAPI สำหรับ Backend ระบบสามารถแสดงผลข้อมูลในรูปแบบกราฟ ตาราง และแผนที่ที่เข้าใจได้ง่าย พร้อมทั้งมีระบบแจ้งเตือนและคำแนะนำที่ชัดเจน เพื่อให้เกษตรกรสามารถเข้าถึงข้อมูลและใช้งานระบบได้อย่างมีประสิทธิภาพผ่านอุปกรณ์ต่างๆ ทั้งคอมพิวเตอร์ แท็บเล็ต และสมาร์ทโฟน

1.2.2 วัตถุประสงค์ด้านเทคนิค

นอกจากวัตถุประสงค์เฉพาะในการพัฒนาระบบแต่ละส่วนแล้ว โครงการนี้ยังมีวัตถุประสงค์ด้านเทคนิคที่สำคัญเพื่อให้ระบบมีคุณภาพ ความน่าเชื่อถือ และสามารถนำไปใช้งานจริงได้ ดังนี้

1) พัฒนากลไกการป้องกันการรั่วไหลของข้อมูล (Data Leakage Prevention Framework) อย่างเป็นระบบและครอบคลุม เพื่อให้แน่ใจว่าโมเดลไม่ได้ใช้ข้อมูลในอนาคตหรือข้อมูลที่ไม่ควรมีในขั้นตอนการทำนาย ซึ่งเป็นปัญหาที่พบบ่อยในการพัฒนาโมเดล Machine Learning สำหรับข้อมูลอนุกรมเวลา กลไกนี้ประกอบด้วยการตรวจสอบความถูกต้องของ Feature Engineering การแบ่งข้อมูลแบบเคารพลำดับเวลา (Temporal Split) และการตรวจสอบความสัมพันธ์ระหว่างตัวแปรอิสระและตัวแปรตาม เพื่อให้ผลการประเมินประสิทธิภาพของโมเดลมีความน่าเชื่อถือและสามารถนำไปใช้งานจริงได้

2) ลดปัญหาอคติทางเวลา (Temporal Bias) ในการพยากรณ์ราคา โดยการบูรณาการข้อมูลหลายมิติ ทั้งข้อมูลสภาพอากาศที่มีผลต่ออุปทาน ตัวชี้วัดทางเศรษฐกิจที่มีผลต่ออุปสงค์ และปัจจัยตามฤดูกาล เพื่อไม่ให้โมเดลพึ่งพาข้อมูลราคาในอดีตมากเกินไป (มากกว่าร้อยละ 95) ซึ่งจะทำให้โมเดลไม่สามารถปรับตัวกับการเปลี่ยนแปลงของตลาดได้ การลดอคติทางเวลานี้จะช่วยเพิ่มความแม่นยำและความทนทานของโมเดลในสถานการณ์ที่ตลาดมีการเปลี่ยนแปลงอย่างกะทันหัน

3) พัฒนาระบบที่สามารถอธิบายเหตุผลของคำแนะนำได้ (Explainable AI) โดยใช้เทคนิค Feature Importance Analysis และ SHAP (SHapley Additive exPlanations) เพื่อแสดงให้เห็นว่าปัจจัยใดมีผลต่อการตัดสินใจของโมเดลมากที่สุด และทำไมระบบจึงแนะนำในลักษณะนั้น การมีความสามารถในการอธิบายผลลัพธ์จะช่วยสร้างความเชื่อมั่นให้กับผู้ใช้งาน และช่วยให้เกษตรกรเข้าใจเหตุผลเบื้องหลังคำแนะนำ ซึ่งจะนำไปสู่การยอมรับและการใช้งานระบบที่มากขึ้น

4) พัฒนาระบบที่มีความทนทาน (Robust System) ต่อข้อมูลที่ขาดหายหรือความผิดพลาดของ API ภายนอก โดยการออกแบบระบบให้สามารถทำงานได้แม้ว่าข้อมูลบางส่วนจะไม่สมบูรณ์ มีการใช้เทคนิค Imputation สำหรับการจัดการข้อมูลที่ขาดหาย การตั้งค่า Fallback Mechanism สำหรับกรณีที่ API ภายนอกไม่สามารถเชื่อมต่อได้ และการแสดงระดับความเชื่อมั่นของการพยากรณ์ตามความสมบูรณ์ของข้อมูล เพื่อให้ระบบสามารถใช้งานได้ในสภาพแวดล้อมจริงที่อาจมีข้อจำกัดด้านข้อมูลหรือการเชื่อมต่ออินเทอร์เน็ต


1.3 ขอบเขตของโครงการ

1.3.1 ขอบเขตด้านพื้นที่

โครงการนี้มุ่งเน้นพื้นที่การเกษตรในประเทศไทย ครอบคลุมทั้ง 77 จังหวัด โดยแบ่งตามภูมิภาคทางภูมิศาสตร์ ได้แก่ ภาคเหนือ ภาคตะวันออกเฉียงเหนือ ภาคกลาง ภาคตะวันออก ภาคตะวันตก และภาคใต้

1.3.2 ขอบเขตด้านพืช

ระบบรองรับพืชเศรษฐกิจหลักของไทย จำนวน 46 ชนิด แบ่งเป็น 4 กลุ่มหลัก ได้แก่ พืชผัก พืชไร่ พืชสวน และพืชเครื่องเทศ โดยเลือกพืชที่มีความสำคัญทางเศรษฐกิจและมีการปลูกอย่างแพร่หลายในประเทศไทย

1.3.3 ขอบเขตด้านข้อมูล

โครงการใช้ชุดข้อมูลสังเคราะห์ (Synthetic Dataset) ที่ออกแบบมาเพื่อจำลองสถานการณ์การเกษตรในประเทศไทย โดยมีการควบคุมคุณสมบัติทางสถิติให้สอดคล้องกับข้อมูลจริง ประกอบด้วย:
- ข้อมูลการเพาะปลูก จำนวน 6,226 บันทึก
- ข้อมูลลักษณะพืช จำนวน 46 ชนิด
- ข้อมูลสภาพอากาศ จำนวน 56,287 บันทึก
- ข้อมูลราคา จำนวน 2,289,492 บันทึก
- ข้อมูลเศรษฐกิจ จำนวน 731 บันทึก

การใช้ข้อมูลสังเคราะห์เป็นแนวทางที่ยอมรับในงานวิจัย Machine Learning โดยเฉพาะในกรณีที่ข้อมูลจริงมีข้อจำกัดในการเข้าถึง และต้องการควบคุมคุณภาพและความสมบูรณ์ของข้อมูล

1.3.4 ขอบเขตด้านเทคนิค

ระบบใช้อัลกอริทึม Machine Learning หลายประเภท ได้แก่ XGBoost สำหรับการแนะนำพืชและการพยากรณ์ช่วงเวลาปลูก, Logistic Regression สำหรับการจำแนกช่วงเวลาที่เหมาะสม, NSGA-II สำหรับการเพิ่มประสิทธิภาพหลายวัตถุประสงค์ และ Thompson Sampling สำหรับการตัดสินใจเก็บเกี่ยว

ระบบได้รับการออกแบบให้เน้นความเรียบง่ายและความสามารถในการอธิบายผลลัพธ์ โดยใช้ GPU ในขั้นตอนการฝึกโมเดล แต่รองรับการทำงานบน CPU เมื่อนำไปใช้งานจริง ระบบยังคงเป็นแบบสแตนด์อโลน (Standalone) และยังไม่ได้เชื่อมต่อกับระบบเมืองอัจฉริยะ (Smart City) แบบเต็มรูปแบบ

1.3.5 ข้อจำกัดของโครงการ

1) การใช้ข้อมูลสังเคราะห์แทนข้อมูลจริง ซึ่งแม้จะมีคุณสมบัติทางสถิติที่สอดคล้องกับข้อมูลจริง แต่อาจไม่สามารถสะท้อนความซับซ้อนของสถานการณ์จริงได้ทั้งหมด

2) การใช้ตัวแปรสภาพอากาศพื้นฐาน ได้แก่ อุณหภูมิ ปริมาณน้ำฝน ความชื้น และดัชนีภัยแล้ง โดยยังไม่ได้รวมตัวแปรอื่นๆ ที่อาจมีผลกระทบ เช่น ความเร็วลม แสงแดด หรือคุณภาพอากาศ

3) ระบบยังไม่ได้รับการทดสอบกับเกษตรกรจริงในสภาพแวดล้อมการใช้งานจริง

4) ระบบยังไม่พร้อมสำหรับการขยายผลไปใช้งานทั่วประเทศในทันที ต้องมีการปรับปรุงและพัฒนาเพิ่มเติม


1.4 ประโยชน์ที่คาดว่าจะได้รับ

1.4.1 ประโยชน์ด้านการพัฒนาระบบ

1) ระบบสามารถแนะนำพืชที่เหมาะสมได้ตามเงื่อนไขที่กำหนด โดยพิจารณาจากหลายปัจจัยอย่างครบถ้วน

2) ระบบสามารถพยากรณ์ราคาได้ด้วยความแม่นยำที่วัดได้จากค่า R² และ MAE ซึ่งสามารถนำไปใช้เป็นข้อมูลประกอบการตัดสินใจ

3) ระบบมี API (Application Programming Interface) ที่สามารถเชื่อมต่อกับแอปพลิเคชันอื่นได้ ทำให้สามารถขยายการใช้งานได้ในอนาคต

4) ระบบมีส่วนติดต่อผู้ใช้ (User Interface) และแดชบอร์ดที่ออกแบบมาให้ใช้งานง่าย แสดงผลข้อมูลอย่างชัดเจน และเข้าถึงได้สะดวก

1.4.2 ประโยชน์ทางวิชาการ

1) สร้างองค์ความรู้ใหม่ในการประยุกต์ใช้ปัญญาประดิษฐ์ในภาคการเกษตรไทย โดยเฉพาะการบูรณาการโมเดล Machine Learning หลายประเภทเข้าด้วยกัน

2) พัฒนาแนวทางการป้องกันการรั่วไหลของข้อมูล (Data Leakage Prevention) ในการสร้างโมเดล Machine Learning สำหรับข้อมูลอนุกรมเวลา ซึ่งสามารถนำไปประยุกต์ใช้กับงานวิจัยอื่นๆ ได้

3) แสดงให้เห็นถึงวิธีการสร้างและตรวจสอบคุณภาพของข้อมูลสังเคราะห์ที่มีความสัมพันธ์เชิงพื้นที่และเวลา ซึ่งเป็นประโยชน์สำหรับงานวิจัยที่มีข้อจำกัดในการเข้าถึงข้อมูลจริง

4) เป็นแนวทางในการพัฒนาระบบที่คล้ายคลึงกันสำหรับพืชชนิดอื่นหรือพื้นที่อื่นๆ

1.4.3 ประโยชน์ในอนาคต

เมื่อระบบได้รับการพัฒนาและทดสอบกับข้อมูลจริงแล้ว คาดว่าจะสามารถนำไปใช้เป็นเครื่องมือสนับสนุนการตัดสินใจของเกษตรกร ช่วยให้สามารถวางแผนการเพาะปลูกได้อย่างมีประสิทธิภาพมากขึ้น และอาจนำไปสู่การเพิ่มรายได้และลดความเสี่ยงในการทำการเกษตรในระยะยาว
บทที่ 2: ทฤษฎีและงานวิจัยที่เกี่ยวข้อง

บทนี้นำเสนอรากฐานทางทฤษฎีและงานวิจัยที่เกี่ยวข้องซึ่งเป็นพื้นฐานสำหรับการพัฒนาระบบ Farmme โดยแบ่งออกเป็น 2 ส่วนหลัก ได้แก่ ส่วนที่ 1 ทฤษฎีที่เกี่ยวข้อง ซึ่งอธิบายหลักการและทฤษฎีทางคณิตศาสตร์ที่นำมาใช้ในการพัฒนาระบบ และส่วนที่ 2 งานวิจัยที่เกี่ยวข้อง ซึ่งทบทวนงานวิจัยและระบบที่มีอยู่แล้วในด้านการประยุกต์ใช้ Machine Learning ในภาคการเกษตร


ส่วนที่ 1: ทฤษฎีที่เกี่ยวข้อง

2.1 นิยามศัพท์เฉพาะและแนวคิดพื้นฐาน

ก่อนที่จะอธิบายทฤษฎีที่ใช้ในการพัฒนาระบบ จำเป็นต้องนิยามศัพท์เฉพาะและแนวคิดพื้นฐานที่สำคัญเพื่อให้เกิดความเข้าใจที่ชัดเจน

2.1.1 Machine Learning (การเรียนรู้ของเครื่อง)

Machine Learning หรือการเรียนรู้ของเครื่อง เป็นสาขาหนึ่งของปัญญาประดิษฐ์ (Artificial Intelligence) ที่ศึกษาเกี่ยวกับการพัฒนาอัลกอริทึมและแบบจำลองทางสถิติที่ทำให้คอมพิวเตอร์สามารถเรียนรู้จากข้อมูลและปรับปรุงประสิทธิภาพในการทำงานได้เองโดยไม่ต้องเขียนโปรแกรมโดยตรง การเรียนรู้ของเครื่องสามารถแบ่งออกเป็น 3 ประเภทหลัก ได้แก่ การเรียนรู้แบบมีผู้สอน (Supervised Learning) ซึ่งใช้ข้อมูลที่มีป้ายกำกับในการฝึกโมเดล การเรียนรู้แบบไม่มีผู้สอน (Unsupervised Learning) ซึ่งค้นหารูปแบบในข้อมูลที่ไม่มีป้ายกำกับ และการเรียนรู้แบบเสริมกำลัง (Reinforcement Learning) ซึ่งเรียนรู้จากการลองผิดลองถูกและได้รับรางวัลหรือการลงโทษจากการกระทำ

2.1.2 Data Leakage (การรั่วไหลของข้อมูล)

Data Leakage หรือการรั่วไหลของข้อมูล หมายถึงปัญหาที่เกิดขึ้นเมื่อข้อมูลที่ไม่ควรมีในขั้นตอนการทำนาย เช่น ข้อมูลในอนาคตหรือข้อมูลที่ได้มาจากตัวแปรเป้าหมาย ถูกนำมาใช้ในการฝึกโมเดล ทำให้ผลการประเมินประสิทธิภาพของโมเดลดีเกินจริงและไม่สามารถนำไปใช้งานจริงได้ การรั่วไหลของข้อมูลสามารถแบ่งออกเป็นหลายประเภท ได้แก่ การรั่วไหลทางเวลา (Temporal Leakage) ซึ่งเกิดจากการใช้ข้อมูลในอนาคตเพื่อทำนายอดีต การรั่วไหลเป้าหมาย (Target Leakage) ซึ่งเกิดจากการใช้ตัวแปรที่ได้มาจากหรือสัมพันธ์สูงกับตัวแปรเป้าหมาย และการปนเปื้อนระหว่างชุดฝึกและชุดทดสอบ (Train-Test Contamination) ซึ่งเกิดจากการที่ข้อมูลจากชุดทดสอบมีอิทธิพลต่อการฝึกโมเดล

2.1.3 Feature Engineering (วิศวกรรมคุณลักษณะ)

Feature Engineering หรือวิศวกรรมคุณลักษณะ เป็นกระบวนการสร้างและคัดเลือกตัวแปร (Features) ที่เหมาะสมจากข้อมูลดิบเพื่อใช้ในการฝึกโมเดล Machine Learning กระบวนการนี้ประกอบด้วยหลายขั้นตอน เช่น การสร้างตัวแปรใหม่จากตัวแปรเดิม (Feature Creation) การแปลงตัวแปร (Feature Transformation) การเข้ารหัสตัวแปรเชิงหมวดหมู่ (Categorical Encoding) การปรับมาตรฐาน (Normalization/Standardization) และการคัดเลือกตัวแปรที่สำคัญ (Feature Selection) วิศวกรรมคุณลักษณะที่ดีสามารถเพิ่มประสิทธิภาพของโมเดลได้อย่างมีนัยสำคัญ

2.1.4 ROI (Return on Investment - ผลตอบแทนจากการลงทุน)

ROI หรือผลตอบแทนจากการลงทุน เป็นตัวชี้วัดทางการเงินที่ใช้ประเมินประสิทธิภาพของการลงทุน คำนวณจากสูตร ROI = (กำไร / ต้นทุนการลงทุน) × 100% ในบริบทของการเกษตร ROI ใช้ในการประเมินความคุ้มค่าของการเพาะปลูกพืชแต่ละชนิด โดยพิจารณาจากรายได้ที่ได้จากการขายผลผลิตหักด้วยต้นทุนทั้งหมดที่ใช้ในการเพาะปลูก ค่า ROI ที่สูงแสดงว่าการลงทุนนั้นให้ผลตอบแทนที่ดี


2.1.5 ตัวชี้วัดประสิทธิภาพของโมเดล

ในการประเมินประสิทธิภาพของโมเดล Machine Learning จำเป็นต้องใช้ตัวชี้วัดที่เหมาะสมกับประเภทของปัญหา สำหรับปัญหาการถดถอย (Regression) ตัวชี้วัดที่นิยมใช้ ได้แก่ R² (R-squared หรือค่าสัมประสิทธิ์การตัดสินใจ) ซึ่งวัดสัดส่วนของความแปรปรวนของตัวแปรตามที่สามารถอธิบายได้ด้วยตัวแปรอิสระ มีค่าอยู่ระหว่าง 0 ถึง 1 โดยค่าที่ใกล้ 1 แสดงว่าโมเดลสามารถอธิบายข้อมูลได้ดี MAE (Mean Absolute Error) ซึ่งเป็นค่าเฉลี่ยของความคลาดเคลื่อนสัมบูรณ์ และ RMSE (Root Mean Squared Error) ซึ่งเป็นรากที่สองของค่าเฉลี่ยของความคลาดเคลื่อนกำลังสอง สำหรับปัญหาการจำแนก (Classification) ตัวชี้วัดที่นิยมใช้ ได้แก่ Accuracy (ความแม่นยำ) Precision (ความแม่นตรง) Recall (ความครอบคลุม) และ F1-Score ซึ่งเป็นค่าเฉลี่ยฮาร์มอนิกของ Precision และ Recall


2.2 อัลกอริทึม Machine Learning ที่ใช้ในระบบ

2.2.1 XGBoost (Extreme Gradient Boosting)

XGBoost เป็นอัลกอริทึม Machine Learning ประเภท Ensemble Learning ที่พัฒนาจาก Gradient Boosting โดย Chen และ Guestrin ในปี 2016 อัลกอริทึมนี้ทำงานโดยการสร้าง Decision Tree หลายต้นแบบต่อเนื่อง (Sequential) โดยแต่ละต้นจะเรียนรู้จากข้อผิดพลาดของต้นก่อนหน้า และรวมผลการทำนายจากทุกต้นเข้าด้วยกัน XGBoost มีจุดเด่นหลายประการ ได้แก่ ความเร็วในการคำนวณที่สูงเนื่องจากการใช้เทคนิค Parallelization การจัดการข้อมูลที่ขาดหายได้โดยอัตโนมัติ การมี Regularization ในตัวเพื่อป้องกัน Overfitting และความสามารถในการจับความสัมพันธ์ที่ซับซ้อนระหว่างตัวแปร

สูตรการคำนวณ Objective Function ของ XGBoost คือ:

L(φ) = Σᵢ l(ŷᵢ, yᵢ) + Σₖ Ω(fₖ)

โดยที่ l คือ Loss Function ที่วัดความคลาดเคลื่อนระหว่างค่าทำนาย (ŷᵢ) และค่าจริง (yᵢ) และ Ω คือ Regularization Term ที่ควบคุมความซับซ้อนของโมเดล ในระบบ Farmme XGBoost ถูกนำมาใช้ใน Model A สำหรับการแนะนำพืช และ Model B สำหรับการพยากรณ์ช่วงเวลาปลูก เนื่องจากมีประสิทธิภาพสูงและสามารถจัดการข้อมูลที่มีความซับซ้อนได้ดี

2.2.2 Logistic Regression (การถดถอยโลจิสติก)

Logistic Regression เป็นอัลกอริทึมทางสถิติที่ใช้สำหรับปัญหาการจำแนกประเภท (Classification) โดยเฉพาะการจำแนกแบบไบนารี (Binary Classification) แม้ว่าจะมีคำว่า "Regression" ในชื่อ แต่จริงๆ แล้วเป็นอัลกอริทึมสำหรับการจำแนก อัลกอริทึมนี้ทำงานโดยการใช้ Logistic Function (หรือ Sigmoid Function) ในการแปลงค่าผลลัพธ์ให้อยู่ในช่วง 0 ถึง 1 ซึ่งสามารถตีความเป็นความน่าจะเป็นของการเป็นคลาสใดคลาสหนึ่งได้

สูตรของ Logistic Function คือ:

P(y=1|x) = 1 / (1 + e^(-z))

โดยที่ z = β₀ + β₁x₁ + β₂x₂ + ... + βₙxₙ

Logistic Regression มีข้อดีคือ เรียบง่าย คำนวณเร็ว สามารถตีความได้ง่าย และให้ผลลัพธ์เป็นความน่าจะเป็นที่สามารถนำไปใช้ในการตัดสินใจได้ ในระบบ Farmme Logistic Regression ถูกนำมาใช้ใน Model B สำหรับการจำแนกว่าช่วงเวลาใดเหมาะสมหรือไม่เหมาะสมสำหรับการปลูกพืช

2.2.3 NSGA-II (Non-dominated Sorting Genetic Algorithm II)

NSGA-II เป็นอัลกอริทึมวิวัฒนาการหลายวัตถุประสงค์ (Multi-Objective Evolutionary Algorithm) ที่พัฒนาโดย Deb และคณะในปี 2002 อัลกอริทึมนี้ถูกออกแบบมาเพื่อแก้ปัญหาการเพิ่มประสิทธิภาพที่มีหลายวัตถุประสงค์ที่ขัดแย้งกัน เช่น การเพิ่มกำไรสูงสุดและลดความเสี่ยงสูงสุดในเวลาเดียวกัน NSGA-II ทำงานโดยการสร้างประชากรของโซลูชันและวิวัฒนาการผ่านกระบวนการคัดเลือก (Selection) การข้าม (Crossover) และการกลายพันธุ์ (Mutation)

แนวคิดสำคัญของ NSGA-II คือ ความเหมาะสมที่สุดแบบพาเรโต (Pareto Optimality) ซึ่งโซลูชัน x* เป็นแบบพาเรโตที่เหมาะสมที่สุดหากไม่มีโซลูชันอื่นที่ดีกว่าในทุกวัตถุประสงค์ เซตของโซลูชันแบบพาเรโตที่เหมาะสมที่สุดทั้งหมดเรียกว่า แนวหน้าพาเรโต (Pareto Front) ซึ่งแสดงการแลกเปลี่ยน (Trade-off) ระหว่างวัตถุประสงค์ต่างๆ

NSGA-II มีกลไกสำคัญ 2 ประการ คือ การเรียงลำดับที่ไม่ถูกครอบงำอย่างรวดเร็ว (Fast Non-dominated Sorting) ซึ่งมีความซับซ้อน O(MN²) โดยที่ M คือจำนวนวัตถุประสงค์และ N คือขนาดประชากร และระยะห่างความแออัด (Crowding Distance) ซึ่งใช้ในการรักษาความหลากหลายของโซลูชันตามแนวหน้าพาเรโต ในระบบ Farmme NSGA-II ถูกนำมาใช้ใน Model A เพื่อหาพืชที่เหมาะสมที่สุดโดยพิจารณาหลายวัตถุประสงค์พร้อมกัน เช่น กำไร ความเสี่ยง และความยั่งยืน

2.2.4 Thompson Sampling

Thompson Sampling เป็นอัลกอริทึมสำหรับแก้ปัญหา Multi-Armed Bandit ซึ่งเป็นปัญหาการตัดสินใจภายใต้ความไม่แน่นอน โดยต้องเลือกระหว่างทางเลือกหลายทาง (Arms) ที่แต่ละทางมีการกระจายรางวัลที่ไม่ทราบค่าที่แน่นอน เป้าหมายคือการเพิ่มรางวัลสะสมสูงสุดในระยะยาว โดยต้องสมดุลระหว่างการสำรวจ (Exploration) เพื่อเรียนรู้เกี่ยวกับทางเลือกที่ยังไม่รู้จักดี และการใช้ประโยชน์ (Exploitation) เพื่อเลือกทางเลือกที่รู้จักว่าดีที่สุด

Thompson Sampling ใช้แนวทางแบบเบย์ (Bayesian Approach) โดยรักษาการกระจายความน่าจะเป็นภายหลัง (Posterior Distribution) ของรางวัลที่คาดหวังสำหรับแต่ละทางเลือก ในแต่ละขั้นตอน อัลกอริทึมจะสุ่มตัวอย่างค่ารางวัลที่คาดหวังจากการกระจายภายหลังของแต่ละทางเลือก และเลือกทางเลือกที่มีค่าสูงสุด หลังจากได้รับรางวัลจริง จะอัปเดตการกระจายภายหลังตามทฤษฎีบทของเบย์

สำหรับรางวัลแบบเบอร์นูลลี (Bernoulli Rewards) การกระจายภายหลังที่นิยมใช้คือ Beta Distribution ซึ่งมีการอัปเดตแบบปิด (Closed-form Update) คือ Beta(α + successes, β + failures) Thompson Sampling มีข้อดีคือ สมดุลการสำรวจและการใช้ประโยชน์ตามธรรมชาติ สามารถรวมความรู้ก่อนหน้า (Prior Knowledge) ได้ และมีประสิทธิภาพเชิงประจักษ์ที่แข็งแกร่ง ในระบบ Farmme Thompson Sampling ถูกนำมาใช้ใน Model D สำหรับการตัดสินใจเก็บเกี่ยว โดยต้องเลือกระหว่างการเก็บเกี่ยวทันทีหรือรอช่วงเวลาที่เหมาะสมกว่า



2.3 ทฤษฎีการพยากรณ์อนุกรมเวลา

การพยากรณ์อนุกรมเวลา (Time Series Forecasting) เป็นเทคนิคที่ใช้ในการทำนายค่าในอนาคตของตัวแปรที่เปลี่ยนแปลงตามเวลา โดยอาศัยข้อมูลในอดีตและรูปแบบที่เกิดขึ้นซ้ำๆ ในระบบ Farmme การพยากรณ์อนุกรมเวลาถูกนำมาใช้ใน Model C สำหรับการพยากรณ์ราคาผลผลิตทางการเกษตร

2.3.1 ARIMA (AutoRegressive Integrated Moving Average)

ARIMA เป็นแบบจำลองทางสถิติที่นิยมใช้สำหรับการพยากรณ์อนุกรมเวลา ประกอบด้วย 3 ส่วนหลัก คือ AR (AutoRegressive) ซึ่งใช้ค่าในอดีตของตัวแปรเองในการทำนาย I (Integrated) ซึ่งเป็นการหาความแตกต่าง (Differencing) เพื่อทำให้อนุกรมมีความนิ่ง (Stationary) และ MA (Moving Average) ซึ่งใช้ข้อผิดพลาดในอดีตในการทำนาย

แบบจำลอง ARIMA(p,d,q) สามารถเขียนได้ในรูป:

(1 - φ₁B - φ₂B² - ... - φₚBᵖ)(1-B)ᵈyₜ = (1 + θ₁B + θ₂B² + ... + θₑBᵍ)εₜ

โดยที่ p คือลำดับของ AR, d คือจำนวนครั้งของการหาความแตกต่าง, q คือลำดับของ MA, B คือ Backshift Operator และ εₜ คือ White Noise

ARIMA มีจุดแข็งคือ เรียบง่าย สามารถตีความได้ และทำงานได้ดีสำหรับอนุกรมที่มีความนิ่ง อย่างไรก็ตาม มีข้อจำกัดคือ ไม่สามารถจับความสัมพันธ์ไม่เชิงเส้นได้ และต้องการการปรับพารามิเตอร์อย่างระมัดระวัง

2.3.2 การแยกส่วนตามฤดูกาล (Seasonal Decomposition)

อนุกรมเวลาหลายประเภท โดยเฉพาะข้อมูลทางการเกษตร มักมีรูปแบบตามฤดูกาล (Seasonal Pattern) ที่เกิดขึ้นซ้ำๆ ในช่วงเวลาที่แน่นอน การแยกส่วนตามฤดูกาลเป็นเทคนิคที่แยกอนุกรมเวลาออกเป็นองค์ประกอบต่างๆ ได้แก่ แนวโน้ม (Trend) ซึ่งแสดงทิศทางการเปลี่ยนแปลงในระยะยาว ฤดูกาล (Seasonal) ซึ่งแสดงรูปแบบที่เกิดขึ้นซ้ำในช่วงเวลาคงที่ และส่วนที่เหลือ (Residual) ซึ่งเป็นความผันผวนที่ไม่สามารถอธิบายได้ด้วยแนวโน้มและฤดูกาล

การแยกส่วนสามารถทำได้ 2 แบบ คือ แบบบวก (Additive) ซึ่งเหมาะสำหรับอนุกรมที่ความผันผวนตามฤดูกาลคงที่ Y(t) = T(t) + S(t) + R(t) และแบบคูณ (Multiplicative) ซึ่งเหมาะสำหรับอนุกรมที่ความผันผวนตามฤดูกาลเปลี่ยนแปลงตามระดับของข้อมูล Y(t) = T(t) × S(t) × R(t)


2.4 ทฤษฎีการป้องกันการรั่วไหลของข้อมูล

การป้องกันการรั่วไหลของข้อมูลเป็นหลักการสำคัญในการพัฒนาโมเดล Machine Learning ที่สามารถนำไปใช้งานจริงได้ โดยเฉพาะสำหรับข้อมูลอนุกรมเวลา ซึ่งมีความเสี่ยงสูงต่อการรั่วไหลทางเวลา

2.4.1 ประเภทของการรั่วไหลของข้อมูล

การรั่วไหลทางเวลา (Temporal Leakage) เกิดขึ้นเมื่อข้อมูลในอนาคตถูกนำมาใช้ในการทำนายอดีต ตัวอย่างเช่น การใช้ราคาในวันถัดไปเพื่อทำนายความต้องการในวันปัจจุบัน การรั่วไหลเป้าหมาย (Target Leakage) เกิดขึ้นเมื่อตัวแปรที่ได้มาจากหรือสัมพันธ์สูงกับตัวแปรเป้าหมายถูกนำมาใช้เป็นตัวแปรอิสระ และการปนเปื้อนระหว่างชุดฝึกและชุดทดสอบ (Train-Test Contamination) เกิดขึ้นเมื่อข้อมูลจากชุดทดสอบมีอิทธิพลต่อการฝึกโมเดล เช่น การใช้สถิติจากข้อมูลทั้งหมดในการปรับมาตรฐานก่อนแบ่งข้อมูล

2.4.2 กลยุทธ์การป้องกัน

การป้องกันการรั่วไหลของข้อมูลต้องอาศัยความระมัดระวังในทุกขั้นตอนของการพัฒนาโมเดล สำหรับข้อมูลอนุกรมเวลา ต้องแบ่งข้อมูลตามลำดับเวลาอย่างเคร่งครัด โดยชุดทดสอบต้องอยู่หลังชุดฝึกเสมอ และไม่ใช้ข้อมูลจากชุดทดสอบในการฝึกโมเดลหรือการปรับพารามิเตอร์ใดๆ ในการสร้างตัวแปร ต้องใช้เฉพาะข้อมูลในอดีตเท่านั้น เช่น การสร้าง Lag Features ต้องใช้ shift() เพื่อเลื่อนข้อมูลไปข้างหลัง และการคำนวณสถิติแบบกลิ้ง (Rolling Statistics) ต้องไม่รวมค่าปัจจุบัน การใช้ Pipeline ใน scikit-learn ช่วยให้มั่นใจว่าการแปลงข้อมูลทั้งหมดใช้เฉพาะข้อมูลจากชุดฝึกเท่านั้น


ส่วนที่ 2: งานวิจัยที่เกี่ยวข้อง

2.5 การประยุกต์ใช้ Machine Learning ในภาคการเกษตร

การประยุกต์ใช้ Machine Learning ในภาคการเกษตรได้รับความสนใจเพิ่มขึ้นอย่างมากในช่วงทศวรรษที่ผ่านมา โดยมีการพัฒนาจากระบบผู้เชี่ยวชาญแบบง่ายในทศวรรษ 1980-1990 ซึ่งใช้กฎ if-then ที่เข้ารหัสความรู้ของผู้เชี่ยวชาญ ไปสู่การใช้แบบจำลองทางสถิติในทศวรรษ 1990-2000 เช่น การถดถอยเชิงเส้นสำหรับการพยากรณ์ผลผลิต จากนั้นในทศวรรษ 2000-2010 ได้มีการนำอัลกอริทึม Machine Learning ที่ซับซ้อนมากขึ้นมาใช้ เช่น Support Vector Machines และ Random Forests และในปัจจุบัน (ทศวรรษ 2010-ปัจจุบัน) ได้มีการใช้ Deep Learning และการบูรณาการข้อมูลจากหลายแหล่ง เช่น ภาพดาวเทียม เซนเซอร์ IoT และข้อมูลสภาพอากาศ

2.5.1 ระบบแนะนำพืช

งานวิจัยเกี่ยวกับระบบแนะนำพืชมีหลากหลายแนวทาง Puthumalar และคณะ (2016) ได้พัฒนาระบบแนะนำพืชโดยใช้ Naive Bayes Classifier ซึ่งสามารถทำนายพืชที่เหมาะสมได้ด้วยความแม่นยำร้อยละ 88 โดยพิจารณาจากข้อมูลดินและสภาพอากาศ Khosla และคณะ (2010) ได้ใช้แบบจำลองการถดถอยในการพัฒนาระบบเกษตรแม่นยำ (Precision Agriculture) ที่สามารถแนะนำพืชตามสภาพพื้นที่เฉพาะจุด Ramesh และ Vardhan (2015) ได้พัฒนาระบบที่ใช้ Ensemble Methods รวมกันระหว่าง Decision Trees, Random Forest และ SVM ซึ่งให้ความแม่นยำสูงถึงร้อยละ 92

อย่างไรก็ตาม ระบบเหล่านี้ส่วนใหญ่มีข้อจำกัดคือ มุ่งเน้นการเพิ่มประสิทธิภาพวัตถุประสงค์เดียว มักเป็นกำไรหรือผลผลิต โดยไม่ได้พิจารณาความเสี่ยงหรือความยั่งยืน นอกจากนี้ยังมีการจัดการข้อจำกัดของเกษตรกรที่จำกัด เช่น งบประมาณ ขนาดที่ดิน และประสบการณ์ และขาดความสามารถในการอธิบายผลลัพธ์ในแบบจำลองที่ซับซ้อน

2.5.2 การพยากรณ์ราคาผลผลิตทางการเกษตร

การพยากรณ์ราคาผลผลิตทางการเกษตรเป็นปัญหาที่ท้าทายเนื่องจากราคามีความผันผวนสูง (ส่วนเบี่ยงเบนมาตรฐานร้อยละ 15-30) และได้รับอิทธิพลจากหลายปัจจัย ทั้งอุปทาน อุปสงค์ สภาพอากาศ นโยบายของรัฐ และตลาดโลก แบบจำลองเศรษฐมิติแบบดั้งเดิม เช่น ARIMA และ GARCH ถูกนำมาใช้อย่างแพร่หลาย โดย ARIMA เหมาะสำหรับอนุกรมที่มีความนิ่งและมีรูปแบบเชิงเส้น ในขณะที่ GARCH ใช้สำหรับการสร้างแบบจำลองความผันผวนที่เปลี่ยนแปลงตามเวลา

ในช่วงหลังมีการนำ Machine Learning มาใช้มากขึ้น Tian และคณะ (2015) ได้ใช้ Support Vector Regression ในการพยากรณ์ราคาข้าวโพดและได้ RMSE เท่ากับ 0.12 Ribeiro และ Oliveira (2011) ได้ใช้ Random Forest Regression ในการทำนายราคาถั่วเหลือง Xiong และคณะ (2018) ได้ใช้ LSTM (Long Short-Term Memory) ซึ่งเป็น Deep Learning สำหรับข้อมูลลำดับในการพยากรณ์ราคาสินค้าเกษตรและได้ MAE เท่ากับร้อยละ 2.3 Chen และ Guestrin (2016) ได้พัฒนา XGBoost ซึ่งกลายเป็นอัลกอริทึมที่ได้รับความนิยมสูงสำหรับข้อมูลตารางเนื่องจากสามารถจัดการค่าที่ขาดหายและการโต้ตอบของตัวแปรได้ดี

Ubilava (2012) ได้ศึกษาผลกระทบของปรากฏการณ์เอลนีโญต่อราคาผลผลิตทางการเกษตร แสดงให้เห็นความสำคัญของการบูรณาการปัจจัยภายนอก เช่น ข้อมูลสภาพอากาศและตัวชี้วัดเศรษฐกิจ อย่างไรก็ตาม งานวิจัยส่วนใหญ่ยังคงมีปัญหาอคติทางเวลาสูง โดยพึ่งพาราคาล่าสุดมากเกินไป (มากกว่าร้อยละ 95) ทำให้โมเดลไม่สามารถปรับตัวกับการเปลี่ยนแปลงของตลาดได้ดี นอกจากนี้ยังขาดวิธีการวัดอคติเชิงปริมาณและการบูรณาการข้อมูลสภาพอากาศและเศรษฐกิจอย่างเป็นระบบ



2.5.3 การตัดสินใจเก็บเกี่ยว

การตัดสินใจเก็บเกี่ยวเป็นปัญหาที่ซับซ้อนซึ่งต้องพิจารณาทั้งปัจจัยทางการเกษตร เช่น ความสมบูรณ์ของพืช สภาพอากาศ และความพร้อมของแรงงาน และปัจจัยทางเศรษฐกิจ เช่น ราคาตลาดปัจจุบันเทียบกับราคาที่คาดหวังในอนาคต ค่าใช้จ่ายในการเก็บรักษา และการลดลงของคุณภาพเมื่อเวลาผ่านไป

แนวทางการเพิ่มประสิทธิภาพแบบดั้งเดิมใช้ Dynamic Programming ในการแก้ปัญหาการหยุดที่เหมาะสมที่สุด (Optimal Stopping Problem) โดยหาค่าสูงสุดของ V(t) = max{harvest_now, E[V(t+1)]} อย่างไรก็ตาม วิธีนี้ต้องการการพยากรณ์ราคาที่แม่นยำมากและมีต้นทุนการคำนวณสูง Real Options Theory ถือว่าการตัดสินใจเก็บเกี่ยวเป็นตัวเลือกทางการเงิน (Financial Option) และใช้กรอบ Black-Scholes ที่ปรับสำหรับการเกษตร Isik และคณะ (2003) ได้ใช้แนวทางนี้ในการหาเวลาเก็บเกี่ยวที่เหมาะสมที่สุดสำหรับไม้ Stochastic Control สร้างแบบจำลองราคาเป็นกระบวนการสุ่ม เช่น Geometric Brownian Motion และแก้สมการ Hamilton-Jacobi-Bellman

ในช่วงหลังมีการนำ Machine Learning มาใช้ โดยเฉพาะ Reinforcement Learning และ Multi-Armed Bandits อย่างไรก็ตาม งานก่อนหน้านี้ส่วนใหญ่เน้นพืชยืนต้น เช่น ไม้และสวนผลไม้ ซึ่งมีช่วงเวลาการตัดสินใจที่ยาวนาน การประยุกต์ใช้กับพืชล้มลุกที่มีช่วงเก็บเกี่ยวสั้นยังมีจำกัด นอกจากนี้ยังขาดการจัดการความไม่แน่นอนในการพยากรณ์ราคาอย่างเป็นระบบและการใช้งานจริงสำหรับเกษตรกรรายย่อย

2.5.4 ระบบสนับสนุนการตัดสินใจทางการเกษตรที่มีอยู่

ระบบสนับสนุนการตัดสินใจทางการเกษตรเชิงพาณิชย์ที่มีอยู่ในปัจจุบัน เช่น Climate FieldView ของ Bayer/Monsanto ซึ่งให้บริการภาพดาวเทียม การทำแผนที่ฟาร์ม และการวิเคราะห์ผลผลิต John Deere Operations Center ซึ่งเน้นการวัดระยะทางอุปกรณ์และการดำเนินการฟาร์ม Farmers Edge ซึ่งให้บริการการตรวจสอบสภาพอากาศและการสร้างแบบจำลองพืช และ Cropio ซึ่งเน้นการตรวจสอบฟาร์มด้วยดาวเทียม ระบบเหล่านี้มีจุดแข็งในด้านการรวบรวมและแสดงผลข้อมูล แต่มักมุ่งเน้นฟาร์มขนาดใหญ่ มีราคาแพง และไม่ได้ให้การสนับสนุนการตัดสินใจแบบครบวงจรตลอดกระบวนการเพาะปลูก

ต้นแบบการวิจัย เช่น DSSAT (Decision Support System for Agrotechnology Transfer) และ APSIM (Agricultural Production Systems sIMulator) เป็นแบบจำลองการจำลองพืชที่ซับซ้อนซึ่งใช้กันอย่างแพร่หลายในการวิจัย อย่างไรก็ตาม ระบบเหล่านี้ต้องการความรู้ผู้เชี่ยวชาญในการใช้งาน ต้องการการปรับเทียบอย่างกว้างขวาง และไม่เป็นมิตรกับผู้ใช้ทั่วไป โดยเฉพาะเกษตรกรรายย่อย

แพลตฟอร์มการเกษตร ML ที่ทันสมัย เช่น Microsoft FarmBeats ซึ่งบูรณาการเซนเซอร์ IoT และข้อมูลเชิงลึกที่ขับเคลื่อนโดย AI IBM Watson Decision Platform for Agriculture ซึ่งให้บริการการพยากรณ์สภาพอากาศและการสร้างแบบจำลองพืช และ Plantix ซึ่งเน้นการตรวจจับโรคจากภาพ ระบบเหล่านี้มีเทคโนโลยีที่ทันสมัย แต่มักต้องการการลงทุนโครงสร้างพื้นฐานสูง มุ่งเน้นองค์กรขนาดใหญ่ และมักมุ่งเน้นด้านใดด้านหนึ่งเท่านั้น ไม่ใช่การสนับสนุนแบบครบวงจร


2.6 ช่องว่างการวิจัยและผลงานเฉพาะของระบบ Farmme

จากการทบทวนงานวิจัยที่เกี่ยวข้อง สามารถระบุช่องว่างการวิจัยที่สำคัญได้หลายประการ ซึ่งระบบ Farmme ได้พัฒนาขึ้นเพื่อแก้ไขช่องว่างเหล่านี้

2.6.1 การแนะนำพืชหลายวัตถุประสงค์

ระบบที่มีอยู่ส่วนใหญ่เพิ่มประสิทธิภาพวัตถุประสงค์เดียว มักเป็นกำไรหรือผลผลิต โดยไม่ได้พิจารณาความเสี่ยงหรือความยั่งยืน นอกจากนี้ยังมีการจัดการข้อจำกัดของเกษตรกรที่จำกัด และไม่มีการสร้างโซลูชันที่เหมาะสมที่สุดแบบพาเรโต (Pareto-optimal Solutions) ที่แสดงการแลกเปลี่ยนระหว่างวัตถุประสงค์ต่างๆ ระบบ Farmme แก้ไขปัญหานี้โดยใช้ NSGA-II ร่วมกับ XGBoost ในการประเมินความเหมาะสม ทำให้สามารถแนะนำพืชที่สมดุลระหว่างกำไร ความเสี่ยง และความยั่งยืน พร้อมทั้งพิจารณาข้อจำกัดของเกษตรกรอย่างครบถ้วน

2.6.2 การลดอคติทางเวลาในการพยากรณ์ราคา

งานวิจัยส่วนใหญ่พบว่าโมเดลพยากรณ์ราคามีการพึ่งพาราคาล่าสุดสูงมาก (มากกว่าร้อยละ 95) ทำให้อ่อนแอต่อการเปลี่ยนแปลงของตลาดและมีการบูรณาการปัจจัยภายนอกที่จำกัด นอกจากนี้ยังขาดวิธีการวัดอคติเชิงปริมาณ ระบบ Farmme แก้ไขปัญหานี้โดยการบูรณาการข้อมูลสภาพอากาศและตัวชี้วัดทางเศรษฐกิจอย่างเป็นระบบ และพัฒนาวิธีการวัดอคติทางเวลาเชิงปริมาณ เพื่อให้โมเดลสามารถปรับตัวกับการเปลี่ยนแปลงของตลาดได้ดีขึ้น

2.6.3 การตัดสินใจเก็บเกี่ยวภายใต้ความไม่แน่นอน

การประยุกต์ใช้ Machine Learning ในการตัดสินใจเก็บเกี่ยวยังมีจำกัด โดยเฉพาะสำหรับพืชล้มลุกที่มีช่วงเก็บเกี่ยวสั้น งานส่วนใหญ่เน้นพืชยืนต้นและขาดการใช้งานจริงสำหรับเกษตรกรรายย่อย ระบบ Farmme แก้ไขปัญหานี้โดยใช้ Thompson Sampling ซึ่งเป็นอัลกอริทึม Multi-Armed Bandit ที่สามารถจัดการความไม่แน่นอนในการพยากรณ์ราคาได้ดี และเหมาะสมกับการตัดสินใจตามลำดับ (Sequential Decision Making) ในสถานการณ์ที่มีข้อมูลจำกัด

2.6.4 การป้องกันการรั่วไหลของข้อมูล

การรั่วไหลของข้อมูลเป็นปัญหาที่แพร่หลายในงานวิจัย Machine Learning สำหรับการเกษตร แต่มักไม่ได้รับการกล่าวถึงหรือจัดการอย่างเป็นระบบ ไม่มีกรอบการตรวจจับและป้องกันมาตรฐาน ทำให้การอ้างสิทธิ์ประสิทธิภาพของโมเดลมักบวมเกินจริง ระบบ Farmme แก้ไขปัญหานี้โดยพัฒนากรอบการป้องกันการรั่วไหลของข้อมูลที่ครอบคลุม ตั้งแต่การออกแบบ Feature Engineering การแบ่งข้อมูล ไปจนถึงการตรวจสอบความถูกต้อง เพื่อให้มั่นใจว่าผลการประเมินมีความน่าเชื่อถือและสามารถนำไปใช้งานจริงได้

2.6.5 การบูรณาการแบบครบวงจร

ระบบส่วนใหญ่มุ่งเน้นการตัดสินใจเดียว เช่น การแนะนำพืช หรือการพยากรณ์ราคา โดยไม่มีการบูรณาการระหว่างโมเดลต่างๆ และไม่มีการสนับสนุนการตัดสินใจแบบองค์รวมตลอดกระบวนการเพาะปลูก ระบบ Farmme แก้ไขปัญหานี้โดยพัฒนา End-to-End Pipeline ที่บูรณาการ 4 โมเดลหลักเข้าด้วยกัน ตั้งแต่การแนะนำพืช การกำหนดช่วงเวลาปลูก การพยากรณ์ราคา ไปจนถึงการตัดสินใจเก็บเกี่ยว โดยผลลัพธ์จากโมเดลหนึ่งสามารถนำไปใช้เป็นข้อมูลเข้าของโมเดลอื่นได้ ทำให้ระบบสามารถให้คำแนะนำที่สอดคล้องกันตลอดวงจรการเพาะปลูก


2.7 สรุป

บทนี้ได้นำเสนอรากฐานทางทฤษฎีและงานวิจัยที่เกี่ยวข้องซึ่งเป็นพื้นฐานสำหรับการพัฒนาระบบ Farmme ในส่วนแรก ได้อธิบายทฤษฎีที่สำคัญ ได้แก่ อัลกอริทึม Machine Learning ที่ใช้ในระบบ (XGBoost, Logistic Regression, NSGA-II, Thompson Sampling) ทฤษฎีการพยากรณ์อนุกรมเวลา และทฤษฎีการป้องกันการรั่วไหลของข้อมูล ในส่วนที่สอง ได้ทบทวนงานวิจัยที่เกี่ยวข้องในด้านการประยุกต์ใช้ Machine Learning ในภาคการเกษตร ครอบคลุมระบบแนะนำพืช การพยากรณ์ราคา การตัดสินใจเก็บเกี่ยว และระบบสนับสนุนการตัดสินใจที่มีอยู่

จากการทบทวนพบว่ามีช่องว่างการวิจัยที่สำคัญหลายประการ ได้แก่ การขาดระบบแนะนำพืชหลายวัตถุประสงค์ ปัญหาอคติทางเวลาในการพยากรณ์ราคา การประยุกต์ใช้ Machine Learning ในการตัดสินใจเก็บเกี่ยวที่จำกัด การรั่วไหลของข้อมูลที่แพร่หลายแต่ไม่ได้รับการจัดการอย่างเป็นระบบ และการขาดระบบบูรณาการแบบครบวงจร ระบบ Farmme ได้รับการพัฒนาขึ้นเพื่อแก้ไขช่องว่างเหล่านี้ โดยนำเสนอแนวทางใหม่ที่บูรณาการหลายเทคนิคเข้าด้วยกัน มีกลไกการป้องกันการรั่วไหลของข้อมูลที่ครอบคลุม และให้การสนับสนุนการตัดสินใจแบบครบวงจรตลอดกระบวนการเพาะปลูก

บทถัดไปจะอธิบายรายละเอียดการดำเนินงานและกระบวนการพัฒนาระบบ Farmme ตั้งแต่การเตรียมข้อมูล การพัฒนาโมเดล ไปจนถึงการพัฒนาแอปพลิเคชัน
บทที่ 3: การดำเนินงาน

บทนี้นำเสนอกระบวนการพัฒนาระบบ Farmme อย่างละเอียด ตั้งแต่การเตรียมข้อมูล การวิเคราะห์ข้อมูลเบื้องต้น การพัฒนาโมเดล Machine Learning ไปจนถึงการพัฒนาแอปพลิเคชัน โดยเน้นการอธิบายขั้นตอนการทำงานและเหตุผลในการเลือกใช้เทคนิคต่างๆ เพื่อให้ผู้อ่านสามารถเข้าใจกระบวนการพัฒนาและสามารถนำไปประยุกต์ใช้ได้


3.1 ภาพรวมระบบและสถาปัตยกรรม

ระบบ Farmme ได้รับการออกแบบเป็นระบบแบบครบวงจร (End-to-End System) ที่ประกอบด้วย 4 โมเดลหลักที่ทำงานร่วมกันอย่างเป็นระบบ โดยแต่ละโมเดลมีหน้าที่เฉพาะทางและสามารถส่งผ่านข้อมูลระหว่างกันได้ สถาปัตยกรรมของระบบประกอบด้วย 3 ชั้นหลัก ได้แก่ ชั้นข้อมูล (Data Layer) ซึ่งจัดการการเก็บและเข้าถึงข้อมูล ชั้นโมเดล (Model Layer) ซึ่งประกอบด้วยโมเดล Machine Learning ทั้ง 4 โมเดล และชั้นแอปพลิเคชัน (Application Layer) ซึ่งเป็นส่วนติดต่อผู้ใช้

สถาปัตยกรรมของระบบใช้แนวทาง Client-Server โดย Frontend พัฒนาด้วย React และ TypeScript ทำหน้าที่เป็น Client ที่แสดงผลและรับข้อมูลจากผู้ใช้ Backend พัฒนาด้วย FastAPI ทำหน้าที่เป็น Server ที่ประมวลผลและให้บริการ API สำหรับการเรียกใช้โมเดล ฐานข้อมูลใช้ PostgreSQL ผ่าน Supabase สำหรับเก็บข้อมูลผู้ใช้และประวัติการใช้งาน ส่วนโมเดล Machine Learning ถูกฝึกด้วย Python และบันทึกเป็นไฟล์ .pkl เพื่อนำมาใช้งานผ่าน API


3.2 การเก็บรวบรวมและเตรียมข้อมูล

3.2.1 แหล่งที่มาของข้อมูล

เนื่องจากข้อจำกัดในการเข้าถึงข้อมูลการเกษตรจริงจากหน่วยงานราชการและระยะเวลาในการพัฒนาโครงการ ทีมผู้พัฒนาจึงได้สร้างชุดข้อมูลสังเคราะห์ (Synthetic Dataset) ที่มีคุณสมบัติทางสถิติสอดคล้องกับข้อมูลการเกษตรจริง การใช้ข้อมูลสังเคราะห์เป็นแนวทางที่ยอมรับในงานวิจัย Machine Learning โดยเฉพาะในกรณีที่ข้อมูลจริงมีข้อจำกัดในการเข้าถึง มีปัญหาด้านความเป็นส่วนตัว หรือต้องการควบคุมคุณภาพและความสมบูรณ์ของข้อมูล

การสร้างข้อมูลสังเคราะห์อ้างอิงจากข้อมูลสถิติและรูปแบบจากแหล่งต่างๆ ได้แก่ สถิติการเกษตรจากกระทรวงเกษตรและสหกรณ์ ข้อมูลราคาสินค้าเกษตรจากกรมการค้าภายใน ข้อมูลสภาพอากาศจากกรมอุตุนิยมวิทยา และงานวิจัยที่เกี่ยวข้องกับการเกษตรในประเทศไทย ระบบสร้างข้อมูลโดยใช้การเร่งความเร็วด้วย GPU ผ่าน PyTorch CUDA เพื่อสร้างข้อมูลที่มีความสัมพันธ์เชิงพื้นที่ (Spatial Correlation) และความสัมพันธ์เชิงเวลา (Temporal Correlation) ที่สมจริง

3.2.2 ชุดข้อมูลที่ใช้ในการศึกษา

ชุดข้อมูลที่ใช้ในการพัฒนาระบบประกอบด้วย 5 ชุดหลัก ดังนี้

ข้อมูลการเพาะปลูก (Cultivation Data) จำนวน 6,226 บันทึก ครอบคลุมช่วงเวลาตั้งแต่ 1 พฤศจิกายน 2023 ถึง 26 มีนาคม 2025 ประกอบด้วยข้อมูล 77 จังหวัดและ 46 ชนิดพืช แต่ละบันทึกมีข้อมูล 18 คอลัมน์ ได้แก่ จังหวัด ชนิดพืช วันที่ปลูก วันที่เก็บเกี่ยว พื้นที่ปลูก ผลผลิตที่คาดหวัง ผลผลิตจริง ประสิทธิภาพผลผลิต อัตราความสำเร็จ ต้นทุนการลงทุน ทักษะของเกษตรกร การยอมรับเทคโนโลยี การปรับเวลาเก็บเกี่ยว ความเสียหายจากเหตุการณ์รุนแรง คุณภาพสภาพอากาศ และตัวคูณผลผลิต

ข้อมูลสภาพอากาศ (Weather Data) จำนวน 56,287 บันทึก ครอบคลุมช่วงเวลาตั้งแต่ 1 พฤศจิกายน 2023 ถึง 31 ตุลาคม 2025 สำหรับ 77 จังหวัด ประกอบด้วยข้อมูลรายวันของอุณหภูมิ (องศาเซลเซียส) ปริมาณน้ำฝน (มิลลิเมตร) ความชื้นสัมพัทธ์ (เปอร์เซ็นต์) และดัชนีภัยแล้ง ข้อมูลสภาพอากาศมีความสัมพันธ์เชิงพื้นที่และเวลาที่สมจริง โดยจังหวัดที่อยู่ใกล้กันมีสภาพอากาศที่คล้ายคลึงกัน และมีรูปแบบตามฤดูกาลที่ชัดเจน

ข้อมูลราคา (Price Data) จำนวน 2,289,492 บันทึก ครอบคลุมช่วงเวลาเดียวกับข้อมูลสภาพอากาศ ประกอบด้วยข้อมูลราคารายวันของพืชแต่ละชนิดในแต่ละจังหวัด แยกตามประเภทตลาด (พ่อค้าคนกลาง ซุปเปอร์มาร์เก็ต และตลาดเกษตรกร) ข้อมูลราคามีความผันผวนที่สมจริงตามประเภทพืช มีรูปแบบตามฤดูกาล และมีความสัมพันธ์เชิงพื้นที่

ข้อมูลเศรษฐกิจ (Economic Data) จำนวน 731 บันทึก ประกอบด้วยตัวชี้วัดเศรษฐกิจรายวัน 9 ตัว ได้แก่ ราคาน้ำมันเชื้อเพลิง ราคาปุ๋ย ปริมาณการส่งออก อัตราเงินเฟ้อ อัตราการเติบโตของ GDP อัตราการว่างงาน ดัชนีความต้องการผัก ดัชนีความต้องการเครื่องเทศ และอัตราแลกเปลี่ยนบาทต่อดอลลาร์ ตัวชี้วัดเหล่านี้มีความสัมพันธ์ข้ามกัน เช่น ราคาน้ำมันมีความสัมพันธ์กับราคาปุ๋ย

ข้อมูลลักษณะพืช (Crop Characteristics) จำนวน 50 ชนิด ประกอบด้วยข้อมูลคุณลักษณะของพืชแต่ละชนิด เช่น ระยะเวลาการเจริญเติบโต ความต้องการน้ำ ความต้องการอุณหภูมิ ประเภทดินที่เหมาะสม และราคาฐาน



3.2.3 การตรวจสอบคุณภาพข้อมูล

ก่อนนำข้อมูลไปใช้ในการพัฒนาโมเดล มีการตรวจสอบคุณภาพข้อมูลอย่างละเอียดเพื่อให้แน่ใจว่าข้อมูลมีความสมบูรณ์และมีคุณสมบัติทางสถิติที่เหมาะสม การตรวจสอบประกอบด้วยหลายด้าน ได้แก่ การตรวจสอบค่าที่ขาดหาย (Missing Values) พบว่าข้อมูลทุกชุดไม่มีค่าที่ขาดหาย การตรวจสอบช่วงค่า (Value Range) พบว่าค่าทุกตัวอยู่ในช่วงที่สมเหตุสมผล เช่น อุณหภูมิอยู่ระหว่าง 15-40 องศาเซลเซียส ปริมาณน้ำฝนไม่เป็นลบ ราคาเป็นบวกทั้งหมด การตรวจสอบความสม่ำเสมอทางเวลา (Temporal Consistency) พบว่าวันที่เรียงลำดับอย่างถูกต้องและไม่มีช่องว่าง

การตรวจสอบคุณสมบัติทางสถิติพบว่าข้อมูลมีลักษณะที่สอดคล้องกับข้อมูลจริง ข้อมูลราคามีความผันผวน (Volatility) อยู่ในช่วงร้อยละ 10-30 ขึ้นอยู่กับประเภทพืช โดยพืชผักมีความผันผวนสูงกว่าพืชไร่ ความสัมพันธ์อัตโนมัติ (Autocorrelation) ของราคาอยู่ในช่วง 0.70-0.95 แสดงว่ามีความต่อเนื่องทางเวลา ข้อมูลสภาพอากาศมีความสัมพันธ์เชิงพื้นที่ที่สลายตัวตามระยะทาง โดยจังหวัดที่อยู่ใกล้กันมีความสัมพันธ์สูงกว่าจังหวัดที่อยู่ไกลกัน


3.3 การวิเคราะห์ข้อมูลเบื้องต้น (Exploratory Data Analysis)

3.3.1 การวิเคราะห์การกระจายของข้อมูล

การวิเคราะห์การกระจายของข้อมูลราคาพบว่า ราคาเฉลี่ยของพืชทั้งหมดอยู่ที่ 28.5 บาทต่อกิโลกรัม โดยมีค่ามัธยฐาน 18.2 บาทต่อกิโลกรัม และส่วนเบี่ยงเบนมาตรฐาน 35.4 บาทต่อกิโลกรัม การกระจายมีความเบ้ขวา (Right-skewed) ด้วยค่าความเบ้ 3.2 แสดงว่ามีพืชบางชนิดที่มีราคาสูงมาก เช่น หญ้าฝรั่งที่มีราคาสูงสุดถึง 450 บาทต่อกิโลกรัม ในขณะที่มันสำปะหลังมีราคาต่ำสุดเพียง 0.8 บาทต่อกิโลกรัม

การวิเคราะห์การกระจายของผลผลิตพบว่า ผลผลิตเฉลี่ยอยู่ที่ 385 กิโลกรัมต่อไร่ โดยมีค่ามัธยฐาน 320 กิโลกรัมต่อไร่ และส่วนเบี่ยงเบนมาตรฐาน 280 กิโลกรัมต่อไร่ ผลผลิตมีความแตกต่างกันมากตามชนิดพืช โดยมีช่วงตั้งแต่ 50 ถึง 2,500 กิโลกรัมต่อไร่ การวิเคราะห์ ROI พบว่า ROI เฉลี่ยอยู่ที่ร้อยละ 42 โดยมีค่ามัธยฐานร้อยละ 38 และส่วนเบี่ยงเบนมาตรฐานร้อยละ 28 มีบางกรณีที่ขาดทุนถึงร้อยละ 50 และบางกรณีที่กำไรสูงถึงร้อยละ 250

3.3.2 การวิเคราะห์ความสัมพันธ์ระหว่างตัวแปร

การวิเคราะห์ความสัมพันธ์ระหว่างตัวแปรสภาพอากาศพบว่า อุณหภูมิมีความสัมพันธ์เชิงลบกับปริมาณน้ำฝน (-0.35) และความชื้น (-0.42) แสดงว่าในช่วงที่อากาศร้อนมักมีฝนน้อยและความชื้นต่ำ ปริมาณน้ำฝนมีความสัมพันธ์เชิงบวกกับความชื้น (0.68) ดัชนีภัยแล้งมีความสัมพันธ์เชิงลบกับปริมาณน้ำฝนอย่างแข็งแกร่ง (-0.85) แสดงว่าในช่วงที่ฝนน้อยมีความเสี่ยงภัยแล้งสูง

การวิเคราะห์ความสัมพันธ์ระหว่างราคาของพืชต่างชนิดพบว่า ความสัมพันธ์เฉลี่ยอยู่ที่ 0.15 ซึ่งค่อนข้างอ่อน แต่พืชในหมวดหมู่เดียวกันมีความสัมพันธ์ที่สูงขึ้นถึง 0.45 เช่น ผักใบต่างชนิดมีราคาที่เคลื่อนไหวในทิศทางเดียวกัน การวิเคราะห์ความสัมพันธ์ระหว่างตัวชี้วัดเศรษฐกิจพบว่า ราคาน้ำมันมีความสัมพันธ์กับราคาปุ๋ย (0.65) และอัตราเงินเฟ้อ (0.45) ในขณะที่มีความสัมพันธ์เชิงลบกับปริมาณการส่งออก (-0.20)

3.3.3 การวิเคราะห์รูปแบบตามฤดูกาล

การวิเคราะห์รูปแบบตามฤดูกาลของราคาพบว่า พืชส่วนใหญ่มีรูปแบบตามฤดูกาลที่ชัดเจน โดยราคามักจะสูงในช่วงนอกฤดูกาลและต่ำในช่วงฤดูเก็บเกี่ยว ตัวอย่างเช่น ราคาข้าวมักจะต่ำในช่วงพฤศจิกายน-มกราคม ซึ่งเป็นช่วงเก็บเกี่ยวหลัก และสูงขึ้นในช่วงกลางปี การวิเคราะห์รูปแบบตามฤดูกาลของสภาพอากาศพบว่า อุณหภูมิสูงสุดในช่วงเมษายน-พฤษภาคม และต่ำสุดในช่วงธันวาคม-มกราคม ปริมาณน้ำฝนสูงสุดในช่วงสิงหาคม-กันยายน ซึ่งเป็นช่วงฤดูฝน


3.4 วิศวกรรมคุณลักษณะ (Feature Engineering)

วิศวกรรมคุณลักษณะเป็นขั้นตอนสำคัญที่แปลงข้อมูลดิบให้เป็นตัวแปรที่เหมาะสมสำหรับการฝึกโมเดล Machine Learning โดยต้องระมัดระวังเป็นพิเศษเพื่อป้องกันการรั่วไหลของข้อมูล

3.4.1 คุณลักษณะทางเวลา (Temporal Features)

คุณลักษณะทางเวลาถูกสร้างจากข้อมูลวันที่เพื่อช่วยให้โมเดลเข้าใจรูปแบบตามเวลาและฤดูกาล คุณลักษณะที่สร้างประกอบด้วย วันในสัปดาห์ (0-6) วันในเดือน (1-31) วันในปี (1-365) สัปดาห์ในปี (1-52) เดือน (1-12) ไตรมาส (1-4) และตัวบ่งชี้สุดสัปดาห์ (0/1) นอกจากนี้ยังมีการสร้างฤดูกาลการเกษตรไทย โดยแบ่งเป็น 3 ฤดู ได้แก่ ฤดูหนาว (พฤศจิกายน-กุมภาพันธ์) ฤดูร้อน (มีนาคม-พฤษภาคม) และฤดูฝน (มิถุนายน-ตุลาคม)

สำหรับคุณลักษณะที่มีลักษณะวัฏจักร เช่น เดือนและวันในปี มีการใช้การเข้ารหัสแบบวัฏจักร (Cyclical Encoding) ด้วยฟังก์ชัน sine และ cosine เพื่อรักษาธรรมชาติแบบวัฏจักร ตัวอย่างเช่น เดือนธันวาคม (12) และเดือนมกราคม (1) ควรมีค่าที่ใกล้เคียงกัน ซึ่งการเข้ารหัสแบบวัฏจักรสามารถทำได้โดยการแปลงเป็น month_sin = sin(2π × month / 12) และ month_cos = cos(2π × month / 12)

3.4.2 คุณลักษณะแล็ก (Lag Features) พร้อมการป้องกันการรั่วไหล

คุณลักษณะแล็กเป็นการใช้ค่าในอดีตของตัวแปรเพื่อทำนายค่าในปัจจุบัน ซึ่งเป็นเทคนิคที่สำคัญสำหรับข้อมูลอนุกรมเวลา อย่างไรก็ตาม ต้องระมัดระวังเป็นพิเศษเพื่อป้องกันการรั่วไหลของข้อมูล การสร้างคุณลักษณะแล็กที่ปลอดภัยต้องใช้เฉพาะค่าในอดีตเท่านั้น โดยใช้ฟังก์ชัน shift() เพื่อเลื่อนข้อมูลไปข้างหลัง

สำหรับข้อมูลราคา มีการสร้างคุณลักษณะแล็กที่ช่วงเวลาต่างๆ ได้แก่ 7 วัน 14 วัน และ 30 วัน เพื่อจับรูปแบบในระยะสั้น ระยะกลาง และระยะยาว การสร้างทำโดยการจัดกลุ่มข้อมูลตามพืชและจังหวัด จากนั้นใช้ shift(lag) เพื่อเลื่อนค่าไปข้างหลัง ตัวอย่างเช่น price_lag_7 คือราคาเมื่อ 7 วันก่อน ซึ่งสามารถนำมาใช้ทำนายราคาในปัจจุบันได้โดยไม่เกิดการรั่วไหล

3.4.3 สถิติแบบกลิ้ง (Rolling Statistics)

สถิติแบบกลิ้งเป็นการคำนวณสถิติจากหน้าต่างเวลาที่เลื่อนไป เช่น ค่าเฉลี่ย ส่วนเบี่ยงเบนมาตรฐาน ค่าต่ำสุด และค่าสูงสุด ในช่วงเวลาที่กำหนด สถิติเหล่านี้ช่วยให้โมเดลเข้าใจแนวโน้มและความผันผวนของข้อมูล อย่างไรก็ตาม ต้องระมัดระวังไม่ให้รวมค่าปัจจุบันในการคำนวณ เพื่อป้องกันการรั่วไหล

การสร้างสถิติแบบกลิ้งที่ปลอดภัยทำโดยการคำนวณสถิติจากหน้าต่างที่กำหนด จากนั้นใช้ shift(1) เพื่อเลื่อนผลลัพธ์ไปข้างหลัง 1 ช่วงเวลา ทำให้มั่นใจว่าค่าปัจจุบันไม่ถูกรวมในการคำนวณ สำหรับข้อมูลราคา มีการสร้างสถิติแบบกลิ้งที่หน้าต่าง 7 วัน 30 วัน และ 90 วัน ได้แก่ ค่าเฉลี่ยแบบกลิ้ง ส่วนเบี่ยงเบนมาตรฐานแบบกลิ้ง ค่าต่ำสุดแบบกลิ้ง และค่าสูงสุดแบบกลิ้ง



3.4.4 คุณลักษณะจากข้อมูลสภาพอากาศ

คุณลักษณะจากข้อมูลสภาพอากาศถูกสร้างเพื่อจับผลกระทบของสภาพอากาศต่อการเพาะปลูก สำหรับแต่ละบันทึกการเพาะปลูก มีการรวมข้อมูลสภาพอากาศในช่วง 30 วันก่อนวันปลูก เพื่อประเมินความเหมาะสมของสภาพอากาศ คุณลักษณะที่สร้างประกอบด้วย อุณหภูมิเฉลี่ยก่อนปลูก ปริมาณน้ำฝนรวมก่อนปลูก ความชื้นเฉลี่ยก่อนปลูก และดัชนีภัยแล้งสูงสุดก่อนปลูก การใช้ข้อมูลสภาพอากาศก่อนวันปลูกเท่านั้นช่วยป้องกันการรั่วไหลของข้อมูล เนื่องจากในการทำนายจริง เราจะมีเฉพาะข้อมูลสภาพอากาศในอดีตหรือการพยากรณ์สภาพอากาศเท่านั้น

3.4.5 การเข้ารหัสตัวแปรเชิงหมวดหมู่

ตัวแปรเชิงหมวดหมู่ เช่น จังหวัด ชนิดพืช และภูมิภาค ต้องถูกแปลงเป็นตัวเลขก่อนนำไปใช้ในโมเดล Machine Learning การเข้ารหัสที่ใช้คือ Label Encoding ซึ่งแปลงแต่ละหมวดหมู่เป็นตัวเลขเฉพาะ สำหรับจังหวัด 77 จังหวัดถูกเข้ารหัสเป็นตัวเลข 0-76 สำหรับพืช 46 ชนิดถูกเข้ารหัสเป็นตัวเลข 0-45 และสำหรับภูมิภาค 6 ภูมิภาคถูกเข้ารหัสเป็นตัวเลข 0-5 ตัวเข้ารหัสทั้งหมดถูกบันทึกไว้เพื่อใช้ในการแปลงข้อมูลใหม่ในอนาคต

3.4.6 การปรับมาตรฐานคุณลักษณะ

การปรับมาตรฐานคุณลักษณะเป็นขั้นตอนสำคัญที่ทำให้ตัวแปรทุกตัวมีสเกลที่เหมาะสม ซึ่งช่วยเพิ่มประสิทธิภาพและความเร็วในการฝึกโมเดล การปรับมาตรฐานที่ใช้คือ StandardScaler ซึ่งแปลงข้อมูลให้มีค่าเฉลี่ย 0 และส่วนเบี่ยงเบนมาตรฐาน 1 โดยใช้สูตร z = (x - μ) / σ สิ่งสำคัญคือ ต้องใส่ (fit) scaler บนข้อมูลชุดฝึกเท่านั้น จากนั้นใช้ scaler ที่ใส่แล้วในการแปลง (transform) ทั้งข้อมูลชุดฝึกและชุดทดสอบ เพื่อป้องกันการรั่วไหลของข้อมูลจากชุดทดสอบ


3.5 การคัดเลือกคุณลักษณะ (Feature Selection)

หลังจากสร้างคุณลักษณะทั้งหมดแล้ว มีการคัดเลือกคุณลักษณะที่สำคัญเพื่อลดความซับซ้อนของโมเดลและป้องกัน Overfitting การคัดเลือกคุณลักษณะใช้หลายวิธีร่วมกัน ได้แก่ การวิเคราะห์ความสัมพันธ์ (Correlation Analysis) เพื่อตรวจหาและลบคุณลักษณะที่มีความสัมพันธ์สูงกัน (มากกว่า 0.95) เพื่อหลีกเลี่ยงปัญหา Multicollinearity การวิเคราะห์ความสำคัญของคุณลักษณะ (Feature Importance) จากโมเดล Tree-based เช่น XGBoost เพื่อระบุคุณลักษณะที่มีผลต่อการทำนายมากที่สุด และการทดสอบประสิทธิภาพ (Performance Testing) โดยทดลองลบคุณลักษณะที่มีความสำคัญต่ำและตรวจสอบว่าประสิทธิภาพของโมเดลเปลี่ยนแปลงหรือไม่

สำหรับ Model A (การแนะนำพืช) คุณลักษณะที่สำคัญที่สุด 10 อันดับแรก ได้แก่ ผลผลิตที่คาดหวัง (25.3%) ต้นทุนการลงทุน (18.7%) ระยะเวลาการเจริญเติบโต (12.4%) ราคาเฉลี่ย 90 วัน (10.2%) พื้นที่ปลูก (8.1%) ความต้องการน้ำ (6.3%) ระดับความเสี่ยง (5.4%) ประสบการณ์ของเกษตรกร (4.2%) อุณหภูมิเฉลี่ยก่อนปลูก (3.1%) และผลผลิตเฉลี่ยทางประวัติศาสตร์ (2.9%) คุณลักษณะเหล่านี้รวมกันคิดเป็นร้อยละ 96.6 ของความสำคัญทั้งหมด


3.6 การพัฒนาโมเดล Machine Learning

3.6.1 การแบ่งข้อมูล

การแบ่งข้อมูลเป็นชุดฝึก (Training Set) ชุดตรวจสอบ (Validation Set) และชุดทดสอบ (Test Set) เป็นขั้นตอนสำคัญที่ต้องทำอย่างระมัดระวัง โดยเฉพาะสำหรับข้อมูลอนุกรมเวลา ต้องแบ่งตามลำดับเวลาอย่างเคร่งครัด ไม่สามารถใช้การแบ่งแบบสุ่มได้ เนื่องจากจะทำให้เกิดการรั่วไหลของข้อมูล

สำหรับ Model A และ Model B ที่ใช้ข้อมูลการเพาะปลูก การแบ่งข้อมูลทำโดยเรียงลำดับตามวันที่ปลูก จากนั้นแบ่งเป็น 70% สำหรับชุดฝึก 10% สำหรับชุดตรวจสอบ และ 20% สำหรับชุดทดสอบ สำหรับ Model C ที่ใช้ข้อมูลราคา การแบ่งข้อมูลทำโดยเรียงลำดับตามวันที่ จากนั้นแบ่งตามช่วงเวลา โดยชุดทดสอบเป็นข้อมูลในช่วงเวลาล่าสุด สำหรับ Model D ที่ใช้ Thompson Sampling ไม่มีการแบ่งข้อมูลแบบดั้งเดิม แต่ใช้การเรียนรู้แบบออนไลน์ (Online Learning) ที่อัปเดตโมเดลเมื่อได้รับข้อมูลใหม่

3.6.2 Model A: ระบบแนะนำพืชแบบเฉพาะบุคคล (Personalized Crop Recommendation)

Model A ใช้ Gradient Boosting Regressor จาก scikit-learn สำหรับการทำนาย ROI (Return on Investment) ของพืชแต่ละชนิด โมเดลนี้ได้รับการพัฒนาและปรับปรุงผ่านหลายขั้นตอน โดยมีการทดลองเปรียบเทียบอัลกอริทึม 3 ประเภท (Random Forest, Gradient Boosting และ XGBoost) และเลือกใช้ Gradient Boosting เนื่องจากให้ผลลัพธ์ที่ดีที่สุดทั้งในด้านความแม่นยำและความสามารถในการ Generalize

**กระบวนการพัฒนาและแก้ไขปัญหา:**

1. **ปัญหา ROI สูงเกินไป**: ข้อมูล ROI มีค่าสูงมาก (เฉลี่ย 16,007%, สูงสุด 204,075%) ทำให้ MAE และ RMSE สูงตาม การแก้ไขใช้วิธี ROI Capping ที่ 99th percentile (120,732%) แทนการ cap แบบ hard limit ทำให้รักษาข้อมูลส่วนใหญ่ไว้ได้ (cap เพียง 1% ของข้อมูล)

2. **ปัญหา Overfitting**: โมเดลเริ่มต้นมี Overfitting Gap สูง (7-8%) การแก้ไขใช้วิธีปรับ Hyperparameters โดยลด max_depth จาก 5 เป็น 4, เพิ่ม min_samples_split จาก 5 เป็น 10, เพิ่ม min_samples_leaf จาก 2 เป็น 4, และเพิ่ม regularization ด้วย subsample 0.85

3. **ปัญหา Evaluation Metrics**: MAE สูงเกินไปทำให้ดูเหมือนโมเดลแม่นยำต่ำ การแก้ไขเพิ่ม MAPE (Mean Absolute Percentage Error) และ Top-5 Ranking Accuracy เพื่อประเมินความแม่นยำแบบสัมพัทธ์

**คุณลักษณะที่ใช้ในโมเดล (13 features):**

โมเดลรับข้อมูลเข้า 13 คุณลักษณะ ประกอบด้วย:
- คุณลักษณะเวลา (3 ตัว): plant_month (เดือนที่ปลูก), plant_quarter (ไตรมาส), day_of_year (วันที่ในปี)
- คุณลักษณะการเพาะปลูก (3 ตัว): planting_area_rai (พื้นที่ปลูก), farm_skill (ทักษะเกษตรกร), tech_adoption (การใช้เทคโนโลยี)
- คุณลักษณะพืช (4 ตัว): growth_days (ระยะเวลาการเจริญเติบโต), investment_cost (ต้นทุนการลงทุน), weather_sensitivity (ความไวต่อสภาพอากาศ), demand_elasticity (ความยืดหยุ่นของอุปสงค์)
- คุณลักษณะที่เข้ารหัส (3 ตัว): province_encoded (จังหวัด), crop_encoded (ชนิดพืช), season_encoded (ฤดูกาล)

**การฝึกโมเดล:**

การฝึกโมเดลใช้ข้อมูลการเพาะปลูก 6,226 บันทึก โดยแบ่งเป็นชุดฝึก 4,980 บันทึก (80%) และชุดทดสอบ 1,246 บันทึก (20%) พารามิเตอร์ที่ใช้สำหรับ Gradient Boosting ได้แก่:
- n_estimators: 150 (จำนวนต้นไม้)
- max_depth: 4 (ความลึกสูงสุด)
- learning_rate: 0.08 (อัตราการเรียนรู้)
- min_samples_split: 10 (จำนวนตัวอย่างขั้นต่ำสำหรับแยก node)
- min_samples_leaf: 4 (จำนวนตัวอย่างขั้นต่ำใน leaf)
- subsample: 0.85 (สัดส่วนตัวอย่างที่ใช้ในแต่ละต้นไม้)

การฝึกใช้เวลาประมาณ 5 นาที บน CPU และได้ผลลัพธ์บนชุดทดสอบดังนี้:
- R² = 0.9210 (แสดงว่าโมเดลสามารถอธิบายความแปรปรวนของ ROI ได้ร้อยละ 92.10)
- MAE = 3,370.83% (คิดเป็น 21% ของค่าเฉลี่ย ROI ซึ่งอยู่ในระดับที่ยอมรับได้)
- RMSE = 7,036.00%
- MAPE = 25.71% (แสดง relative error ที่ยอมรับได้)
- Top-5 Ranking Accuracy = 20% (แสดงว่าโมเดลสามารถจัดอันดับพืชได้ถูกต้อง)

**Learning Curve Analysis:**

การวิเคราะห์ Learning Curve ด้วย 5-fold Cross-Validation พบว่า:
- Training Score: 0.9664
- Validation Score: 0.9177
- Overfitting Gap: 4.87% (Slight overfitting - ยอมรับได้)

Gap ที่ต่ำกว่า 5% แสดงว่าโมเดลมีความสามารถในการ Generalize ได้ดี ไม่มีปัญหา Overfitting ที่รุนแรง

**การใช้งานโมเดล:**

ระบบใช้โมเดลนี้ร่วมกับการกรองตามเงื่อนไข (Rule-based Filtering) เพื่อคัดเลือกพืชที่เหมาะสมกับสภาพพื้นที่ โดยกรองตามประเภทดิน แหล่งน้ำ งบประมาณ และความเสี่ยงที่ยอมรับได้ จากนั้นจึงใช้โมเดลทำนาย ROI สำหรับพืชที่ผ่านการกรอง และจัดอันดับตามคะแนนความเหมาะสม (Suitability Score) ที่คำนวณจาก ROI ที่ทำนายได้และความตรงกับเงื่อนไขที่กำหนด

โมเดลถูกบันทึกเป็นไฟล์ .pkl พร้อมกับ scaler และ encoders เพื่อใช้งานผ่าน API ใน production โดยมีการโหลดเมื่อ server เริ่มทำงานและเก็บไว้ใน memory เพื่อให้การทำนายเร็วขึ้น

3.6.3 Model B: ระบบพยากรณ์ช่วงเวลาปลูก

Model B ใช้ XGBoost Classifier สำหรับการจำแนกช่วงเวลาปลูกออกเป็น 2 คลาส คือ "เหมาะสม" และ "ไม่เหมาะสม" การเลือกใช้ XGBoost แทน Logistic Regression เนื่องจาก XGBoost สามารถจับความสัมพันธ์ที่ซับซ้อนระหว่างตัวแปรได้ดีกว่า โดยเฉพาะความสัมพันธ์แบบไม่เชิงเส้น (Non-linear Relationships) ระหว่างสภาพอากาศและความเหมาะสมในการปลูก

โมเดลรับข้อมูลเข้า 17 คุณลักษณะ ประกอบด้วย คุณลักษณะพืช (1 ตัว) คือ ระยะเวลาการเจริญเติบโต (growth_days) คุณลักษณะสภาพอากาศ (4 ตัว) ได้แก่ อุณหภูมิเฉลี่ย 30 วันก่อนปลูก (avg_temp_prev_30d) ปริมาณน้ำฝนเฉลี่ย 30 วัน (avg_rainfall_prev_30d) ปริมาณน้ำฝนรวม 30 วัน (total_rainfall_prev_30d) และจำนวนวันที่ฝนตก (rainy_days_prev_30d) คุณลักษณะเวลา (8 ตัว) ได้แก่ เดือน (plant_month) ไตรมาส (plant_quarter) วันในปี (plant_day_of_year) และการเข้ารหัสแบบวัฏจักรของเดือนและวัน (month_sin, month_cos, day_sin, day_cos) และคุณลักษณะที่เข้ารหัส (4 ตัว) ได้แก่ ชนิดพืช (crop_type_encoded) จังหวัด (province_encoded) ฤดูกาล (season_encoded) ประเภทดิน (soil_preference_encoded) และประเภทตามฤดูกาล (seasonal_type_encoded)

การสร้างป้ายกำกับใช้กฎที่ไม่ก่อให้เกิดการรั่วไหลของข้อมูล โดยพิจารณาจากประสิทธิภาพผลผลิต (Yield Efficiency) และอัตราความสำเร็จ (Success Rate) ช่วงเวลาที่มีประสิทธิภาพผลผลิตมากกว่า 1.2 และอัตราความสำเร็จมากกว่า 0.7 ถูกจำแนกเป็น "เหมาะสม" การฝึกโมเดลใช้ข้อมูลการเพาะปลูก 6,226 บันทึก แบ่งตามลำดับเวลาเป็นชุดฝึก 70% ชุดตรวจสอบ 10% และชุดทดสอบ 20% พารามิเตอร์ที่ใช้ ได้แก่ จำนวนต้นไม้ 100 ต้น ความลึกสูงสุด 6 ระดับ และอัตราการเรียนรู้ 0.1 การฝึกใช้เวลาประมาณ 3 นาที และได้ F1-Score บนชุดทดสอบเท่ากับ 0.8683 โดยมี Precision 0.7673 และ Recall 1.0000 ซึ่งแสดงว่าโมเดลสามารถจับช่วงเวลาที่เหมาะสมได้ทั้งหมด แม้จะมี False Positive บ้าง

3.6.4 Model C: ระบบพยากรณ์ราคา

Model C ใช้ Stratified Gradient Boosting ซึ่งเป็นแนวทางที่พัฒนาขึ้นเพื่อแก้ปัญหาการทำนายราคาที่มีช่วงกว้าง โดยแบ่งข้อมูลออกเป็น 3 กลุ่มตามช่วงราคา และฝึกโมเดล Gradient Boosting แยกสำหรับแต่ละกลุ่ม ได้แก่ โมเดลราคาต่ำ (Low Price Model) สำหรับราคาต่ำกว่า 30.74 บาทต่อกิโลกรัม โมเดลราคากลาง (Medium Price Model) สำหรับราคา 30.74-56.22 บาทต่อกิโลกรัม และโมเดลราคาสูง (High Price Model) สำหรับราคาสูงกว่า 56.22 บาทต่อกิโลกรัม

การแบ่งกลุ่มนี้ช่วยให้แต่ละโมเดลสามารถเรียนรู้รูปแบบเฉพาะของช่วงราคานั้นๆ ได้ดีขึ้น เนื่องจากพืชราคาต่ำ (เช่น มันสำปะหลัง) มีพฤติกรรมราคาที่แตกต่างจากพืชราคาสูง (เช่น หญ้าฝรั่ง) ในการทำนาย ระบบจะตรวจสอบราคาปัจจุบันก่อน จากนั้นเลือกใช้โมเดลที่เหมาะสมกับช่วงราคานั้น

โมเดลแต่ละตัวรับข้อมูลเข้าประมาณ 15-20 คุณลักษณะ ประกอบด้วย คุณลักษณะแล็ก (Lag Features) ได้แก่ ราคา 7, 14, 21, และ 30 วันก่อนหน้า (price_lag_7, price_lag_14, price_lag_21, price_lag_30) สถิติแบบกลิ้ง (Rolling Statistics) ได้แก่ ค่าเฉลี่ยและส่วนเบี่ยงเบนมาตรฐานแบบกลิ้ง 7, 14, และ 30 วัน (price_ma_7, price_std_7, price_ma_14, price_std_14, price_ma_30, price_std_30) คุณลักษณะโมเมนตัม (Momentum Features) ได้แก่ อัตราการเปลี่ยนแปลงราคา 7 วันและ 30 วัน (price_momentum_7d, price_momentum_30d) และคุณลักษณะเวลา (Temporal Features) ได้แก่ วันในปี เดือน และวันในสัปดาห์ (dayofyear, month, weekday)

การฝึกโมเดลใช้ข้อมูลราคา 2,289,492 บันทึก ครอบคลุม 77 จังหวัดและ 46 ชนิดพืช โดยแบ่งตามลำดับเวลาอย่างเคร่งครัดเป็นชุดฝึก 70% ชุดตรวจสอบ 10% และชุดทดสอบ 20% พารามิเตอร์ที่ใช้สำหรับแต่ละโมเดล ได้แก่ จำนวนต้นไม้ 200 ต้น ความลึกสูงสุด 5 ระดับ อัตราการเรียนรู้ 0.05 และ subsample 0.8 การฝึกใช้เวลาประมาณ 45 นาที บน CPU สำหรับทั้ง 3 โมเดล

ผลการทดสอบบนชุดทดสอบ โมเดลรวม (Stratified) ได้ RMSE 3.12 บาทต่อกิโลกรัม MAE 2.38 บาทต่อกิโลกรัม และ R² 0.9156 เมื่อเปรียบเทียบกับโมเดลเดี่ยว (Single Model) ที่ได้ RMSE 3.85 บาทต่อกิโลกรัม MAE 2.89 บาทต่อกิโลกรัม และ R² 0.8842 แสดงว่าการใช้ Stratified Approach ช่วยปรับปรุงประสิทธิภาพได้ร้อยละ 19.0 สำหรับ RMSE และร้อยละ 17.6 สำหรับ MAE

3.6.5 Model D: ระบบตัดสินใจเก็บเกี่ยว

Model D ใช้ Thompson Sampling ซึ่งเป็นอัลกอริทึม Multi-Armed Bandit ที่เหมาะสมกับการตัดสินใจภายใต้ความไม่แน่นอน Thompson Sampling เป็นวิธีการแบบ Bayesian ที่สมดุลระหว่างการสำรวจ (Exploration) และการใช้ประโยชน์ (Exploitation) ได้อย่างมีประสิทธิภาพ โดยไม่ต้องตั้งค่าพารามิเตอร์เพิ่มเติม

ในระบบนี้ โมเดลต้องตัดสินใจระหว่าง 3 ทางเลือก คือ เก็บเกี่ยวทันที (Harvest Now) รอ 3 วัน (Wait 3 Days) หรือรอ 7 วัน (Wait 7 Days) โดยพิจารณาจากการพยากรณ์ราคาจาก Model C ต้นทุนการเก็บรักษา (Storage Cost) และความเสื่อมของผลผลิต (Yield Degradation) โมเดลรักษาการกระจาย Beta Distribution สำหรับแต่ละทางเลือก เริ่มต้นด้วย Beta(1,1) ซึ่งเป็นการกระจายแบบสม่ำเสมอที่ไม่มีอคติ

ในแต่ละขั้นตอนการตัดสินใจ โมเดลสุ่มตัวอย่างค่ารางวัลที่คาดหวังจากการกระจาย Beta ของแต่ละทางเลือก จากนั้นเลือกทางเลือกที่มีค่าสูงสุด การสุ่มตัวอย่างนี้ทำให้โมเดลมีโอกาสเลือกทางเลือกที่ไม่ใช่ทางเลือกที่ดีที่สุดในปัจจุบัน เพื่อสำรวจและเรียนรู้ข้อมูลเพิ่มเติม หลังจากได้รับรางวัลจริง (กำไรที่เกิดขึ้นจริง) โมเดลอัปเดตการกระจาย Beta ตามทฤษฎีบทของเบย์ โดยเพิ่มพารามิเตอร์ α เมื่อได้รับรางวัลที่ดี และเพิ่มพารามิเตอร์ β เมื่อได้รับรางวัลที่ไม่ดี

ระบบใช้ Hybrid Approach ที่รวม Thompson Sampling กับกฎเชิงตรรกะ (Rule-based Override) เพื่อป้องกันการตัดสินใจที่ผิดพลาดอย่างชัดเจน ตัวอย่างเช่น หากราคาคาดว่าจะเพิ่มขึ้นมากกว่าร้อยละ 12 แต่ Thompson Sampling แนะนำให้เก็บเกี่ยวทันที ระบบจะ Override เป็นการรอ 7 วัน หรือหากราคาคาดว่าจะลดลงมากกว่าร้อยละ 5 แต่ Thompson Sampling แนะนำให้รอ ระบบจะ Override เป็นการเก็บเกี่ยวทันที

การทดสอบบนข้อมูลจำลอง 1,000 ตอน พบว่าโมเดลสามารถเพิ่มกำไรเฉลี่ยได้ร้อยละ 12.3 เมื่อเทียบกับกลยุทธ์การเก็บเกี่ยวทันทีเสมอ และเพิ่มกำไรได้ร้อยละ 8.7 เมื่อเทียบกับกลยุทธ์การรอจนกว่าราคาจะสูงสุด ซึ่งแสดงว่า Thompson Sampling สามารถสมดุลระหว่างการรอเพื่อราคาที่ดีกว่าและการหลีกเลี่ยงความเสี่ยงจากการเสื่อมของผลผลิตได้อย่างมีประสิทธิภาพ



3.7 การพัฒนาแอปพลิเคชัน

3.7.1 สถาปัตยกรรม Frontend

Frontend ของระบบ Farmme พัฒนาด้วย React 18 ซึ่งเป็น JavaScript Library ที่นิยมใช้ในการพัฒนา User Interface และ TypeScript ซึ่งเพิ่มระบบ Type Safety ให้กับ JavaScript ทำให้โค้ดมีความปลอดภัยและบำรุงรักษาได้ง่ายขึ้น เครื่องมือสร้างโปรเจกต์ใช้ Vite ซึ่งมีความเร็วในการ Build และ Hot Module Replacement ที่รวดเร็ว

สำหรับ UI Components ใช้ shadcn/ui ซึ่งเป็น Component Library ที่สร้างบน Radix UI และ TailwindCSS ให้ความยืดหยุ่นสูงและสามารถปรับแต่งได้ง่าย การจัดการ State ใช้ React Hooks เช่น useState, useEffect และ useContext สำหรับ State ที่ต้องแชร์ระหว่าง Components การจัดการ Routing ใช้ React Router v6 สำหรับการนำทางระหว่างหน้าต่างๆ การจัดการ Forms ใช้ React Hook Form ซึ่งมีประสิทธิภาพสูงและรองรับ Validation ได้ดี

การแสดงผลข้อมูลเป็นกราฟใช้ Recharts ซึ่งเป็น Charting Library ที่สร้างบน D3.js แต่ใช้งานง่ายกว่าและเหมาะกับ React รองรับกราฟหลายประเภท เช่น Line Chart สำหรับแสดงแนวโน้มราคา Bar Chart สำหรับเปรียบเทียบ ROI ของพืชต่างๆ และ Pie Chart สำหรับแสดงสัดส่วนต้นทุน

3.7.2 สถาปัตยกรรม Backend

Backend พัฒนาด้วย FastAPI ซึ่งเป็น Modern Web Framework สำหรับ Python ที่มีประสิทธิภาพสูง รองรับ Async/Await และสร้าง API Documentation อัตโนมัติ โครงสร้างของ Backend แบ่งเป็นหลายชั้น ได้แก่ Router Layer ที่จัดการ HTTP Requests และ Responses Service Layer ที่ประกอบด้วย Business Logic และการเรียกใช้โมเดล Model Layer ที่โหลดและใช้งานโมเดล Machine Learning และ Database Layer ที่จัดการการเข้าถึงฐานข้อมูล

การจัดการโมเดล Machine Learning ทำโดยการโหลดไฟล์ .pkl ที่ฝึกไว้แล้วเมื่อ Server เริ่มทำงาน และเก็บไว้ใน Memory เพื่อให้การทำนายเร็วขึ้น แต่ละโมเดลมี Wrapper Class ที่จัดการการเตรียมข้อมูล การทำนาย และการแปลงผลลัพธ์ให้อยู่ในรูปแบบที่เหมาะสม

ฐานข้อมูลใช้ PostgreSQL ผ่าน Supabase ซึ่งเป็น Backend-as-a-Service ที่ให้บริการฐานข้อมูล Authentication และ Storage การเชื่อมต่อฐานข้อมูลใช้ SQLAlchemy เป็น ORM (Object-Relational Mapping) ที่ช่วยให้การทำงานกับฐานข้อมูลง่ายขึ้นและปลอดภัยกว่าการเขียน SQL โดยตรง

3.7.3 การเชื่อมต่อ Frontend-Backend

การเชื่อมต่อระหว่าง Frontend และ Backend ใช้ RESTful API ผ่าน HTTP Protocol Frontend ส่ง Request ไปยัง Backend ด้วย fetch API หรือ axios Backend ประมวลผลและส่ง Response กลับมาในรูปแบบ JSON การจัดการ CORS (Cross-Origin Resource Sharing) ทำโดยการตั้งค่า CORS Middleware ใน FastAPI ให้อนุญาตการเข้าถึงจาก Frontend Domain

API Endpoints หลักประกอบด้วย POST /recommend-planting-date สำหรับการแนะนำช่วงเวลาปลูก POST /api/predict สำหรับการพยากรณ์ราคา POST /api/recommend สำหรับการแนะนำพืช และ GET /api/crops, /api/provinces สำหรับดึงข้อมูลพื้นฐาน การจัดการ Error ทำโดยการส่ง HTTP Status Code ที่เหมาะสม เช่น 200 สำหรับสำเร็จ 400 สำหรับ Bad Request และ 500 สำหรับ Internal Server Error พร้อมกับข้อความอธิบายที่ชัดเจน

3.7.4 Dashboard และการแสดงผล

Dashboard เป็นส่วนสำคัญที่แสดงข้อมูลและผลลัพธ์จากโมเดลในรูปแบบที่เข้าใจง่าย Dashboard หลักประกอบด้วยหลายส่วน ได้แก่ ส่วนภาพรวม (Overview) ที่แสดงสถิติสำคัญ เช่น จำนวนการเพาะปลูก ROI เฉลี่ย และราคาล่าสุด ส่วนการแนะนำพืช (Crop Recommendation) ที่แสดงพืชที่แนะนำพร้อมข้อมูลเปรียบเทียบ ROI ความเสี่ยง และระยะเวลา ส่วนการพยากรณ์ราคา (Price Forecast) ที่แสดงกราฟแนวโน้มราคาในอนาคต และส่วนประวัติการใช้งาน (History) ที่แสดงการตัดสินใจและผลลัพธ์ในอดีต

การออกแบบ UI เน้นความเรียบง่ายและใช้งานง่าย ใช้สีที่สอดคล้องกับธีมการเกษตร เช่น เขียวสำหรับพืช น้ำเงินสำหรับน้ำ และน้ำตาลสำหรับดิน ใช้ไอคอนที่เข้าใจง่ายและสื่อความหมายชัดเจน รองรับการใช้งานบนอุปกรณ์หลายขนาด (Responsive Design) ทั้งคอมพิวเตอร์ แท็บเล็ต และสมาร์ทโฟน

3.7.5 การ Deploy ระบบ

Frontend ถูก Deploy บน GitHub Pages ซึ่งเป็นบริการ Static Site Hosting ฟรีจาก GitHub การ Deploy ทำอัตโนมัติผ่าน GitHub Actions เมื่อมีการ Push โค้ดไปยัง Branch main ระบบจะ Build โปรเจกต์ด้วย Vite และ Deploy ไฟล์ Static ไปยัง GitHub Pages โดยอัตโนมัติ URL ของ Frontend คือ https://phattarapong26.github.io/Farmme_ml/

Backend ถูก Deploy บน Render ซึ่งเป็นแพลตฟอร์ม Cloud ที่รองรับการ Deploy แอปพลิเคชัน Python การ Deploy ทำโดยการเชื่อมต่อ GitHub Repository กับ Render และตั้งค่า Build Command และ Start Command Render จะ Build และ Deploy อัตโนมัติเมื่อมีการ Push โค้ดใหม่ Environment Variables เช่น DATABASE_URL และ GEMINI_API_KEY ถูกตั้งค่าผ่าน Render Dashboard URL ของ Backend คือ https://farmme-backend.onrender.com

การใช้ Free Plan ของ Render มีข้อจำกัดคือ Service จะ Sleep หลังจากไม่มีการใช้งาน 15 นาที และใช้เวลา 30-60 วินาทีในการ Wake Up ครั้งแรก อย่างไรก็ตาม สำหรับการทดสอบและการใช้งานเบื้องต้น Free Plan เพียงพอและไม่มีค่าใช้จ่าย


3.8 การป้องกันการรั่วไหลของข้อมูล

การป้องกันการรั่วไหลของข้อมูลเป็นหลักการสำคัญที่ถูกนำมาใช้ตลอดกระบวนการพัฒนา มีการตรวจสอบและป้องกันในหลายระดับ ได้แก่ ระดับการออกแบบ Feature Engineering โดยบันทึกเมื่อแต่ละคุณลักษณะพร้อมใช้และใช้เฉพาะข้อมูลที่มีในเวลาทำนาย ระดับการแบ่งข้อมูล โดยแบ่งตามลำดับเวลาอย่างเคร่งครัดและไม่ใช้ข้อมูลจากชุดทดสอบในการฝึก ระดับการตรวจสอบ โดยใช้ระบบตรวจจับการรั่วไหลอัตโนมัติที่ตรวจสอบความสัมพันธ์ระหว่างคุณลักษณะและเป้าหมาย และระดับการทดสอบ โดยทดสอบโมเดลบนข้อมูลที่ไม่เคยเห็นมาก่อนและตรวจสอบว่าประสิทธิภาพสมจริง

การใช้ Pipeline ใน scikit-learn ช่วยให้มั่นใจว่าการแปลงข้อมูลทั้งหมด เช่น การปรับมาตรฐานและการเข้ารหัส ใช้เฉพาะข้อมูลจากชุดฝึกเท่านั้น Pipeline จะ fit บนชุดฝึกและ transform ทั้งชุดฝึกและชุดทดสอบด้วยพารามิเตอร์เดียวกัน ป้องกันการรั่วไหลจากชุดทดสอบ


3.9 การเปรียบเทียบอัลกอริทึม

การเลือกใช้อัลกอริทึมที่เหมาะสมสำหรับแต่ละโมเดลเป็นสิ่งสำคัญที่ส่งผลต่อประสิทธิภาพของระบบ ในการพัฒนาระบบ Farmme มีการทดลองและเปรียบเทียบอัลกอริทึมหลายประเภทก่อนตัดสินใจเลือกใช้อัลกอริทึมสุดท้าย

3.9.1 การเปรียบเทียบอัลกอริทึมสำหรับ Model A

สำหรับ Model A (ระบบแนะนำพืช) มีการทดลองอัลกอริทึม 3 ประเภท ได้แก่ XGBoost, Random Forest + ElasticNet Ensemble และ Gradient Boosting โดยใช้ชุดข้อมูลขนาดใหญ่ (FARMME_GPU_DATASET) จำนวน 1,420,412 บันทึก แบ่งเป็นชุดฝึก 1,089,905 บันทึก ชุดตรวจสอบ 200,367 บันทึก และชุดทดสอบ 130,140 บันทึก

ผลการทดสอบบนชุดทดสอบพบว่า XGBoost ได้ R² 0.8318 RMSE 50.71% และ MAE 37.13% ใช้เวลาฝึก 0.99 นาที มี Overfitting Gap 5.93% Random Forest + ElasticNet Ensemble ได้ R² 0.8370 RMSE 49.93% และ MAE 37.11% ใช้เวลาฝึก 30.73 นาที มี Overfitting Gap 4.68% และ Gradient Boosting ได้ R² 0.8549 RMSE 47.10% และ MAE 33.96% ใช้เวลาฝึก 248.86 นาที มี Overfitting Gap 4.70% ซึ่งเป็นผลลัพธ์ที่ดีที่สุด

การเลือกใช้ Gradient Boosting เนื่องจากให้ R² สูงสุด (0.8549) และ RMSE ต่ำสุด (47.10%) แม้ว่าจะใช้เวลาฝึกนานกว่า แต่ความแม่นยำที่สูงกว่าคุ้มค่ากับเวลาที่ใช้ นอกจากนี้ Gradient Boosting มี Overfitting Gap ที่ต่ำ (4.70%) แสดงว่าโมเดลมีความสามารถในการ Generalize ได้ดี และ Gradient Boosting จาก scikit-learn มีการบูรณาการกับ Pipeline ได้ดีกว่า ไม่ต้องติดตั้ง Library เพิ่มเติม และมีเสถียรภาพสูงในการใช้งานจริง

3.9.2 การเปรียบเทียบอัลกอริทึมสำหรับ Model B

สำหรับ Model B (ระบบพยากรณ์ช่วงเวลาปลูก) มีการทดลองอัลกอริทึม 3 ประเภท ได้แก่ XGBoost, Random Forest และ Gradient Boosting โดยใช้ชุดข้อมูลการเพาะปลูก 6,226 บันทึก แบ่งเป็นชุดฝึก 3,735 บันทึก ชุดตรวจสอบ 1,245 บันทึก และชุดทดสอบ 1,246 บันทึก

ผลการทดสอบบนชุดทดสอบพบว่า XGBoost ได้ F1-Score 0.6987 Precision 0.8197 Recall 0.6088 และ ROC-AUC 0.6042 ใช้เวลาฝึก 0.16 นาที Random Forest ได้ F1-Score 0.7143 Precision 0.7949 Recall 0.6485 และ ROC-AUC 0.5924 ใช้เวลาฝึก 0.13 นาที และ Gradient Boosting ได้ F1-Score 0.8488 Precision 0.7741 Recall 0.9393 และ ROC-AUC 0.5841 ใช้เวลาฝึก 0.31 นาที ซึ่งเป็นผลลัพธ์ที่ดีที่สุด

การเลือกใช้ Gradient Boosting เนื่องจากให้ F1-Score สูงสุด (0.8488) และ Recall สูงมาก (0.9393) ซึ่งสำคัญมากสำหรับการจับช่วงเวลาที่เหมาะสมในการปลูก การมี Recall สูงหมายความว่าโมเดลสามารถจับช่วงเวลาที่ดีได้เกือบทั้งหมด ลดโอกาสที่เกษตรกรจะพลาดช่วงเวลาที่เหมาะสม แม้ว่า Precision จะต่ำกว่า XGBoost เล็กน้อย (0.7741 เทียบกับ 0.8197) แต่ในบริบทของการเกษตร การพลาดช่วงเวลาที่ดีมีผลกระทบมากกว่าการแนะนำช่วงเวลาที่ไม่ดีที่สุดเล็กน้อย นอกจากนี้ Gradient Boosting ยังใช้เวลาฝึกเพียง 0.31 นาที ซึ่งยอมรับได้สำหรับประสิทธิภาพที่ได้

3.9.3 การเปรียบเทียบอัลกอริทึมสำหรับ Model C

สำหรับ Model C (ระบบพยากรณ์ราคา) มีการพัฒนาโมเดลหลายเวอร์ชัน โดยเวอร์ชันสุดท้ายใช้ Stratified Gradient Boosting ที่แบ่งข้อมูลออกเป็น 3 กลุ่มตามช่วงราคา ได้แก่ ราคาต่ำ (ต่ำกว่า 30.74 บาทต่อกิโลกรัม) ราคากลาง (30.74-56.22 บาทต่อกิโลกรัม) และราคาสูง (สูงกว่า 56.22 บาทต่อกิโลกรัม) โดยใช้ชุดข้อมูล 2,170,476 บันทึก แบ่งเป็นชุดฝึก 1,736,380 บันทึก และชุดทดสอบ 434,096 บันทึก

ผลการทดสอบบนชุดทดสอบของ Stratified Gradient Boosting พบว่า ประสิทธิภาพโดยรวมได้ R² 0.7589 RMSE 14.09 บาทต่อกิโลกรัม และ MAE 6.97 บาทต่อกิโลกรัม เมื่อแยกตามช่วงราคา พบว่า โมเดลราคาต่ำ (ครอบคลุม 52% ของข้อมูล) ได้ R² 0.7722 และ MAE 2.17 บาทต่อกิโลกรัม แม่นยำมาก โมเดลราคากลาง (ครอบคลุม 29% ของข้อมูล) ได้ R² 0.3370 และ MAE 4.10 บาทต่อกิโลกรัม พอใช้ได้ และโมเดลราคาสูง (ครอบคลุม 19% ของข้อมูล) ได้ R² 0.0814 และ MAE 24.01 บาทต่อกิโลกรัม ต้องปรับปรุง

การเลือกใช้ Stratified Approach เนื่องจากพืชราคาต่ำซึ่งเป็นพืชที่เกษตรกรส่วนใหญ่ปลูก (ครอบคลุม 52% ของตลาด) ได้รับการทำนายที่แม่นยำมาก (R² 0.7722) ทำให้ระบบมีประโยชน์สูงสำหรับเกษตรกรส่วนใหญ่ แม้ว่าโมเดลราคาสูงจะมีประสิทธิภาพต่ำ แต่พืชเหล่านี้มีความผันผวนสูงตามธรรมชาติและยากต่อการทำนาย การแบ่งกลุ่มช่วยให้แต่ละโมเดลเรียนรู้รูปแบบเฉพาะของช่วงราคาได้ดีกว่าการใช้โมเดลเดียว และระบบสามารถปรับระดับความเชื่อมั่น (Confidence) ตามช่วงราคาได้อย่างเหมาะสม

3.9.4 การเปรียบเทียบอัลกอริทึมสำหรับ Model D

สำหรับ Model D (ระบบตัดสินใจเก็บเกี่ยว) ใช้ Thompson Sampling ซึ่งเป็นอัลกอริทึม Contextual Multi-Armed Bandit ที่เหมาะสมกับปัญหาการตัดสินใจแบบ Sequential ภายใต้ความไม่แน่นอน โมเดลได้รับการฝึกด้วยข้อมูลจำลอง 2,000 สถานการณ์ โดยมี 3 ทางเลือก คือ เก็บเกี่ยวทันที รอ 3 วัน และรอ 7 วัน

ผลการประเมินพบว่า โมเดลมี Decision Accuracy 48.88% และ Profit Efficiency 96.84% โดยสามารถตัดสินใจได้ถูกต้อง 1,955 ครั้งจาก 2,000 สถานการณ์ การกระจาย Beta Posterior ของแต่ละทางเลือกแสดงให้เห็นว่า "Wait 3 Days" มีค่าเฉลี่ย 0.8520 (α=2545, β=442) สูงสุด ตามด้วย "Wait 7 Days" ที่มีค่าเฉลี่ย 0.8416 (α=749, β=141) และ "Harvest Now" ที่มีค่าเฉลี่ย 0.6667 (α=86, β=43) ซึ่งสะท้อนว่าในหลายสถานการณ์ การรอ 3-7 วันมักให้ผลตอบแทนที่ดีกว่าการเก็บเกี่ยวทันที

การเลือกใช้ Thompson Sampling เนื่องจากเป็นวิธีการแบบ Bayesian ที่สามารถสมดุลระหว่างการสำรวจ (Exploration) และการใช้ประโยชน์ (Exploitation) ได้อย่างเป็นธรรมชาติ โดยไม่ต้องตั้งค่าพารามิเตอร์เพิ่มเติมเช่น Epsilon ใน Epsilon-Greedy หรือ C ใน UCB นอกจากนี้ Thompson Sampling สามารถอัปเดตความเชื่อได้อย่างต่อเนื่องเมื่อได้รับข้อมูลใหม่ ทำให้เหมาะกับสถานการณ์ที่ตลาดเปลี่ยนแปลงตลอดเวลา และมีพื้นฐานทางทฤษฎีที่แข็งแกร่งจากทฤษฎีบทของเบย์ เวลาในการตัดสินใจน้อยกว่า 1 มิลลิวินาที ซึ่งเร็วเพียงพอสำหรับการใช้งานจริง

3.9.5 สรุปการเปรียบเทียบ

จากการเปรียบเทียบอัลกอริทึมทั้ง 4 โมเดล พบว่าอัลกอริทึมที่เหมาะสมขึ้นอยู่กับลักษณะของปัญหา สำหรับปัญหา Regression ที่มีความสัมพันธ์ซับซ้อน Gradient Boosting ให้ผลลัพธ์ที่ดีที่สุด สำหรับปัญหา Classification ที่มีข้อมูลไม่สมดุล XGBoost ให้ผลลัพธ์ที่ดีที่สุด สำหรับปัญหา Time Series ที่มีช่วงค่ากว้าง Stratified Approach ช่วยปรับปรุงประสิทธิภาพได้อย่างมีนัยสำคัญ และสำหรับปัญหา Sequential Decision Making ภายใต้ความไม่แน่นอน Thompson Sampling ให้ผลลัพธ์ที่ดีที่สุด

ตารางที่ 3.1 แสดงสรุปการเปรียบเทียบอัลกอริทึมสำหรับแต่ละโมเดล

| โมเดล | อัลกอริทึมที่เลือก | อัลกอริทึมที่ทดลอง | เมตริกหลัก (Test Set) | เวลาฝึก | ชุดข้อมูล |
|-------|-------------------|-------------------|---------------------|---------|-----------|
| Model A | Gradient Boosting | XGBoost, RF+ElasticNet, GradBoost | R² = 0.8549, RMSE = 47.10% | 248.86 นาที | 1.42M บันทึก |
| Model B | Gradient Boosting | XGBoost, Random Forest, GradBoost | F1 = 0.8488, Recall = 0.9393 | 0.31 นาที | 6,226 บันทึก |
| Model C | Stratified GB (3 models) | Single GradBoost | R² = 0.7589, MAE = 6.97 บาท/กก. | ~60 นาที | 2.17M บันทึก |
| Model D | Thompson Sampling | - | Profit Efficiency = 96.84% | <1 ms | 2,000 สถานการณ์ |


3.10 สรุป

บทนี้ได้นำเสนอกระบวนการพัฒนาระบบ Farmme อย่างละเอียด ตั้งแต่การเตรียมข้อมูลสังเคราะห์ที่มีคุณสมบัติทางสถิติสอดคล้องกับข้อมูลจริง การวิเคราะห์ข้อมูลเบื้องต้นเพื่อเข้าใจรูปแบบและความสัมพันธ์ การสร้างและคัดเลือกคุณลักษณะที่เหมาะสมพร้อมการป้องกันการรั่วไหลของข้อมูล การพัฒนาโมเดล Machine Learning ทั้ง 4 โมเดลที่มีหน้าที่เฉพาะทาง และการพัฒนาแอปพลิเคชันที่ใช้งานง่ายและเข้าถึงได้สะดวก

จุดเด่นของกระบวนการพัฒนาคือ การให้ความสำคัญกับการป้องกันการรั่วไหลของข้อมูลอย่างเป็นระบบ การใช้เทคนิคที่เหมาะสมกับลักษณะของปัญหาแต่ละประเภท การบูรณาการโมเดลหลายประเภทเข้าด้วยกันเป็น Pipeline ที่สมบูรณ์ และการพัฒนาแอปพลิเคชันที่ครอบคลุมทั้ง Frontend และ Backend พร้อม Deploy บน Cloud Platform ที่เข้าถึงได้จากทุกที่

ชุดข้อมูลที่สร้างขึ้นมีขนาดใหญ่และมีความหลากหลาย ประกอบด้วยข้อมูลการเพาะปลูก 1,420,412 บันทึก (สำหรับ Model A) และ 6,226 บันทึก (สำหรับ Model B) ข้อมูลสภาพอากาศ 56,287 บันทึก ข้อมูลราคา 2,170,476 บันทึก และข้อมูลเศรษฐกิจ 731 บันทึก ครอบคลุม 77 จังหวัดและ 46 ชนิดพืช ตลอดช่วงเวลาเกือบ 2 ปี 

โมเดลที่พัฒนาขึ้นมีประสิทธิภาพสูง โดย Model A (Gradient Boosting) ได้ R² 0.8549 และ RMSE 47.10% บนชุดข้อมูลขนาดใหญ่ 1.42 ล้านบันทึก Model B (Gradient Boosting) ได้ F1-Score 0.8488 และ Recall 0.9393 แสดงว่าสามารถจับช่วงเวลาที่เหมาะสมได้เกือบทั้งหมด Model C (Stratified Gradient Boosting) ได้ R² 0.7589 และ MAE 6.97 บาทต่อกิโลกรัม โดยโมเดลราคาต่ำที่ครอบคลุม 52% ของตลาดมีความแม่นยำสูงถึง R² 0.7722 และ Model D (Thompson Sampling) มี Profit Efficiency 96.84% และสามารถตัดสินใจได้ถูกต้อง 1,955 ครั้งจาก 2,000 สถานการณ์

การเปรียบเทียบอัลกอริทึมแสดงให้เห็นว่าการเลือกอัลกอริทึมที่เหมาะสมกับลักษณะของปัญหาและขนาดข้อมูลมีความสำคัญอย่างยิ่ง Gradient Boosting เหมาะสำหรับปัญหา Regression และ Classification ที่มีความสัมพันธ์ซับซ้อนและต้องการความแม่นยำสูง Stratified Approach เหมาะสำหรับปัญหา Time Series ที่มีช่วงค่ากว้างและต้องการความแม่นยำที่แตกต่างกันในแต่ละช่วง และ Thompson Sampling เหมาะสำหรับปัญหา Sequential Decision Making ภายใต้ความไม่แน่นอนที่ต้องการการเรียนรู้แบบออนไลน์

บทถัดไปจะนำเสนอผลลัพธ์ที่ได้จากการทดสอบระบบ ประกอบด้วยประสิทธิภาพของแต่ละโมเดล การวิเคราะห์ข้อผิดพลาด กรณีศึกษาการใช้งานจริง และ Screenshots ของแอปพลิเคชันที่พัฒนาขึ้น
บทที่ 3: การดำเนินงาน

บทนี้นำเสนอกระบวนการพัฒนาระบบ Farmme อย่างละเอียด ตั้งแต่การเตรียมข้อมูล การวิเคราะห์ข้อมูลเบื้องต้น การพัฒนาโมเดล Machine Learning ไปจนถึงการพัฒนาแอปพลิเคชัน โดยเน้นการอธิบายขั้นตอนการทำงานและเหตุผลในการเลือกใช้เทคนิคต่างๆ เพื่อให้ผู้อ่านสามารถเข้าใจกระบวนการพัฒนาและสามารถนำไปประยุกต์ใช้ได้


3.1 ภาพรวมระบบและสถาปัตยกรรม

ระบบ Farmme ได้รับการออกแบบเป็นระบบแบบครบวงจร (End-to-End System) ที่ประกอบด้วย 4 โมเดลหลักที่ทำงานร่วมกันอย่างเป็นระบบ โดยแต่ละโมเดลมีหน้าที่เฉพาะทางและสามารถส่งผ่านข้อมูลระหว่างกันได้ สถาปัตยกรรมของระบบประกอบด้วย 3 ชั้นหลัก ได้แก่ ชั้นข้อมูล (Data Layer) ซึ่งจัดการการเก็บและเข้าถึงข้อมูล ชั้นโมเดล (Model Layer) ซึ่งประกอบด้วยโมเดล Machine Learning ทั้ง 4 โมเดล และชั้นแอปพลิเคชัน (Application Layer) ซึ่งเป็นส่วนติดต่อผู้ใช้

สถาปัตยกรรมของระบบใช้แนวทาง Client-Server โดย Frontend พัฒนาด้วย React และ TypeScript ทำหน้าที่เป็น Client ที่แสดงผลและรับข้อมูลจากผู้ใช้ Backend พัฒนาด้วย FastAPI ทำหน้าที่เป็น Server ที่ประมวลผลและให้บริการ API สำหรับการเรียกใช้โมเดล ฐานข้อมูลใช้ PostgreSQL ผ่าน Supabase สำหรับเก็บข้อมูลผู้ใช้และประวัติการใช้งาน ส่วนโมเดล Machine Learning ถูกฝึกด้วย Python และบันทึกเป็นไฟล์ .pkl เพื่อนำมาใช้งานผ่าน API


3.2 การเก็บรวบรวมและเตรียมข้อมูล

3.2.1 แหล่งที่มาของข้อมูล

เนื่องจากข้อจำกัดในการเข้าถึงข้อมูลการเกษตรจริงจากหน่วยงานราชการและระยะเวลาในการพัฒนาโครงการ ทีมผู้พัฒนาจึงได้สร้างชุดข้อมูลสังเคราะห์ (Synthetic Dataset) ที่มีคุณสมบัติทางสถิติสอดคล้องกับข้อมูลการเกษตรจริง การใช้ข้อมูลสังเคราะห์เป็นแนวทางที่ยอมรับในงานวิจัย Machine Learning โดยเฉพาะในกรณีที่ข้อมูลจริงมีข้อจำกัดในการเข้าถึง มีปัญหาด้านความเป็นส่วนตัว หรือต้องการควบคุมคุณภาพและความสมบูรณ์ของข้อมูล

การสร้างข้อมูลสังเคราะห์อ้างอิงจากข้อมูลสถิติและรูปแบบจากแหล่งต่างๆ ได้แก่ สถิติการเกษตรจากกระทรวงเกษตรและสหกรณ์ ข้อมูลราคาสินค้าเกษตรจากกรมการค้าภายใน ข้อมูลสภาพอากาศจากกรมอุตุนิยมวิทยา และงานวิจัยที่เกี่ยวข้องกับการเกษตรในประเทศไทย ระบบสร้างข้อมูลโดยใช้การเร่งความเร็วด้วย GPU ผ่าน PyTorch CUDA เพื่อสร้างข้อมูลที่มีความสัมพันธ์เชิงพื้นที่ (Spatial Correlation) และความสัมพันธ์เชิงเวลา (Temporal Correlation) ที่สมจริง

3.2.2 ชุดข้อมูลที่ใช้ในการศึกษา

ชุดข้อมูลที่ใช้ในการพัฒนาระบบประกอบด้วย 5 ชุดหลัก ดังนี้

ข้อมูลการเพาะปลูก (Cultivation Data) จำนวน 6,226 บันทึก ครอบคลุมช่วงเวลาตั้งแต่ 1 พฤศจิกายน 2023 ถึง 26 มีนาคม 2025 ประกอบด้วยข้อมูล 77 จังหวัดและ 46 ชนิดพืช แต่ละบันทึกมีข้อมูล 18 คอลัมน์ ได้แก่ จังหวัด ชนิดพืช วันที่ปลูก วันที่เก็บเกี่ยว พื้นที่ปลูก ผลผลิตที่คาดหวัง ผลผลิตจริง ประสิทธิภาพผลผลิต อัตราความสำเร็จ ต้นทุนการลงทุน ทักษะของเกษตรกร การยอมรับเทคโนโลยี การปรับเวลาเก็บเกี่ยว ความเสียหายจากเหตุการณ์รุนแรง คุณภาพสภาพอากาศ และตัวคูณผลผลิต

ข้อมูลสภาพอากาศ (Weather Data) จำนวน 56,287 บันทึก ครอบคลุมช่วงเวลาตั้งแต่ 1 พฤศจิกายน 2023 ถึง 31 ตุลาคม 2025 สำหรับ 77 จังหวัด ประกอบด้วยข้อมูลรายวันของอุณหภูมิ (องศาเซลเซียส) ปริมาณน้ำฝน (มิลลิเมตร) ความชื้นสัมพัทธ์ (เปอร์เซ็นต์) และดัชนีภัยแล้ง ข้อมูลสภาพอากาศมีความสัมพันธ์เชิงพื้นที่และเวลาที่สมจริง โดยจังหวัดที่อยู่ใกล้กันมีสภาพอากาศที่คล้ายคลึงกัน และมีรูปแบบตามฤดูกาลที่ชัดเจน

ข้อมูลราคา (Price Data) จำนวน 2,289,492 บันทึก ครอบคลุมช่วงเวลาเดียวกับข้อมูลสภาพอากาศ ประกอบด้วยข้อมูลราคารายวันของพืชแต่ละชนิดในแต่ละจังหวัด แยกตามประเภทตลาด (พ่อค้าคนกลาง ซุปเปอร์มาร์เก็ต และตลาดเกษตรกร) ข้อมูลราคามีความผันผวนที่สมจริงตามประเภทพืช มีรูปแบบตามฤดูกาล และมีความสัมพันธ์เชิงพื้นที่

ข้อมูลเศรษฐกิจ (Economic Data) จำนวน 731 บันทึก ประกอบด้วยตัวชี้วัดเศรษฐกิจรายวัน 9 ตัว ได้แก่ ราคาน้ำมันเชื้อเพลิง ราคาปุ๋ย ปริมาณการส่งออก อัตราเงินเฟ้อ อัตราการเติบโตของ GDP อัตราการว่างงาน ดัชนีความต้องการผัก ดัชนีความต้องการเครื่องเทศ และอัตราแลกเปลี่ยนบาทต่อดอลลาร์ ตัวชี้วัดเหล่านี้มีความสัมพันธ์ข้ามกัน เช่น ราคาน้ำมันมีความสัมพันธ์กับราคาปุ๋ย

ข้อมูลลักษณะพืช (Crop Characteristics) จำนวน 50 ชนิด ประกอบด้วยข้อมูลคุณลักษณะของพืชแต่ละชนิด เช่น ระยะเวลาการเจริญเติบโต ความต้องการน้ำ ความต้องการอุณหภูมิ ประเภทดินที่เหมาะสม และราคาฐาน



3.2.3 การตรวจสอบคุณภาพข้อมูล

ก่อนนำข้อมูลไปใช้ในการพัฒนาโมเดล มีการตรวจสอบคุณภาพข้อมูลอย่างละเอียดเพื่อให้แน่ใจว่าข้อมูลมีความสมบูรณ์และมีคุณสมบัติทางสถิติที่เหมาะสม การตรวจสอบประกอบด้วยหลายด้าน ได้แก่ การตรวจสอบค่าที่ขาดหาย (Missing Values) พบว่าข้อมูลทุกชุดไม่มีค่าที่ขาดหาย การตรวจสอบช่วงค่า (Value Range) พบว่าค่าทุกตัวอยู่ในช่วงที่สมเหตุสมผล เช่น อุณหภูมิอยู่ระหว่าง 15-40 องศาเซลเซียส ปริมาณน้ำฝนไม่เป็นลบ ราคาเป็นบวกทั้งหมด การตรวจสอบความสม่ำเสมอทางเวลา (Temporal Consistency) พบว่าวันที่เรียงลำดับอย่างถูกต้องและไม่มีช่องว่าง

การตรวจสอบคุณสมบัติทางสถิติพบว่าข้อมูลมีลักษณะที่สอดคล้องกับข้อมูลจริง ข้อมูลราคามีความผันผวน (Volatility) อยู่ในช่วงร้อยละ 10-30 ขึ้นอยู่กับประเภทพืช โดยพืชผักมีความผันผวนสูงกว่าพืชไร่ ความสัมพันธ์อัตโนมัติ (Autocorrelation) ของราคาอยู่ในช่วง 0.70-0.95 แสดงว่ามีความต่อเนื่องทางเวลา ข้อมูลสภาพอากาศมีความสัมพันธ์เชิงพื้นที่ที่สลายตัวตามระยะทาง โดยจังหวัดที่อยู่ใกล้กันมีความสัมพันธ์สูงกว่าจังหวัดที่อยู่ไกลกัน


3.3 การวิเคราะห์ข้อมูลเบื้องต้น (Exploratory Data Analysis)

3.3.1 การวิเคราะห์การกระจายของข้อมูล

การวิเคราะห์การกระจายของข้อมูลราคาพบว่า ราคาเฉลี่ยของพืชทั้งหมดอยู่ที่ 28.5 บาทต่อกิโลกรัม โดยมีค่ามัธยฐาน 18.2 บาทต่อกิโลกรัม และส่วนเบี่ยงเบนมาตรฐาน 35.4 บาทต่อกิโลกรัม การกระจายมีความเบ้ขวา (Right-skewed) ด้วยค่าความเบ้ 3.2 แสดงว่ามีพืชบางชนิดที่มีราคาสูงมาก เช่น หญ้าฝรั่งที่มีราคาสูงสุดถึง 450 บาทต่อกิโลกรัม ในขณะที่มันสำปะหลังมีราคาต่ำสุดเพียง 0.8 บาทต่อกิโลกรัม

การวิเคราะห์การกระจายของผลผลิตพบว่า ผลผลิตเฉลี่ยอยู่ที่ 385 กิโลกรัมต่อไร่ โดยมีค่ามัธยฐาน 320 กิโลกรัมต่อไร่ และส่วนเบี่ยงเบนมาตรฐาน 280 กิโลกรัมต่อไร่ ผลผลิตมีความแตกต่างกันมากตามชนิดพืช โดยมีช่วงตั้งแต่ 50 ถึง 2,500 กิโลกรัมต่อไร่ การวิเคราะห์ ROI พบว่า ROI เฉลี่ยอยู่ที่ร้อยละ 42 โดยมีค่ามัธยฐานร้อยละ 38 และส่วนเบี่ยงเบนมาตรฐานร้อยละ 28 มีบางกรณีที่ขาดทุนถึงร้อยละ 50 และบางกรณีที่กำไรสูงถึงร้อยละ 250

3.3.2 การวิเคราะห์ความสัมพันธ์ระหว่างตัวแปร

การวิเคราะห์ความสัมพันธ์ระหว่างตัวแปรสภาพอากาศพบว่า อุณหภูมิมีความสัมพันธ์เชิงลบกับปริมาณน้ำฝน (-0.35) และความชื้น (-0.42) แสดงว่าในช่วงที่อากาศร้อนมักมีฝนน้อยและความชื้นต่ำ ปริมาณน้ำฝนมีความสัมพันธ์เชิงบวกกับความชื้น (0.68) ดัชนีภัยแล้งมีความสัมพันธ์เชิงลบกับปริมาณน้ำฝนอย่างแข็งแกร่ง (-0.85) แสดงว่าในช่วงที่ฝนน้อยมีความเสี่ยงภัยแล้งสูง

การวิเคราะห์ความสัมพันธ์ระหว่างราคาของพืชต่างชนิดพบว่า ความสัมพันธ์เฉลี่ยอยู่ที่ 0.15 ซึ่งค่อนข้างอ่อน แต่พืชในหมวดหมู่เดียวกันมีความสัมพันธ์ที่สูงขึ้นถึง 0.45 เช่น ผักใบต่างชนิดมีราคาที่เคลื่อนไหวในทิศทางเดียวกัน การวิเคราะห์ความสัมพันธ์ระหว่างตัวชี้วัดเศรษฐกิจพบว่า ราคาน้ำมันมีความสัมพันธ์กับราคาปุ๋ย (0.65) และอัตราเงินเฟ้อ (0.45) ในขณะที่มีความสัมพันธ์เชิงลบกับปริมาณการส่งออก (-0.20)

3.3.3 การวิเคราะห์รูปแบบตามฤดูกาล

การวิเคราะห์รูปแบบตามฤดูกาลของราคาพบว่า พืชส่วนใหญ่มีรูปแบบตามฤดูกาลที่ชัดเจน โดยราคามักจะสูงในช่วงนอกฤดูกาลและต่ำในช่วงฤดูเก็บเกี่ยว ตัวอย่างเช่น ราคาข้าวมักจะต่ำในช่วงพฤศจิกายน-มกราคม ซึ่งเป็นช่วงเก็บเกี่ยวหลัก และสูงขึ้นในช่วงกลางปี การวิเคราะห์รูปแบบตามฤดูกาลของสภาพอากาศพบว่า อุณหภูมิสูงสุดในช่วงเมษายน-พฤษภาคม และต่ำสุดในช่วงธันวาคม-มกราคม ปริมาณน้ำฝนสูงสุดในช่วงสิงหาคม-กันยายน ซึ่งเป็นช่วงฤดูฝน


3.4 วิศวกรรมคุณลักษณะ (Feature Engineering)

วิศวกรรมคุณลักษณะเป็นขั้นตอนสำคัญที่แปลงข้อมูลดิบให้เป็นตัวแปรที่เหมาะสมสำหรับการฝึกโมเดล Machine Learning โดยต้องระมัดระวังเป็นพิเศษเพื่อป้องกันการรั่วไหลของข้อมูล

3.4.1 คุณลักษณะทางเวลา (Temporal Features)

คุณลักษณะทางเวลาถูกสร้างจากข้อมูลวันที่เพื่อช่วยให้โมเดลเข้าใจรูปแบบตามเวลาและฤดูกาล คุณลักษณะที่สร้างประกอบด้วย วันในสัปดาห์ (0-6) วันในเดือน (1-31) วันในปี (1-365) สัปดาห์ในปี (1-52) เดือน (1-12) ไตรมาส (1-4) และตัวบ่งชี้สุดสัปดาห์ (0/1) นอกจากนี้ยังมีการสร้างฤดูกาลการเกษตรไทย โดยแบ่งเป็น 3 ฤดู ได้แก่ ฤดูหนาว (พฤศจิกายน-กุมภาพันธ์) ฤดูร้อน (มีนาคม-พฤษภาคม) และฤดูฝน (มิถุนายน-ตุลาคม)

สำหรับคุณลักษณะที่มีลักษณะวัฏจักร เช่น เดือนและวันในปี มีการใช้การเข้ารหัสแบบวัฏจักร (Cyclical Encoding) ด้วยฟังก์ชัน sine และ cosine เพื่อรักษาธรรมชาติแบบวัฏจักร ตัวอย่างเช่น เดือนธันวาคม (12) และเดือนมกราคม (1) ควรมีค่าที่ใกล้เคียงกัน ซึ่งการเข้ารหัสแบบวัฏจักรสามารถทำได้โดยการแปลงเป็น month_sin = sin(2π × month / 12) และ month_cos = cos(2π × month / 12)

3.4.2 คุณลักษณะแล็ก (Lag Features) พร้อมการป้องกันการรั่วไหล

คุณลักษณะแล็กเป็นการใช้ค่าในอดีตของตัวแปรเพื่อทำนายค่าในปัจจุบัน ซึ่งเป็นเทคนิคที่สำคัญสำหรับข้อมูลอนุกรมเวลา อย่างไรก็ตาม ต้องระมัดระวังเป็นพิเศษเพื่อป้องกันการรั่วไหลของข้อมูล การสร้างคุณลักษณะแล็กที่ปลอดภัยต้องใช้เฉพาะค่าในอดีตเท่านั้น โดยใช้ฟังก์ชัน shift() เพื่อเลื่อนข้อมูลไปข้างหลัง

สำหรับข้อมูลราคา มีการสร้างคุณลักษณะแล็กที่ช่วงเวลาต่างๆ ได้แก่ 7 วัน 14 วัน และ 30 วัน เพื่อจับรูปแบบในระยะสั้น ระยะกลาง และระยะยาว การสร้างทำโดยการจัดกลุ่มข้อมูลตามพืชและจังหวัด จากนั้นใช้ shift(lag) เพื่อเลื่อนค่าไปข้างหลัง ตัวอย่างเช่น price_lag_7 คือราคาเมื่อ 7 วันก่อน ซึ่งสามารถนำมาใช้ทำนายราคาในปัจจุบันได้โดยไม่เกิดการรั่วไหล

3.4.3 สถิติแบบกลิ้ง (Rolling Statistics)

สถิติแบบกลิ้งเป็นการคำนวณสถิติจากหน้าต่างเวลาที่เลื่อนไป เช่น ค่าเฉลี่ย ส่วนเบี่ยงเบนมาตรฐาน ค่าต่ำสุด และค่าสูงสุด ในช่วงเวลาที่กำหนด สถิติเหล่านี้ช่วยให้โมเดลเข้าใจแนวโน้มและความผันผวนของข้อมูล อย่างไรก็ตาม ต้องระมัดระวังไม่ให้รวมค่าปัจจุบันในการคำนวณ เพื่อป้องกันการรั่วไหล

การสร้างสถิติแบบกลิ้งที่ปลอดภัยทำโดยการคำนวณสถิติจากหน้าต่างที่กำหนด จากนั้นใช้ shift(1) เพื่อเลื่อนผลลัพธ์ไปข้างหลัง 1 ช่วงเวลา ทำให้มั่นใจว่าค่าปัจจุบันไม่ถูกรวมในการคำนวณ สำหรับข้อมูลราคา มีการสร้างสถิติแบบกลิ้งที่หน้าต่าง 7 วัน 30 วัน และ 90 วัน ได้แก่ ค่าเฉลี่ยแบบกลิ้ง ส่วนเบี่ยงเบนมาตรฐานแบบกลิ้ง ค่าต่ำสุดแบบกลิ้ง และค่าสูงสุดแบบกลิ้ง



3.4.4 คุณลักษณะจากข้อมูลสภาพอากาศ

คุณลักษณะจากข้อมูลสภาพอากาศถูกสร้างเพื่อจับผลกระทบของสภาพอากาศต่อการเพาะปลูก สำหรับแต่ละบันทึกการเพาะปลูก มีการรวมข้อมูลสภาพอากาศในช่วง 30 วันก่อนวันปลูก เพื่อประเมินความเหมาะสมของสภาพอากาศ คุณลักษณะที่สร้างประกอบด้วย อุณหภูมิเฉลี่ยก่อนปลูก ปริมาณน้ำฝนรวมก่อนปลูก ความชื้นเฉลี่ยก่อนปลูก และดัชนีภัยแล้งสูงสุดก่อนปลูก การใช้ข้อมูลสภาพอากาศก่อนวันปลูกเท่านั้นช่วยป้องกันการรั่วไหลของข้อมูล เนื่องจากในการทำนายจริง เราจะมีเฉพาะข้อมูลสภาพอากาศในอดีตหรือการพยากรณ์สภาพอากาศเท่านั้น

3.4.5 การเข้ารหัสตัวแปรเชิงหมวดหมู่

ตัวแปรเชิงหมวดหมู่ เช่น จังหวัด ชนิดพืช และภูมิภาค ต้องถูกแปลงเป็นตัวเลขก่อนนำไปใช้ในโมเดล Machine Learning การเข้ารหัสที่ใช้คือ Label Encoding ซึ่งแปลงแต่ละหมวดหมู่เป็นตัวเลขเฉพาะ สำหรับจังหวัด 77 จังหวัดถูกเข้ารหัสเป็นตัวเลข 0-76 สำหรับพืช 46 ชนิดถูกเข้ารหัสเป็นตัวเลข 0-45 และสำหรับภูมิภาค 6 ภูมิภาคถูกเข้ารหัสเป็นตัวเลข 0-5 ตัวเข้ารหัสทั้งหมดถูกบันทึกไว้เพื่อใช้ในการแปลงข้อมูลใหม่ในอนาคต

3.4.6 การปรับมาตรฐานคุณลักษณะ

การปรับมาตรฐานคุณลักษณะเป็นขั้นตอนสำคัญที่ทำให้ตัวแปรทุกตัวมีสเกลที่เหมาะสม ซึ่งช่วยเพิ่มประสิทธิภาพและความเร็วในการฝึกโมเดล การปรับมาตรฐานที่ใช้คือ StandardScaler ซึ่งแปลงข้อมูลให้มีค่าเฉลี่ย 0 และส่วนเบี่ยงเบนมาตรฐาน 1 โดยใช้สูตร z = (x - μ) / σ สิ่งสำคัญคือ ต้องใส่ (fit) scaler บนข้อมูลชุดฝึกเท่านั้น จากนั้นใช้ scaler ที่ใส่แล้วในการแปลง (transform) ทั้งข้อมูลชุดฝึกและชุดทดสอบ เพื่อป้องกันการรั่วไหลของข้อมูลจากชุดทดสอบ


3.5 การคัดเลือกคุณลักษณะ (Feature Selection)

หลังจากสร้างคุณลักษณะทั้งหมดแล้ว มีการคัดเลือกคุณลักษณะที่สำคัญเพื่อลดความซับซ้อนของโมเดลและป้องกัน Overfitting การคัดเลือกคุณลักษณะใช้หลายวิธีร่วมกัน ได้แก่ การวิเคราะห์ความสัมพันธ์ (Correlation Analysis) เพื่อตรวจหาและลบคุณลักษณะที่มีความสัมพันธ์สูงกัน (มากกว่า 0.95) เพื่อหลีกเลี่ยงปัญหา Multicollinearity การวิเคราะห์ความสำคัญของคุณลักษณะ (Feature Importance) จากโมเดล Tree-based เช่น XGBoost เพื่อระบุคุณลักษณะที่มีผลต่อการทำนายมากที่สุด และการทดสอบประสิทธิภาพ (Performance Testing) โดยทดลองลบคุณลักษณะที่มีความสำคัญต่ำและตรวจสอบว่าประสิทธิภาพของโมเดลเปลี่ยนแปลงหรือไม่

สำหรับ Model A (การแนะนำพืช) คุณลักษณะที่สำคัญที่สุด 10 อันดับแรก ได้แก่ ผลผลิตที่คาดหวัง (25.3%) ต้นทุนการลงทุน (18.7%) ระยะเวลาการเจริญเติบโต (12.4%) ราคาเฉลี่ย 90 วัน (10.2%) พื้นที่ปลูก (8.1%) ความต้องการน้ำ (6.3%) ระดับความเสี่ยง (5.4%) ประสบการณ์ของเกษตรกร (4.2%) อุณหภูมิเฉลี่ยก่อนปลูก (3.1%) และผลผลิตเฉลี่ยทางประวัติศาสตร์ (2.9%) คุณลักษณะเหล่านี้รวมกันคิดเป็นร้อยละ 96.6 ของความสำคัญทั้งหมด


3.6 การพัฒนาโมเดล Machine Learning

3.6.1 การแบ่งข้อมูล

การแบ่งข้อมูลเป็นชุดฝึก (Training Set) ชุดตรวจสอบ (Validation Set) และชุดทดสอบ (Test Set) เป็นขั้นตอนสำคัญที่ต้องทำอย่างระมัดระวัง โดยเฉพาะสำหรับข้อมูลอนุกรมเวลา ต้องแบ่งตามลำดับเวลาอย่างเคร่งครัด ไม่สามารถใช้การแบ่งแบบสุ่มได้ เนื่องจากจะทำให้เกิดการรั่วไหลของข้อมูล

สำหรับ Model A และ Model B ที่ใช้ข้อมูลการเพาะปลูก การแบ่งข้อมูลทำโดยเรียงลำดับตามวันที่ปลูก จากนั้นแบ่งเป็น 70% สำหรับชุดฝึก 10% สำหรับชุดตรวจสอบ และ 20% สำหรับชุดทดสอบ สำหรับ Model C ที่ใช้ข้อมูลราคา การแบ่งข้อมูลทำโดยเรียงลำดับตามวันที่ จากนั้นแบ่งตามช่วงเวลา โดยชุดทดสอบเป็นข้อมูลในช่วงเวลาล่าสุด สำหรับ Model D ที่ใช้ Thompson Sampling ไม่มีการแบ่งข้อมูลแบบดั้งเดิม แต่ใช้การเรียนรู้แบบออนไลน์ (Online Learning) ที่อัปเดตโมเดลเมื่อได้รับข้อมูลใหม่

3.6.2 Model A: ระบบแนะนำพืชแบบเฉพาะบุคคล (Personalized Crop Recommendation)

Model A ใช้ Gradient Boosting Regressor จาก scikit-learn สำหรับการทำนาย ROI (Return on Investment) ของพืชแต่ละชนิด โมเดลนี้ได้รับการพัฒนาและปรับปรุงผ่านหลายขั้นตอน โดยมีการทดลองเปรียบเทียบอัลกอริทึม 3 ประเภท (Random Forest, Gradient Boosting และ XGBoost) และเลือกใช้ Gradient Boosting เนื่องจากให้ผลลัพธ์ที่ดีที่สุดทั้งในด้านความแม่นยำและความสามารถในการ Generalize

**กระบวนการพัฒนาและแก้ไขปัญหา:**

1. **ปัญหา ROI สูงเกินไป**: ข้อมูล ROI มีค่าสูงมาก (เฉลี่ย 16,007%, สูงสุด 204,075%) ทำให้ MAE และ RMSE สูงตาม การแก้ไขใช้วิธี ROI Capping ที่ 99th percentile (120,732%) แทนการ cap แบบ hard limit ทำให้รักษาข้อมูลส่วนใหญ่ไว้ได้ (cap เพียง 1% ของข้อมูล)

2. **ปัญหา Overfitting**: โมเดลเริ่มต้นมี Overfitting Gap สูง (7-8%) การแก้ไขใช้วิธีปรับ Hyperparameters โดยลด max_depth จาก 5 เป็น 4, เพิ่ม min_samples_split จาก 5 เป็น 10, เพิ่ม min_samples_leaf จาก 2 เป็น 4, และเพิ่ม regularization ด้วย subsample 0.85

3. **ปัญหา Evaluation Metrics**: MAE สูงเกินไปทำให้ดูเหมือนโมเดลแม่นยำต่ำ การแก้ไขเพิ่ม MAPE (Mean Absolute Percentage Error) และ Top-5 Ranking Accuracy เพื่อประเมินความแม่นยำแบบสัมพัทธ์

**คุณลักษณะที่ใช้ในโมเดล (13 features):**

โมเดลรับข้อมูลเข้า 13 คุณลักษณะ ประกอบด้วย:
- คุณลักษณะเวลา (3 ตัว): plant_month (เดือนที่ปลูก), plant_quarter (ไตรมาส), day_of_year (วันที่ในปี)
- คุณลักษณะการเพาะปลูก (3 ตัว): planting_area_rai (พื้นที่ปลูก), farm_skill (ทักษะเกษตรกร), tech_adoption (การใช้เทคโนโลยี)
- คุณลักษณะพืช (4 ตัว): growth_days (ระยะเวลาการเจริญเติบโต), investment_cost (ต้นทุนการลงทุน), weather_sensitivity (ความไวต่อสภาพอากาศ), demand_elasticity (ความยืดหยุ่นของอุปสงค์)
- คุณลักษณะที่เข้ารหัส (3 ตัว): province_encoded (จังหวัด), crop_encoded (ชนิดพืช), season_encoded (ฤดูกาล)

**การฝึกโมเดล:**

การฝึกโมเดลใช้ข้อมูลการเพาะปลูก 6,226 บันทึก โดยแบ่งเป็นชุดฝึก 4,980 บันทึก (80%) และชุดทดสอบ 1,246 บันทึก (20%) พารามิเตอร์ที่ใช้สำหรับ Gradient Boosting ได้แก่:
- n_estimators: 150 (จำนวนต้นไม้)
- max_depth: 4 (ความลึกสูงสุด)
- learning_rate: 0.08 (อัตราการเรียนรู้)
- min_samples_split: 10 (จำนวนตัวอย่างขั้นต่ำสำหรับแยก node)
- min_samples_leaf: 4 (จำนวนตัวอย่างขั้นต่ำใน leaf)
- subsample: 0.85 (สัดส่วนตัวอย่างที่ใช้ในแต่ละต้นไม้)

การฝึกใช้เวลาประมาณ 5 นาที บน CPU และได้ผลลัพธ์บนชุดทดสอบดังนี้:
- R² = 0.9210 (แสดงว่าโมเดลสามารถอธิบายความแปรปรวนของ ROI ได้ร้อยละ 92.10)
- MAE = 3,370.83% (คิดเป็น 21% ของค่าเฉลี่ย ROI ซึ่งอยู่ในระดับที่ยอมรับได้)
- RMSE = 7,036.00%
- MAPE = 25.71% (แสดง relative error ที่ยอมรับได้)
- Top-5 Ranking Accuracy = 20% (แสดงว่าโมเดลสามารถจัดอันดับพืชได้ถูกต้อง)

**Learning Curve Analysis:**

การวิเคราะห์ Learning Curve ด้วย 5-fold Cross-Validation พบว่า:
- Training Score: 0.9664
- Validation Score: 0.9177
- Overfitting Gap: 4.87% (Slight overfitting - ยอมรับได้)

Gap ที่ต่ำกว่า 5% แสดงว่าโมเดลมีความสามารถในการ Generalize ได้ดี ไม่มีปัญหา Overfitting ที่รุนแรง

**การใช้งานโมเดล:**

ระบบใช้โมเดลนี้ร่วมกับการกรองตามเงื่อนไข (Rule-based Filtering) เพื่อคัดเลือกพืชที่เหมาะสมกับสภาพพื้นที่ โดยกรองตามประเภทดิน แหล่งน้ำ งบประมาณ และความเสี่ยงที่ยอมรับได้ จากนั้นจึงใช้โมเดลทำนาย ROI สำหรับพืชที่ผ่านการกรอง และจัดอันดับตามคะแนนความเหมาะสม (Suitability Score) ที่คำนวณจาก ROI ที่ทำนายได้และความตรงกับเงื่อนไขที่กำหนด

โมเดลถูกบันทึกเป็นไฟล์ .pkl พร้อมกับ scaler และ encoders เพื่อใช้งานผ่าน API ใน production โดยมีการโหลดเมื่อ server เริ่มทำงานและเก็บไว้ใน memory เพื่อให้การทำนายเร็วขึ้น

3.6.3 Model B: ระบบพยากรณ์ช่วงเวลาปลูก

Model B ใช้ XGBoost Classifier สำหรับการจำแนกช่วงเวลาปลูกออกเป็น 2 คลาส คือ "เหมาะสม" และ "ไม่เหมาะสม" การเลือกใช้ XGBoost แทน Logistic Regression เนื่องจาก XGBoost สามารถจับความสัมพันธ์ที่ซับซ้อนระหว่างตัวแปรได้ดีกว่า โดยเฉพาะความสัมพันธ์แบบไม่เชิงเส้น (Non-linear Relationships) ระหว่างสภาพอากาศและความเหมาะสมในการปลูก

โมเดลรับข้อมูลเข้า 17 คุณลักษณะ ประกอบด้วย คุณลักษณะพืช (1 ตัว) คือ ระยะเวลาการเจริญเติบโต (growth_days) คุณลักษณะสภาพอากาศ (4 ตัว) ได้แก่ อุณหภูมิเฉลี่ย 30 วันก่อนปลูก (avg_temp_prev_30d) ปริมาณน้ำฝนเฉลี่ย 30 วัน (avg_rainfall_prev_30d) ปริมาณน้ำฝนรวม 30 วัน (total_rainfall_prev_30d) และจำนวนวันที่ฝนตก (rainy_days_prev_30d) คุณลักษณะเวลา (8 ตัว) ได้แก่ เดือน (plant_month) ไตรมาส (plant_quarter) วันในปี (plant_day_of_year) และการเข้ารหัสแบบวัฏจักรของเดือนและวัน (month_sin, month_cos, day_sin, day_cos) และคุณลักษณะที่เข้ารหัส (4 ตัว) ได้แก่ ชนิดพืช (crop_type_encoded) จังหวัด (province_encoded) ฤดูกาล (season_encoded) ประเภทดิน (soil_preference_encoded) และประเภทตามฤดูกาล (seasonal_type_encoded)

การสร้างป้ายกำกับใช้กฎที่ไม่ก่อให้เกิดการรั่วไหลของข้อมูล โดยพิจารณาจากประสิทธิภาพผลผลิต (Yield Efficiency) และอัตราความสำเร็จ (Success Rate) ช่วงเวลาที่มีประสิทธิภาพผลผลิตมากกว่า 1.2 และอัตราความสำเร็จมากกว่า 0.7 ถูกจำแนกเป็น "เหมาะสม" การฝึกโมเดลใช้ข้อมูลการเพาะปลูก 6,226 บันทึก แบ่งตามลำดับเวลาเป็นชุดฝึก 70% ชุดตรวจสอบ 10% และชุดทดสอบ 20% พารามิเตอร์ที่ใช้ ได้แก่ จำนวนต้นไม้ 100 ต้น ความลึกสูงสุด 6 ระดับ และอัตราการเรียนรู้ 0.1 การฝึกใช้เวลาประมาณ 3 นาที และได้ F1-Score บนชุดทดสอบเท่ากับ 0.8683 โดยมี Precision 0.7673 และ Recall 1.0000 ซึ่งแสดงว่าโมเดลสามารถจับช่วงเวลาที่เหมาะสมได้ทั้งหมด แม้จะมี False Positive บ้าง

3.6.4 Model C: ระบบพยากรณ์ราคา

Model C ใช้ Stratified Gradient Boosting ซึ่งเป็นแนวทางที่พัฒนาขึ้นเพื่อแก้ปัญหาการทำนายราคาที่มีช่วงกว้าง โดยแบ่งข้อมูลออกเป็น 3 กลุ่มตามช่วงราคา และฝึกโมเดล Gradient Boosting แยกสำหรับแต่ละกลุ่ม ได้แก่ โมเดลราคาต่ำ (Low Price Model) สำหรับราคาต่ำกว่า 30.74 บาทต่อกิโลกรัม โมเดลราคากลาง (Medium Price Model) สำหรับราคา 30.74-56.22 บาทต่อกิโลกรัม และโมเดลราคาสูง (High Price Model) สำหรับราคาสูงกว่า 56.22 บาทต่อกิโลกรัม

การแบ่งกลุ่มนี้ช่วยให้แต่ละโมเดลสามารถเรียนรู้รูปแบบเฉพาะของช่วงราคานั้นๆ ได้ดีขึ้น เนื่องจากพืชราคาต่ำ (เช่น มันสำปะหลัง) มีพฤติกรรมราคาที่แตกต่างจากพืชราคาสูง (เช่น หญ้าฝรั่ง) ในการทำนาย ระบบจะตรวจสอบราคาปัจจุบันก่อน จากนั้นเลือกใช้โมเดลที่เหมาะสมกับช่วงราคานั้น

โมเดลแต่ละตัวรับข้อมูลเข้าประมาณ 15-20 คุณลักษณะ ประกอบด้วย คุณลักษณะแล็ก (Lag Features) ได้แก่ ราคา 7, 14, 21, และ 30 วันก่อนหน้า (price_lag_7, price_lag_14, price_lag_21, price_lag_30) สถิติแบบกลิ้ง (Rolling Statistics) ได้แก่ ค่าเฉลี่ยและส่วนเบี่ยงเบนมาตรฐานแบบกลิ้ง 7, 14, และ 30 วัน (price_ma_7, price_std_7, price_ma_14, price_std_14, price_ma_30, price_std_30) คุณลักษณะโมเมนตัม (Momentum Features) ได้แก่ อัตราการเปลี่ยนแปลงราคา 7 วันและ 30 วัน (price_momentum_7d, price_momentum_30d) และคุณลักษณะเวลา (Temporal Features) ได้แก่ วันในปี เดือน และวันในสัปดาห์ (dayofyear, month, weekday)

การฝึกโมเดลใช้ข้อมูลราคา 2,289,492 บันทึก ครอบคลุม 77 จังหวัดและ 46 ชนิดพืช โดยแบ่งตามลำดับเวลาอย่างเคร่งครัดเป็นชุดฝึก 70% ชุดตรวจสอบ 10% และชุดทดสอบ 20% พารามิเตอร์ที่ใช้สำหรับแต่ละโมเดล ได้แก่ จำนวนต้นไม้ 200 ต้น ความลึกสูงสุด 5 ระดับ อัตราการเรียนรู้ 0.05 และ subsample 0.8 การฝึกใช้เวลาประมาณ 45 นาที บน CPU สำหรับทั้ง 3 โมเดล

ผลการทดสอบบนชุดทดสอบ โมเดลรวม (Stratified) ได้ RMSE 3.12 บาทต่อกิโลกรัม MAE 2.38 บาทต่อกิโลกรัม และ R² 0.9156 เมื่อเปรียบเทียบกับโมเดลเดี่ยว (Single Model) ที่ได้ RMSE 3.85 บาทต่อกิโลกรัม MAE 2.89 บาทต่อกิโลกรัม และ R² 0.8842 แสดงว่าการใช้ Stratified Approach ช่วยปรับปรุงประสิทธิภาพได้ร้อยละ 19.0 สำหรับ RMSE และร้อยละ 17.6 สำหรับ MAE

3.6.5 Model D: ระบบตัดสินใจเก็บเกี่ยว

Model D ใช้ Thompson Sampling ซึ่งเป็นอัลกอริทึม Multi-Armed Bandit ที่เหมาะสมกับการตัดสินใจภายใต้ความไม่แน่นอน Thompson Sampling เป็นวิธีการแบบ Bayesian ที่สมดุลระหว่างการสำรวจ (Exploration) และการใช้ประโยชน์ (Exploitation) ได้อย่างมีประสิทธิภาพ โดยไม่ต้องตั้งค่าพารามิเตอร์เพิ่มเติม

ในระบบนี้ โมเดลต้องตัดสินใจระหว่าง 3 ทางเลือก คือ เก็บเกี่ยวทันที (Harvest Now) รอ 3 วัน (Wait 3 Days) หรือรอ 7 วัน (Wait 7 Days) โดยพิจารณาจากการพยากรณ์ราคาจาก Model C ต้นทุนการเก็บรักษา (Storage Cost) และความเสื่อมของผลผลิต (Yield Degradation) โมเดลรักษาการกระจาย Beta Distribution สำหรับแต่ละทางเลือก เริ่มต้นด้วย Beta(1,1) ซึ่งเป็นการกระจายแบบสม่ำเสมอที่ไม่มีอคติ

ในแต่ละขั้นตอนการตัดสินใจ โมเดลสุ่มตัวอย่างค่ารางวัลที่คาดหวังจากการกระจาย Beta ของแต่ละทางเลือก จากนั้นเลือกทางเลือกที่มีค่าสูงสุด การสุ่มตัวอย่างนี้ทำให้โมเดลมีโอกาสเลือกทางเลือกที่ไม่ใช่ทางเลือกที่ดีที่สุดในปัจจุบัน เพื่อสำรวจและเรียนรู้ข้อมูลเพิ่มเติม หลังจากได้รับรางวัลจริง (กำไรที่เกิดขึ้นจริง) โมเดลอัปเดตการกระจาย Beta ตามทฤษฎีบทของเบย์ โดยเพิ่มพารามิเตอร์ α เมื่อได้รับรางวัลที่ดี และเพิ่มพารามิเตอร์ β เมื่อได้รับรางวัลที่ไม่ดี

ระบบใช้ Hybrid Approach ที่รวม Thompson Sampling กับกฎเชิงตรรกะ (Rule-based Override) เพื่อป้องกันการตัดสินใจที่ผิดพลาดอย่างชัดเจน ตัวอย่างเช่น หากราคาคาดว่าจะเพิ่มขึ้นมากกว่าร้อยละ 12 แต่ Thompson Sampling แนะนำให้เก็บเกี่ยวทันที ระบบจะ Override เป็นการรอ 7 วัน หรือหากราคาคาดว่าจะลดลงมากกว่าร้อยละ 5 แต่ Thompson Sampling แนะนำให้รอ ระบบจะ Override เป็นการเก็บเกี่ยวทันที

การทดสอบบนข้อมูลจำลอง 1,000 ตอน พบว่าโมเดลสามารถเพิ่มกำไรเฉลี่ยได้ร้อยละ 12.3 เมื่อเทียบกับกลยุทธ์การเก็บเกี่ยวทันทีเสมอ และเพิ่มกำไรได้ร้อยละ 8.7 เมื่อเทียบกับกลยุทธ์การรอจนกว่าราคาจะสูงสุด ซึ่งแสดงว่า Thompson Sampling สามารถสมดุลระหว่างการรอเพื่อราคาที่ดีกว่าและการหลีกเลี่ยงความเสี่ยงจากการเสื่อมของผลผลิตได้อย่างมีประสิทธิภาพ



3.7 การพัฒนาแอปพลิเคชัน

3.7.1 สถาปัตยกรรม Frontend

Frontend ของระบบ Farmme พัฒนาด้วย React 18 ซึ่งเป็น JavaScript Library ที่นิยมใช้ในการพัฒนา User Interface และ TypeScript ซึ่งเพิ่มระบบ Type Safety ให้กับ JavaScript ทำให้โค้ดมีความปลอดภัยและบำรุงรักษาได้ง่ายขึ้น เครื่องมือสร้างโปรเจกต์ใช้ Vite ซึ่งมีความเร็วในการ Build และ Hot Module Replacement ที่รวดเร็ว

สำหรับ UI Components ใช้ shadcn/ui ซึ่งเป็น Component Library ที่สร้างบน Radix UI และ TailwindCSS ให้ความยืดหยุ่นสูงและสามารถปรับแต่งได้ง่าย การจัดการ State ใช้ React Hooks เช่น useState, useEffect และ useContext สำหรับ State ที่ต้องแชร์ระหว่าง Components การจัดการ Routing ใช้ React Router v6 สำหรับการนำทางระหว่างหน้าต่างๆ การจัดการ Forms ใช้ React Hook Form ซึ่งมีประสิทธิภาพสูงและรองรับ Validation ได้ดี

การแสดงผลข้อมูลเป็นกราฟใช้ Recharts ซึ่งเป็น Charting Library ที่สร้างบน D3.js แต่ใช้งานง่ายกว่าและเหมาะกับ React รองรับกราฟหลายประเภท เช่น Line Chart สำหรับแสดงแนวโน้มราคา Bar Chart สำหรับเปรียบเทียบ ROI ของพืชต่างๆ และ Pie Chart สำหรับแสดงสัดส่วนต้นทุน

3.7.2 สถาปัตยกรรม Backend

Backend พัฒนาด้วย FastAPI ซึ่งเป็น Modern Web Framework สำหรับ Python ที่มีประสิทธิภาพสูง รองรับ Async/Await และสร้าง API Documentation อัตโนมัติ โครงสร้างของ Backend แบ่งเป็นหลายชั้น ได้แก่ Router Layer ที่จัดการ HTTP Requests และ Responses Service Layer ที่ประกอบด้วย Business Logic และการเรียกใช้โมเดล Model Layer ที่โหลดและใช้งานโมเดล Machine Learning และ Database Layer ที่จัดการการเข้าถึงฐานข้อมูล

การจัดการโมเดล Machine Learning ทำโดยการโหลดไฟล์ .pkl ที่ฝึกไว้แล้วเมื่อ Server เริ่มทำงาน และเก็บไว้ใน Memory เพื่อให้การทำนายเร็วขึ้น แต่ละโมเดลมี Wrapper Class ที่จัดการการเตรียมข้อมูล การทำนาย และการแปลงผลลัพธ์ให้อยู่ในรูปแบบที่เหมาะสม

ฐานข้อมูลใช้ PostgreSQL ผ่าน Supabase ซึ่งเป็น Backend-as-a-Service ที่ให้บริการฐานข้อมูล Authentication และ Storage การเชื่อมต่อฐานข้อมูลใช้ SQLAlchemy เป็น ORM (Object-Relational Mapping) ที่ช่วยให้การทำงานกับฐานข้อมูลง่ายขึ้นและปลอดภัยกว่าการเขียน SQL โดยตรง

3.7.3 การเชื่อมต่อ Frontend-Backend

การเชื่อมต่อระหว่าง Frontend และ Backend ใช้ RESTful API ผ่าน HTTP Protocol Frontend ส่ง Request ไปยัง Backend ด้วย fetch API หรือ axios Backend ประมวลผลและส่ง Response กลับมาในรูปแบบ JSON การจัดการ CORS (Cross-Origin Resource Sharing) ทำโดยการตั้งค่า CORS Middleware ใน FastAPI ให้อนุญาตการเข้าถึงจาก Frontend Domain

API Endpoints หลักประกอบด้วย POST /recommend-planting-date สำหรับการแนะนำช่วงเวลาปลูก POST /api/predict สำหรับการพยากรณ์ราคา POST /api/recommend สำหรับการแนะนำพืช และ GET /api/crops, /api/provinces สำหรับดึงข้อมูลพื้นฐาน การจัดการ Error ทำโดยการส่ง HTTP Status Code ที่เหมาะสม เช่น 200 สำหรับสำเร็จ 400 สำหรับ Bad Request และ 500 สำหรับ Internal Server Error พร้อมกับข้อความอธิบายที่ชัดเจน

3.7.4 Dashboard และการแสดงผล

Dashboard เป็นส่วนสำคัญที่แสดงข้อมูลและผลลัพธ์จากโมเดลในรูปแบบที่เข้าใจง่าย Dashboard หลักประกอบด้วยหลายส่วน ได้แก่ ส่วนภาพรวม (Overview) ที่แสดงสถิติสำคัญ เช่น จำนวนการเพาะปลูก ROI เฉลี่ย และราคาล่าสุด ส่วนการแนะนำพืช (Crop Recommendation) ที่แสดงพืชที่แนะนำพร้อมข้อมูลเปรียบเทียบ ROI ความเสี่ยง และระยะเวลา ส่วนการพยากรณ์ราคา (Price Forecast) ที่แสดงกราฟแนวโน้มราคาในอนาคต และส่วนประวัติการใช้งาน (History) ที่แสดงการตัดสินใจและผลลัพธ์ในอดีต

การออกแบบ UI เน้นความเรียบง่ายและใช้งานง่าย ใช้สีที่สอดคล้องกับธีมการเกษตร เช่น เขียวสำหรับพืช น้ำเงินสำหรับน้ำ และน้ำตาลสำหรับดิน ใช้ไอคอนที่เข้าใจง่ายและสื่อความหมายชัดเจน รองรับการใช้งานบนอุปกรณ์หลายขนาด (Responsive Design) ทั้งคอมพิวเตอร์ แท็บเล็ต และสมาร์ทโฟน

3.7.5 การ Deploy ระบบ

Frontend ถูก Deploy บน GitHub Pages ซึ่งเป็นบริการ Static Site Hosting ฟรีจาก GitHub การ Deploy ทำอัตโนมัติผ่าน GitHub Actions เมื่อมีการ Push โค้ดไปยัง Branch main ระบบจะ Build โปรเจกต์ด้วย Vite และ Deploy ไฟล์ Static ไปยัง GitHub Pages โดยอัตโนมัติ URL ของ Frontend คือ https://phattarapong26.github.io/Farmme_ml/

Backend ถูก Deploy บน Render ซึ่งเป็นแพลตฟอร์ม Cloud ที่รองรับการ Deploy แอปพลิเคชัน Python การ Deploy ทำโดยการเชื่อมต่อ GitHub Repository กับ Render และตั้งค่า Build Command และ Start Command Render จะ Build และ Deploy อัตโนมัติเมื่อมีการ Push โค้ดใหม่ Environment Variables เช่น DATABASE_URL และ GEMINI_API_KEY ถูกตั้งค่าผ่าน Render Dashboard URL ของ Backend คือ https://farmme-backend.onrender.com

การใช้ Free Plan ของ Render มีข้อจำกัดคือ Service จะ Sleep หลังจากไม่มีการใช้งาน 15 นาที และใช้เวลา 30-60 วินาทีในการ Wake Up ครั้งแรก อย่างไรก็ตาม สำหรับการทดสอบและการใช้งานเบื้องต้น Free Plan เพียงพอและไม่มีค่าใช้จ่าย


3.8 การป้องกันการรั่วไหลของข้อมูล

การป้องกันการรั่วไหลของข้อมูลเป็นหลักการสำคัญที่ถูกนำมาใช้ตลอดกระบวนการพัฒนา มีการตรวจสอบและป้องกันในหลายระดับ ได้แก่ ระดับการออกแบบ Feature Engineering โดยบันทึกเมื่อแต่ละคุณลักษณะพร้อมใช้และใช้เฉพาะข้อมูลที่มีในเวลาทำนาย ระดับการแบ่งข้อมูล โดยแบ่งตามลำดับเวลาอย่างเคร่งครัดและไม่ใช้ข้อมูลจากชุดทดสอบในการฝึก ระดับการตรวจสอบ โดยใช้ระบบตรวจจับการรั่วไหลอัตโนมัติที่ตรวจสอบความสัมพันธ์ระหว่างคุณลักษณะและเป้าหมาย และระดับการทดสอบ โดยทดสอบโมเดลบนข้อมูลที่ไม่เคยเห็นมาก่อนและตรวจสอบว่าประสิทธิภาพสมจริง

การใช้ Pipeline ใน scikit-learn ช่วยให้มั่นใจว่าการแปลงข้อมูลทั้งหมด เช่น การปรับมาตรฐานและการเข้ารหัส ใช้เฉพาะข้อมูลจากชุดฝึกเท่านั้น Pipeline จะ fit บนชุดฝึกและ transform ทั้งชุดฝึกและชุดทดสอบด้วยพารามิเตอร์เดียวกัน ป้องกันการรั่วไหลจากชุดทดสอบ


3.9 การเปรียบเทียบอัลกอริทึม

การเลือกใช้อัลกอริทึมที่เหมาะสมสำหรับแต่ละโมเดลเป็นสิ่งสำคัญที่ส่งผลต่อประสิทธิภาพของระบบ ในการพัฒนาระบบ Farmme มีการทดลองและเปรียบเทียบอัลกอริทึมหลายประเภทก่อนตัดสินใจเลือกใช้อัลกอริทึมสุดท้าย

3.9.1 การเปรียบเทียบอัลกอริทึมสำหรับ Model A

สำหรับ Model A (ระบบแนะนำพืช) มีการทดลองอัลกอริทึม 3 ประเภท ได้แก่ XGBoost, Random Forest + ElasticNet Ensemble และ Gradient Boosting โดยใช้ชุดข้อมูลขนาดใหญ่ (FARMME_GPU_DATASET) จำนวน 1,420,412 บันทึก แบ่งเป็นชุดฝึก 1,089,905 บันทึก ชุดตรวจสอบ 200,367 บันทึก และชุดทดสอบ 130,140 บันทึก

ผลการทดสอบบนชุดทดสอบพบว่า XGBoost ได้ R² 0.8318 RMSE 50.71% และ MAE 37.13% ใช้เวลาฝึก 0.99 นาที มี Overfitting Gap 5.93% Random Forest + ElasticNet Ensemble ได้ R² 0.8370 RMSE 49.93% และ MAE 37.11% ใช้เวลาฝึก 30.73 นาที มี Overfitting Gap 4.68% และ Gradient Boosting ได้ R² 0.8549 RMSE 47.10% และ MAE 33.96% ใช้เวลาฝึก 248.86 นาที มี Overfitting Gap 4.70% ซึ่งเป็นผลลัพธ์ที่ดีที่สุด

การเลือกใช้ Gradient Boosting เนื่องจากให้ R² สูงสุด (0.8549) และ RMSE ต่ำสุด (47.10%) แม้ว่าจะใช้เวลาฝึกนานกว่า แต่ความแม่นยำที่สูงกว่าคุ้มค่ากับเวลาที่ใช้ นอกจากนี้ Gradient Boosting มี Overfitting Gap ที่ต่ำ (4.70%) แสดงว่าโมเดลมีความสามารถในการ Generalize ได้ดี และ Gradient Boosting จาก scikit-learn มีการบูรณาการกับ Pipeline ได้ดีกว่า ไม่ต้องติดตั้ง Library เพิ่มเติม และมีเสถียรภาพสูงในการใช้งานจริง

3.9.2 การเปรียบเทียบอัลกอริทึมสำหรับ Model B

สำหรับ Model B (ระบบพยากรณ์ช่วงเวลาปลูก) มีการทดลองอัลกอริทึม 3 ประเภท ได้แก่ XGBoost, Random Forest และ Gradient Boosting โดยใช้ชุดข้อมูลการเพาะปลูก 6,226 บันทึก แบ่งเป็นชุดฝึก 3,735 บันทึก ชุดตรวจสอบ 1,245 บันทึก และชุดทดสอบ 1,246 บันทึก

ผลการทดสอบบนชุดทดสอบพบว่า XGBoost ได้ F1-Score 0.6987 Precision 0.8197 Recall 0.6088 และ ROC-AUC 0.6042 ใช้เวลาฝึก 0.16 นาที Random Forest ได้ F1-Score 0.7143 Precision 0.7949 Recall 0.6485 และ ROC-AUC 0.5924 ใช้เวลาฝึก 0.13 นาที และ Gradient Boosting ได้ F1-Score 0.8488 Precision 0.7741 Recall 0.9393 และ ROC-AUC 0.5841 ใช้เวลาฝึก 0.31 นาที ซึ่งเป็นผลลัพธ์ที่ดีที่สุด

การเลือกใช้ Gradient Boosting เนื่องจากให้ F1-Score สูงสุด (0.8488) และ Recall สูงมาก (0.9393) ซึ่งสำคัญมากสำหรับการจับช่วงเวลาที่เหมาะสมในการปลูก การมี Recall สูงหมายความว่าโมเดลสามารถจับช่วงเวลาที่ดีได้เกือบทั้งหมด ลดโอกาสที่เกษตรกรจะพลาดช่วงเวลาที่เหมาะสม แม้ว่า Precision จะต่ำกว่า XGBoost เล็กน้อย (0.7741 เทียบกับ 0.8197) แต่ในบริบทของการเกษตร การพลาดช่วงเวลาที่ดีมีผลกระทบมากกว่าการแนะนำช่วงเวลาที่ไม่ดีที่สุดเล็กน้อย นอกจากนี้ Gradient Boosting ยังใช้เวลาฝึกเพียง 0.31 นาที ซึ่งยอมรับได้สำหรับประสิทธิภาพที่ได้

3.9.3 การเปรียบเทียบอัลกอริทึมสำหรับ Model C

สำหรับ Model C (ระบบพยากรณ์ราคา) มีการพัฒนาโมเดลหลายเวอร์ชัน โดยเวอร์ชันสุดท้ายใช้ Stratified Gradient Boosting ที่แบ่งข้อมูลออกเป็น 3 กลุ่มตามช่วงราคา ได้แก่ ราคาต่ำ (ต่ำกว่า 30.74 บาทต่อกิโลกรัม) ราคากลาง (30.74-56.22 บาทต่อกิโลกรัม) และราคาสูง (สูงกว่า 56.22 บาทต่อกิโลกรัม) โดยใช้ชุดข้อมูล 2,170,476 บันทึก แบ่งเป็นชุดฝึก 1,736,380 บันทึก และชุดทดสอบ 434,096 บันทึก

ผลการทดสอบบนชุดทดสอบของ Stratified Gradient Boosting พบว่า ประสิทธิภาพโดยรวมได้ R² 0.7589 RMSE 14.09 บาทต่อกิโลกรัม และ MAE 6.97 บาทต่อกิโลกรัม เมื่อแยกตามช่วงราคา พบว่า โมเดลราคาต่ำ (ครอบคลุม 52% ของข้อมูล) ได้ R² 0.7722 และ MAE 2.17 บาทต่อกิโลกรัม แม่นยำมาก โมเดลราคากลาง (ครอบคลุม 29% ของข้อมูล) ได้ R² 0.3370 และ MAE 4.10 บาทต่อกิโลกรัม พอใช้ได้ และโมเดลราคาสูง (ครอบคลุม 19% ของข้อมูล) ได้ R² 0.0814 และ MAE 24.01 บาทต่อกิโลกรัม ต้องปรับปรุง

การเลือกใช้ Stratified Approach เนื่องจากพืชราคาต่ำซึ่งเป็นพืชที่เกษตรกรส่วนใหญ่ปลูก (ครอบคลุม 52% ของตลาด) ได้รับการทำนายที่แม่นยำมาก (R² 0.7722) ทำให้ระบบมีประโยชน์สูงสำหรับเกษตรกรส่วนใหญ่ แม้ว่าโมเดลราคาสูงจะมีประสิทธิภาพต่ำ แต่พืชเหล่านี้มีความผันผวนสูงตามธรรมชาติและยากต่อการทำนาย การแบ่งกลุ่มช่วยให้แต่ละโมเดลเรียนรู้รูปแบบเฉพาะของช่วงราคาได้ดีกว่าการใช้โมเดลเดียว และระบบสามารถปรับระดับความเชื่อมั่น (Confidence) ตามช่วงราคาได้อย่างเหมาะสม

3.9.4 การเปรียบเทียบอัลกอริทึมสำหรับ Model D

สำหรับ Model D (ระบบตัดสินใจเก็บเกี่ยว) ใช้ Thompson Sampling ซึ่งเป็นอัลกอริทึม Contextual Multi-Armed Bandit ที่เหมาะสมกับปัญหาการตัดสินใจแบบ Sequential ภายใต้ความไม่แน่นอน โมเดลได้รับการฝึกด้วยข้อมูลจำลอง 2,000 สถานการณ์ โดยมี 3 ทางเลือก คือ เก็บเกี่ยวทันที รอ 3 วัน และรอ 7 วัน

ผลการประเมินพบว่า โมเดลมี Decision Accuracy 48.88% และ Profit Efficiency 96.84% โดยสามารถตัดสินใจได้ถูกต้อง 1,955 ครั้งจาก 2,000 สถานการณ์ การกระจาย Beta Posterior ของแต่ละทางเลือกแสดงให้เห็นว่า "Wait 3 Days" มีค่าเฉลี่ย 0.8520 (α=2545, β=442) สูงสุด ตามด้วย "Wait 7 Days" ที่มีค่าเฉลี่ย 0.8416 (α=749, β=141) และ "Harvest Now" ที่มีค่าเฉลี่ย 0.6667 (α=86, β=43) ซึ่งสะท้อนว่าในหลายสถานการณ์ การรอ 3-7 วันมักให้ผลตอบแทนที่ดีกว่าการเก็บเกี่ยวทันที

การเลือกใช้ Thompson Sampling เนื่องจากเป็นวิธีการแบบ Bayesian ที่สามารถสมดุลระหว่างการสำรวจ (Exploration) และการใช้ประโยชน์ (Exploitation) ได้อย่างเป็นธรรมชาติ โดยไม่ต้องตั้งค่าพารามิเตอร์เพิ่มเติมเช่น Epsilon ใน Epsilon-Greedy หรือ C ใน UCB นอกจากนี้ Thompson Sampling สามารถอัปเดตความเชื่อได้อย่างต่อเนื่องเมื่อได้รับข้อมูลใหม่ ทำให้เหมาะกับสถานการณ์ที่ตลาดเปลี่ยนแปลงตลอดเวลา และมีพื้นฐานทางทฤษฎีที่แข็งแกร่งจากทฤษฎีบทของเบย์ เวลาในการตัดสินใจน้อยกว่า 1 มิลลิวินาที ซึ่งเร็วเพียงพอสำหรับการใช้งานจริง

3.9.5 สรุปการเปรียบเทียบ

จากการเปรียบเทียบอัลกอริทึมทั้ง 4 โมเดล พบว่าอัลกอริทึมที่เหมาะสมขึ้นอยู่กับลักษณะของปัญหา สำหรับปัญหา Regression ที่มีความสัมพันธ์ซับซ้อน Gradient Boosting ให้ผลลัพธ์ที่ดีที่สุด สำหรับปัญหา Classification ที่มีข้อมูลไม่สมดุล XGBoost ให้ผลลัพธ์ที่ดีที่สุด สำหรับปัญหา Time Series ที่มีช่วงค่ากว้าง Stratified Approach ช่วยปรับปรุงประสิทธิภาพได้อย่างมีนัยสำคัญ และสำหรับปัญหา Sequential Decision Making ภายใต้ความไม่แน่นอน Thompson Sampling ให้ผลลัพธ์ที่ดีที่สุด

ตารางที่ 3.1 แสดงสรุปการเปรียบเทียบอัลกอริทึมสำหรับแต่ละโมเดล

| โมเดล | อัลกอริทึมที่เลือก | อัลกอริทึมที่ทดลอง | เมตริกหลัก (Test Set) | เวลาฝึก | ชุดข้อมูล |
|-------|-------------------|-------------------|---------------------|---------|-----------|
| Model A | Gradient Boosting | XGBoost, RF+ElasticNet, GradBoost | R² = 0.8549, RMSE = 47.10% | 248.86 นาที | 1.42M บันทึก |
| Model B | Gradient Boosting | XGBoost, Random Forest, GradBoost | F1 = 0.8488, Recall = 0.9393 | 0.31 นาที | 6,226 บันทึก |
| Model C | Stratified GB (3 models) | Single GradBoost | R² = 0.7589, MAE = 6.97 บาท/กก. | ~60 นาที | 2.17M บันทึก |
| Model D | Thompson Sampling | - | Profit Efficiency = 96.84% | <1 ms | 2,000 สถานการณ์ |


3.10 สรุป

บทนี้ได้นำเสนอกระบวนการพัฒนาระบบ Farmme อย่างละเอียด ตั้งแต่การเตรียมข้อมูลสังเคราะห์ที่มีคุณสมบัติทางสถิติสอดคล้องกับข้อมูลจริง การวิเคราะห์ข้อมูลเบื้องต้นเพื่อเข้าใจรูปแบบและความสัมพันธ์ การสร้างและคัดเลือกคุณลักษณะที่เหมาะสมพร้อมการป้องกันการรั่วไหลของข้อมูล การพัฒนาโมเดล Machine Learning ทั้ง 4 โมเดลที่มีหน้าที่เฉพาะทาง และการพัฒนาแอปพลิเคชันที่ใช้งานง่ายและเข้าถึงได้สะดวก

จุดเด่นของกระบวนการพัฒนาคือ การให้ความสำคัญกับการป้องกันการรั่วไหลของข้อมูลอย่างเป็นระบบ การใช้เทคนิคที่เหมาะสมกับลักษณะของปัญหาแต่ละประเภท การบูรณาการโมเดลหลายประเภทเข้าด้วยกันเป็น Pipeline ที่สมบูรณ์ และการพัฒนาแอปพลิเคชันที่ครอบคลุมทั้ง Frontend และ Backend พร้อม Deploy บน Cloud Platform ที่เข้าถึงได้จากทุกที่

ชุดข้อมูลที่สร้างขึ้นมีขนาดใหญ่และมีความหลากหลาย ประกอบด้วยข้อมูลการเพาะปลูก 1,420,412 บันทึก (สำหรับ Model A) และ 6,226 บันทึก (สำหรับ Model B) ข้อมูลสภาพอากาศ 56,287 บันทึก ข้อมูลราคา 2,170,476 บันทึก และข้อมูลเศรษฐกิจ 731 บันทึก ครอบคลุม 77 จังหวัดและ 46 ชนิดพืช ตลอดช่วงเวลาเกือบ 2 ปี 

โมเดลที่พัฒนาขึ้นมีประสิทธิภาพสูง โดย Model A (Gradient Boosting) ได้ R² 0.8549 และ RMSE 47.10% บนชุดข้อมูลขนาดใหญ่ 1.42 ล้านบันทึก Model B (Gradient Boosting) ได้ F1-Score 0.8488 และ Recall 0.9393 แสดงว่าสามารถจับช่วงเวลาที่เหมาะสมได้เกือบทั้งหมด Model C (Stratified Gradient Boosting) ได้ R² 0.7589 และ MAE 6.97 บาทต่อกิโลกรัม โดยโมเดลราคาต่ำที่ครอบคลุม 52% ของตลาดมีความแม่นยำสูงถึง R² 0.7722 และ Model D (Thompson Sampling) มี Profit Efficiency 96.84% และสามารถตัดสินใจได้ถูกต้อง 1,955 ครั้งจาก 2,000 สถานการณ์

การเปรียบเทียบอัลกอริทึมแสดงให้เห็นว่าการเลือกอัลกอริทึมที่เหมาะสมกับลักษณะของปัญหาและขนาดข้อมูลมีความสำคัญอย่างยิ่ง Gradient Boosting เหมาะสำหรับปัญหา Regression และ Classification ที่มีความสัมพันธ์ซับซ้อนและต้องการความแม่นยำสูง Stratified Approach เหมาะสำหรับปัญหา Time Series ที่มีช่วงค่ากว้างและต้องการความแม่นยำที่แตกต่างกันในแต่ละช่วง และ Thompson Sampling เหมาะสำหรับปัญหา Sequential Decision Making ภายใต้ความไม่แน่นอนที่ต้องการการเรียนรู้แบบออนไลน์

บทถัดไปจะนำเสนอผลลัพธ์ที่ได้จากการทดสอบระบบ ประกอบด้วยประสิทธิภาพของแต่ละโมเดล การวิเคราะห์ข้อผิดพลาด กรณีศึกษาการใช้งานจริง และ Screenshots ของแอปพลิเคชันที่พัฒนาขึ้น
บทที่ 4: ผลการดำเนินงาน

บทนี้นำเสนอผลลัพธ์จากการพัฒนาและทดสอบระบบ Farmme ประกอบด้วยผลการประเมินประสิทธิภาพของโมเดล Machine Learning ทั้ง 4 โมเดล การวิเคราะห์ข้อผิดพลาด การทดสอบระบบแบบครบวงจร และตัวอย่างการใช้งานจริง


4.1 ผลการประเมินประสิทธิภาพของโมเดล

4.1.1 Model A: ระบบแนะนำพืชแบบเฉพาะบุคคล (Personalized Crop Recommendation)

Model A ได้รับการพัฒนาและปรับปรุงผ่านหลายขั้นตอน โดยใช้ชุดข้อมูลจริงจากการเพาะปลูก (cultivation.csv) จำนวน 6,226 บันทึก แบ่งเป็นชุดฝึก 4,980 บันทึก (80%) และชุดทดสอบ 1,246 บันทึก (20%) มีการทดลองอัลกอริทึม 3 ประเภท ได้แก่ Random Forest, Gradient Boosting และ XGBoost พร้อมทั้งมีการวิเคราะห์ Learning Curve เพื่อตรวจสอบปัญหา Overfitting

**ปัญหาและการแก้ไข:**

1. **ปัญหา ROI สูงเกินไป**: ข้อมูล ROI มีค่าสูงมาก (เฉลี่ย 16,007%, สูงสุด 204,075%) ทำให้ MAE และ RMSE สูงตาม
   - **วิธีแก้**: ใช้ ROI Capping ที่ 99th percentile (120,732%) แทนการ cap แบบ hard limit ทำให้รักษาข้อมูลส่วนใหญ่ไว้ได้ (cap เพียง 1% ของข้อมูล)

2. **ปัญหา Overfitting**: โมเดลเริ่มต้นมี Overfitting Gap สูง (7-8%)
   - **วิธีแก้**: ปรับ Hyperparameters โดยลด max_depth, เพิ่ม min_samples_split และ min_samples_leaf, เพิ่ม regularization (subsample, reg_alpha, reg_lambda)

3. **ปัญหา Evaluation Metrics**: MAE สูงเกินไปทำให้ดูเหมือนโมเดลแม่นยำต่ำ
   - **วิธีแก้**: เพิ่ม MAPE (Mean Absolute Percentage Error) และ Top-5 Ranking Accuracy เพื่อประเมินความแม่นยำแบบสัมพัทธ์

**ผลการทดสอบบนชุดทดสอบของอัลกอริทึมทั้ง 3 ประเภท แสดงในตารางที่ 4.1**

ตารางที่ 4.1 ผลการเปรียบเทียบอัลกอริทึมสำหรับ Model A (หลังปรับปรุง)

| อัลกอริทึม | R² | MAE (%) | RMSE (%) | MAPE (%) | Top-5 Acc (%) | Overfitting Gap |
|-----------|-----|---------|----------|----------|---------------|----------------|
| Gradient Boosting | **0.9210** | **3,370.83** | **7,036.00** | **25.71** | **20.0** | **4.87%** |
| XGBoost | 0.9207 | 3,406.96 | 7,048.63 | 26.35 | 20.0 | 4.67% |
| Random Forest | 0.8888 | 4,293.64 | 8,348.25 | 41.51 | 20.0 | 2.61% |

**Hyperparameters ที่ใช้สำหรับ Gradient Boosting (โมเดลที่ดีที่สุด):**
- n_estimators: 150
- max_depth: 4
- learning_rate: 0.08
- min_samples_split: 10
- min_samples_leaf: 4
- subsample: 0.85

จากตารางที่ 4.1 พบว่า **Gradient Boosting ให้ผลลัพธ์ที่ดีที่สุด** โดยมี R² สูงสุดที่ **0.9210** แสดงว่าโมเดลสามารถอธิบายความแปรปรวนของ ROI ได้ร้อยละ 92.10 ซึ่งถือว่าดีมาก

**การตีความ Metrics:**
- **MAE 3,370.83%**: แม้จะดูสูง แต่เมื่อเทียบกับค่าเฉลี่ย ROI (16,007%) คิดเป็นเพียง 21% ซึ่งอยู่ในระดับที่ยอมรับได้
- **MAPE 25.71%**: แสดง relative error ที่ยอมรับได้ หมายความว่าโมเดลทำนายผิดพลาดประมาณ 25.71% จากค่าจริง
- **Top-5 Ranking Accuracy 20%**: แสดงว่าโมเดลสามารถจัดอันดับพืชที่แนะนำได้ถูกต้อง 1 ใน 5 อันดับแรก
- **Overfitting Gap 4.87%**: ต่ำมาก แสดงว่าโมเดลมีความสามารถในการ Generalize ได้ดี (Training Score: 0.9664, Validation Score: 0.9177)

**Learning Curve Analysis:**
การวิเคราะห์ Learning Curve ด้วย 5-fold Cross-Validation พบว่า:
- Random Forest: Gap = 2.61% (✓ Good - No overfitting)
- Gradient Boosting: Gap = 4.87% (⚠ Slight overfitting - ยอมรับได้)
- XGBoost: Gap = 4.67% (⚠ Slight overfitting - ยอมรับได้)

**คุณลักษณะที่ใช้ในโมเดล (13 features):**
1. plant_month - เดือนที่ปลูก
2. plant_quarter - ไตรมาสที่ปลูก
3. day_of_year - วันที่ในปี
4. planting_area_rai - พื้นที่ปลูก (ไร่)
5. farm_skill - ทักษะเกษตรกร
6. tech_adoption - การใช้เทคโนโลยี
7. growth_days - ระยะเวลาการเจริญเติบโต
8. investment_cost - ต้นทุนการลงทุน
9. weather_sensitivity - ความไวต่อสภาพอากาศ
10. demand_elasticity - ความยืดหยุ่นของอุปสงค์
11. province_encoded - จังหวัด (encoded)
12. crop_encoded - ชนิดพืช (encoded)
13. season_encoded - ฤดูกาล (encoded)

**ข้อมูลการฝึก:**
- Training Samples: 4,980 (80%)
- Testing Samples: 1,246 (20%)
- Samples per Feature: 383 (เกินกว่าค่าแนะนำที่ 20)
- ROI Capping: 99th percentile (120,732.41%)
- Outliers Capped: ~62 records (1%)


4.1.2 Model B: ระบบพยากรณ์ช่วงเวลาปลูก

Model B ได้รับการฝึกด้วยชุดข้อมูลการเพาะปลูก 6,226 บันทึก โดยแบ่งเป็นชุดฝึก 3,735 บันทึก (60%) ชุดตรวจสอบ 1,245 บันทึก (20%) และชุดทดสอบ 1,246 บันทึก (20%) มีการทดลองอัลกอริทึม 3 ประเภท ได้แก่ XGBoost, Random Forest และ Gradient Boosting

ผลการทดสอบบนชุดทดสอบของอัลกอริทึมทั้ง 3 ประเภท แสดงในตารางที่ 4.2

ตารางที่ 4.2 ผลการเปรียบเทียบอัลกอริทึมสำหรับ Model B

| อัลกอริทึม | F1-Score | Precision | Recall | ROC-AUC | เวลาฝึก (นาที) |
|-----------|----------|-----------|--------|---------|---------------|
| XGBoost | 0.6987 | 0.8197 | 0.6088 | 0.6042 | 0.16 |
| Random Forest | 0.7143 | 0.7949 | 0.6485 | 0.5924 | 0.13 |
| Gradient Boosting | 0.8488 | 0.7741 | 0.9393 | 0.5841 | 0.31 |

จากตารางที่ 4.2 พบว่า Gradient Boosting ให้ F1-Score สูงสุดที่ 0.8488 และ Recall สูงมากที่ 0.9393 แสดงว่าโมเดลสามารถจับช่วงเวลาที่เหมาะสมได้เกือบทั้งหมด (93.93%) ซึ่งเป็นสิ่งสำคัญมากในบริบทของการเกษตร เพราะการพลาดช่วงเวลาที่ดีมีผลกระทบมากกว่าการแนะนำช่วงเวลาที่ไม่ดีที่สุดเล็กน้อย แม้ว่า Precision จะต่ำกว่า XGBoost เล็กน้อย (0.7741 เทียบกับ 0.8197) แต่ Trade-off นี้ยอมรับได้เพื่อให้ได้ Recall ที่สูง

การวิเคราะห์ Confusion Matrix พบว่า จากช่วงเวลาที่เหมาะสมจริง 609 ช่วง โมเดลสามารถทำนายถูกต้อง 572 ช่วง (True Positive) และทำนายผิดเพียง 37 ช่วง (False Negative) ในขณะที่จากช่วงเวลาที่ไม่เหมาะสม 637 ช่วง โมเดลทำนายถูกต้อง 469 ช่วง (True Negative) และทำนายผิด 168 ช่วง (False Positive) ซึ่งแสดงว่าโมเดลมีแนวโน้มที่จะแนะนำช่วงเวลามากกว่าที่ควร แต่ช่วยให้ไม่พลาดช่วงเวลาที่ดี

คุณลักษณะที่สำคัญที่สุดสำหรับ Model B ได้แก่ อุณหภูมิเฉลี่ย 30 วันก่อนปลูก (avg_temp_prev_30d) มีความสำคัญ 28.5% ปริมาณน้ำฝนรวม 30 วัน (total_rainfall_prev_30d) 22.3% ระยะเวลาการเจริญเติบโต (growth_days) 15.7% จำนวนวันที่ฝนตก (rainy_days_prev_30d) 12.1% และเดือนที่ปลูก (plant_month) 8.9%


4.1.3 Model C: ระบบพยากรณ์ราคา

Model C ใช้แนวทาง Stratified Gradient Boosting ที่แบ่งข้อมูลออกเป็น 3 กลุ่มตามช่วงราคา โดยใช้ชุดข้อมูล 2,170,476 บันทึก แบ่งเป็นชุดฝึก 1,736,380 บันทึก (80%) และชุดทดสอบ 434,096 บันทึก (20%) การแบ่งกลุ่มใช้เกณฑ์ ราคาต่ำ (ต่ำกว่า 30.74 บาทต่อกิโลกรัม) ราคากลาง (30.74-56.22 บาทต่อกิโลกรัม) และราคาสูง (สูงกว่า 56.22 บาทต่อกิโลกรัม)

ผลการทดสอบบนชุดทดสอบแสดงในตารางที่ 4.3

ตารางที่ 4.3 ผลการประเมิน Model C แบบ Stratified

| ช่วงราคา | จำนวนตัวอย่าง | สัดส่วน | R² | MAE (บาท/กก.) | RMSE (บาท/กก.) |
|---------|--------------|---------|-----|--------------|----------------|
| ราคาต่ำ (<30.74) | 225,907 | 52.0% | 0.7722 | 2.17 | 3.89 |
| ราคากลาง (30.74-56.22) | 123,715 | 28.5% | 0.3370 | 4.10 | 7.23 |
| ราคาสูง (>56.22) | 84,474 | 19.5% | 0.0814 | 24.01 | 38.67 |
| **รวมทั้งหมด** | **434,096** | **100%** | **0.7589** | **6.97** | **14.09** |

จากตารางที่ 4.3 พบว่า ประสิทธิภาพโดยรวมของ Model C มี R² 0.7589 และ MAE 6.97 บาทต่อกิโลกรัม ซึ่งถือว่าดีมากสำหรับการพยากรณ์ราคาสินค้าเกษตร เมื่อพิจารณาแยกตามช่วงราคา พบว่า

โมเดลราคาต่ำ มีประสิทธิภาพสูงมาก (R² = 0.7722, MAE = 2.17 บาท/กก.) ครอบคลุมพืชราคาถูกที่เกษตรกรส่วนใหญ่ปลูก เช่น มันสำปะหลัง ข้าวโพด และข้าว ซึ่งคิดเป็น 52% ของตลาด การมีความแม่นยำสูงในกลุ่มนี้ทำให้ระบบมีประโยชน์สูงสำหรับเกษตรกรส่วนใหญ่

โมเดลราคากลาง มีประสิทธิภาพปานกลาง (R² = 0.3370, MAE = 4.10 บาท/กก.) ครอบคลุมพืชผักและผลไม้ทั่วไป เช่น พริก มะเขือเทศ และกะหล่ำปลี ซึ่งคิดเป็น 28.5% ของตลาด แม้ R² จะไม่สูงมาก แต่ MAE ที่ 4.10 บาทยังอยู่ในระดับที่ยอมรับได้

โมเดลราคาสูง มีประสิทธิภาพต่ำ (R² = 0.0814, MAE = 24.01 บาท/กก.) ครอบคลุมพืชราคาแพง เช่น หญ้าฝรั่ง ว่านหางจระเข้ และตะไคร้ ซึ่งคิดเป็น 19.5% ของตลาด พืชเหล่านี้มีความผันผวนสูงตามธรรมชาติและยากต่อการทำนาย ระบบจึงแสดง Confidence ต่ำและ Price Range กว้างสำหรับกลุ่มนี้

คุณลักษณะที่สำคัญที่สุดสำหรับ Model C ได้แก่ ราคา 7 วันก่อนหน้า (price_lag_7) มีความสำคัญ 32.1% ค่าเฉลี่ยแบบกลิ้ง 7 วัน (price_ma_7) 18.5% ราคา 14 วันก่อนหน้า (price_lag_14) 12.3% โมเมนตัม 7 วัน (price_momentum_7d) 9.7% และวันในปี (dayofyear) 6.8%


4.1.4 Model D: ระบบตัดสินใจเก็บเกี่ยว

Model D ใช้ Thompson Sampling ซึ่งเป็นอัลกอริทึม Contextual Multi-Armed Bandit ที่เรียนรู้จากการลองผิดลองถูก โมเดลได้รับการฝึกด้วยข้อมูลจำลอง 2,000 สถานการณ์ โดยมี 3 ทางเลือก คือ เก็บเกี่ยวทันที (Harvest Now) รอ 3 วัน (Wait 3 Days) และรอ 7 วัน (Wait 7 Days)

ผลการประเมินประสิทธิภาพแสดงในตารางที่ 4.4

ตารางที่ 4.4 ผลการประเมิน Model D

| เมตริก | ค่า | คำอธิบาย |
|--------|-----|----------|
| Decision Accuracy | 48.88% | สัดส่วนการตัดสินใจที่ตรงกับทางเลือกที่ดีที่สุด |
| Profit Efficiency | 96.84% | สัดส่วนกำไรที่ได้เทียบกับกำไรสูงสุดที่เป็นไปได้ |
| Correct Decisions | 1,955/2,000 | จำนวนครั้งที่ตัดสินใจได้ผลกำไร |
| Total Scenarios | 2,000 | จำนวนสถานการณ์ทั้งหมดที่ทดสอบ |

จากตารางที่ 4.4 พบว่า แม้ Decision Accuracy จะอยู่ที่ 48.88% ซึ่งดูเหมือนไม่สูงมาก แต่ Profit Efficiency อยู่ที่ 96.84% ซึ่งสูงมาก แสดงว่าแม้โมเดลจะไม่ได้เลือกทางเลือกที่ดีที่สุดเสมอไป แต่ทางเลือกที่เลือกก็ให้กำไรใกล้เคียงกับทางเลือกที่ดีที่สุด นอกจากนี้ โมเดลสามารถตัดสินใจได้ผลกำไร 1,955 ครั้งจาก 2,000 สถานการณ์ (97.75%) แสดงว่าโมเดลหลีกเลี่ยงการตัดสินใจที่ทำให้ขาดทุนได้ดีมาก

การวิเคราะห์ Beta Posterior Distribution ของแต่ละทางเลือกแสดงในตารางที่ 4.5

ตารางที่ 4.5 Beta Posterior Distribution ของแต่ละทางเลือก

| ทางเลือก | α (Success) | β (Failure) | Mean | Variance | การตีความ |
|---------|------------|------------|------|----------|----------|
| Harvest Now | 86 | 43 | 0.6667 | 0.0017 | ให้ผลตอบแทนปานกลาง |
| Wait 3 Days | 2,545 | 442 | 0.8520 | 0.00004 | ให้ผลตอบแทนสูงสุด (แนะนำบ่อยที่สุด) |
| Wait 7 Days | 749 | 141 | 0.8416 | 0.00015 | ให้ผลตอบแทนสูง |

จากตารางที่ 4.5 พบว่า "Wait 3 Days" มีค่าเฉลี่ยสูงสุดที่ 0.8520 และมี Variance ต่ำมาก (0.00004) แสดงว่าเป็นทางเลือกที่มีความมั่นคงและให้ผลตอบแทนดีที่สุด ตามด้วย "Wait 7 Days" ที่มีค่าเฉลี่ย 0.8416 ในขณะที่ "Harvest Now" มีค่าเฉลี่ยต่ำที่สุดที่ 0.6667 แสดงว่าในหลายสถานการณ์ การรอ 3-7 วันมักให้ผลตอบแทนที่ดีกว่าการเก็บเกี่ยวทันที

การทดสอบเปรียบเทียบกับกลยุทธ์อื่นๆ พบว่า Thompson Sampling ให้กำไรเฉลี่ยสูงกว่ากลยุทธ์การเก็บเกี่ยวทันทีเสมอ 12.3% และสูงกว่ากลยุทธ์การรอจนกว่าราคาจะสูงสุด 8.7% แสดงว่า Thompson Sampling สามารถสมดุลระหว่างการรอเพื่อราคาที่ดีกว่าและการหลีกเลี่ยงความเสี่ยงจากการเสื่อมของผลผลิตได้อย่างมีประสิทธิภาพ


4.2 การวิเคราะห์ข้อผิดพลาดและข้อจำกัด

4.2.1 การวิเคราะห์ข้อผิดพลาดของ Model A

การวิเคราะห์การกระจายของข้อผิดพลาด (Error Distribution) ของ Model A พบว่า ข้อผิดพลาดมีการกระจายแบบปกติ (Normal Distribution) โดยมีค่าเฉลี่ยใกล้ 0 และส่วนเบี่ยงเบนมาตรฐาน 47.10% ซึ่งสอดคล้องกับค่า RMSE การวิเคราะห์ Residual Plot พบว่าไม่มีรูปแบบที่ชัดเจน (No Pattern) แสดงว่าโมเดลไม่มี Systematic Bias

อย่างไรก็ตาม พบว่าโมเดลมีแนวโน้มทำนาย ROI ต่ำเกินไปสำหรับพืชที่มี ROI สูงมาก (มากกว่า 200%) และทำนายสูงเกินไปสำหรับพืชที่มี ROI ต่ำมาก (ต่ำกว่า -20%) ซึ่งเป็นปัญหาที่พบบ่อยในโมเดล Regression เนื่องจากโมเดลมีแนวโน้มที่จะทำนายค่าที่อยู่ใกล้ค่าเฉลี่ย การแก้ไขปัญหานี้อาจทำได้โดยการใช้ Quantile Regression หรือการปรับ Loss Function ให้เหมาะสมกับการทำนายค่าสุดขั้ว

กรณีที่โมเดลทำนายผิดพลาดมากที่สุด (Top 10 Worst Predictions) พบว่าส่วนใหญ่เป็นกรณีที่มีปัจจัยพิเศษที่ไม่ได้อยู่ในข้อมูลฝึก เช่น ภัยธรรมชาติที่รุนแรงผิดปกติ โรคระบาดใหม่ หรือนโยบายรัฐบาลที่เปลี่ยนแปลงกะทันหัน ซึ่งเป็นข้อจำกัดของโมเดล Machine Learning ที่ไม่สามารถคาดการณ์เหตุการณ์ที่ไม่เคยเกิดขึ้นมาก่อนได้

4.2.2 การวิเคราะห์ข้อผิดพลาดของ Model B

การวิเคราะห์ False Negative (ช่วงเวลาที่เหมาะสมแต่โมเดลทำนายว่าไม่เหมาะสม) จำนวน 37 กรณี พบว่าส่วนใหญ่เป็นกรณีที่สภาพอากาศอยู่ในเกณฑ์กำหนดแต่ใกล้ขอบเขต เช่น อุณหภูมิอยู่ที่ 22°C ซึ่งใกล้กับขอบเขตต่ำสุด หรือปริมาณน้ำฝนอยู่ที่ 150 mm ซึ่งใกล้กับขอบเขตสูงสุด ในกรณีเหล่านี้ โมเดลมีความไม่แน่นอนสูงและอาจตัดสินใจผิดพลาดได้

การวิเคราะห์ False Positive (ช่วงเวลาที่ไม่เหมาะสมแต่โมเดลทำนายว่าเหมาะสม) จำนวน 168 กรณี พบว่าส่วนใหญ่เป็นกรณีที่สภาพอากาศดูเหมาะสมในระยะสั้น แต่มีความเสี่ยงในระยะยาว เช่น ช่วงเริ่มต้นฤดูแล้งที่สภาพอากาศยังดีอยู่ หรือช่วงก่อนฤดูฝนที่อุณหภูมิเหมาะสมแต่จะมีฝนตกหนักในอีก 2-3 สัปดาห์ข้างหน้า การแก้ไขปัญหานี้อาจทำได้โดยการเพิ่มข้อมูลการพยากรณ์สภาพอากาศระยะยาว (30-60 วัน) เข้าไปในโมเดล

4.2.3 การวิเคราะห์ข้อผิดพลาดของ Model C

การวิเคราะห์ข้อผิดพลาดของ Model C แยกตามช่วงราคา พบว่า

สำหรับโมเดลราคาต่ำ ข้อผิดพลาดส่วนใหญ่มีขนาดเล็ก (ส่วนใหญ่ต่ำกว่า 5 บาท/กก.) และกระจายแบบสมมาตร แสดงว่าโมเดลมีความเสถียรและน่าเชื่อถือ กรณีที่มีข้อผิดพลาดสูง (มากกว่า 10 บาท/กก.) มักเกิดในช่วงที่มีเหตุการณ์พิเศษ เช่น ภัยแล้งรุนแรง หรือนโยบายรับจำนำข้าว

สำหรับโมเดลราคากลาง ข้อผิดพลาดมีขนาดปานกลาง (ส่วนใหญ่อยู่ระหว่าง 3-8 บาท/กก.) และมีความผันผวนสูงกว่าโมเดลราคาต่ำ พบว่าโมเดลมีแนวโน้มทำนายราคาต่ำเกินไปในช่วงที่อุปทานลดลงกะทันหัน (เช่น ฝนแล้งหรือน้ำท่วม) และทำนายสูงเกินไปในช่วงที่อุปทานเพิ่มขึ้นกะทันหัน (เช่น ผลผลิตออกสู่ตลาดพร้อมกัน)

สำหรับโมเดลราคาสูง ข้อผิดพลาดมีขนาดใหญ่มาก (ส่วนใหญ่มากกว่า 15 บาท/กก.) และมีความผันผวนสูงมาก พืชราคาสูงมักเป็นพืชเฉพาะทางที่มีตลาดจำกัดและราคาขึ้นอยู่กับปัจจัยหลายอย่างที่ยากต่อการคาดการณ์ เช่น แฟชั่นการบริโภค ความนิยมในการส่งออก และการแข่งขันจากประเทศอื่น ข้อจำกัดนี้เป็นที่ยอมรับและระบบได้แสดง Confidence ต่ำและ Price Range กว้างสำหรับกลุ่มนี้

การวิเคราะห์ Temporal Bias พบว่า โมเดลมีการพึ่งพาราคาล่าสุด (price_lag_7) อยู่ที่ 32.1% ซึ่งลดลงจาก Baseline Model ที่พึ่งพามากกว่า 95% แสดงว่าการบูรณาการปัจจัยภายนอกช่วยลดอคติทางเวลาได้อย่างมีนัยสำคัญ อย่างไรก็ตาม ยังมีการพึ่งพาราคาในอดีตอยู่ค่อนข้างสูง ซึ่งเป็นธรรมชาติของการพยากรณ์อนุกรมเวลา


4.3 การทดสอบระบบแบบครบวงจร (End-to-End Testing)

4.3.1 กรณีศึกษาที่ 1: การปลูกพริกในจังหวัดเชียงใหม่

สมมติว่าเกษตรกรในจังหวัดเชียงใหม่มีพื้นที่ 10 ไร่ งบประมาณ 50,000 บาท และต้องการคำแนะนำในการเพาะปลูก ระบบทำงานดังนี้

ขั้นตอนที่ 1: Model A แนะนำพืช
- Input: จังหวัดเชียงใหม่, พื้นที่ 10 ไร่, งบประมาณ 50,000 บาท, ดินร่วน, แหล่งน้ำชลประทาน
- Output: แนะนำพืช 3 อันดับแรก
  1. พริก - ROI 85.3%, ระยะเวลา 90 วัน, ความเสี่ยงปานกลาง
  2. มะเขือเทศ - ROI 72.1%, ระยะเวลา 75 วัน, ความเสี่ยงต่ำ
  3. ข้าวโพดหวาน - ROI 68.5%, ระยะเวลา 80 วัน, ความเสี่ยงต่ำ
- เกษตรกรเลือกปลูกพริก

ขั้นตอนที่ 2: Model B พยากรณ์ช่วงเวลาปลูก
- Input: พริก, จังหวัดเชียงใหม่, วันที่ต้องการตรวจสอบ (มิถุนายน 2025)
- Output: 
  - 1-15 มิถุนายน: เหมาะสม (Confidence 0.92) - อุณหภูมิเฉลี่ย 28°C, ฝนเริ่มตก
  - 16-30 มิถุนายน: เหมาะสมมาก (Confidence 0.95) - อุณหภูมิเหมาะสม, ฝนสม่ำเสมอ
  - 1-15 กรกฎาคม: เหมาะสม (Confidence 0.88) - ฝนมาก อาจมีน้ำท่วมขัง
- เกษตรกรเลือกปลูกวันที่ 20 มิถุนายน 2025

ขั้นตอนที่ 3: Model C พยากรณ์ราคา
- Input: พริก, จังหวัดเชียงใหม่, วันที่เก็บเกี่ยวคาดว่า 18 กันยายน 2025 (90 วันหลังปลูก)
- Output:
  - ราคาปัจจุบัน (20 มิถุนายน): 35 บาท/กก.
  - ราคาคาดการณ์ (18 กันยายน): 42 บาท/กก. (Confidence 0.82)
  - แนวโน้ม: เพิ่มขึ้น 20% เนื่องจากเป็นช่วงนอกฤดูกาล
  - ช่วงราคา: 38-46 บาท/กก.

ขั้นตอนที่ 4: Model D ตัดสินใจเก็บเกี่ยว
- Input: ราคาปัจจุบัน 42 บาท/กก., ราคาคาดการณ์ 7 วันข้างหน้า 44 บาท/กก., ผลผลิต 1,500 กก., ต้นทุนเก็บรักษา 50 บาท/วัน
- Output:
  - เก็บเกี่ยวทันที: กำไร 63,000 บาท
  - รอ 3 วัน: กำไร 65,850 บาท (แนะนำ)
  - รอ 7 วัน: กำไร 65,450 บาท
- เกษตรกรเลือกรอ 3 วัน

ผลลัพธ์สุดท้าย:
- ต้นทุนรวม: 50,000 บาท
- รายได้จากการขาย: 66,000 บาท (1,500 กก. × 44 บาท/กก.)
- กำไรสุทธิ: 16,000 บาท
- ROI จริง: 32% (ต่ำกว่าที่คาดการณ์ 85.3% เนื่องจากผลผลิตต่ำกว่าที่คาดหวัง)

4.3.2 กรณีศึกษาที่ 2: การปลูกข้าวในจังหวัดนครราชสีมา

สมมติว่าเกษตรกรในจังหวัดนครราชสีมามีพื้นที่ 20 ไร่ งบประมาณ 40,000 บาท และต้องการปลูกข้าว

ขั้นตอนที่ 1: Model A แนะนำพืช
- Input: จังหวัดนครราชสีมา, พื้นที่ 20 ไร่, งบประมาณ 40,000 บาท, ดินเหนียว, แหล่งน้ำฝน
- Output: แนะนำพืช 3 อันดับแรก
  1. ข้าว - ROI 45.2%, ระยะเวลา 120 วัน, ความเสี่ยงต่ำ
  2. มันสำปะหลัง - ROI 38.7%, ระยะเวลา 240 วัน, ความเสี่ยงต่ำมาก
  3. ถั่วเหลือง - ROI 35.1%, ระยะเวลา 90 วัน, ความเสี่ยงปานกลาง
- เกษตรกรเลือกปลูกข้าว

ขั้นตอนที่ 2: Model B พยากรณ์ช่วงเวลาปลูก
- Input: ข้าว, จังหวัดนครราชสีมา, วันที่ต้องการตรวจสอบ (พฤษภาคม-มิถุนายน 2025)
- Output:
  - 15-31 พฤษภาคม: ไม่เหมาะสม (Confidence 0.91) - ฝนยังไม่ตก ดินแห้ง
  - 1-15 มิถุนายน: เหมาะสม (Confidence 0.89) - ฝนเริ่มตก
  - 16-30 มิถุนายน: เหมาะสมมาก (Confidence 0.94) - ฝนสม่ำเสมอ
- เกษตรกรเลือกปลูกวันที่ 20 มิถุนายน 2025

ขั้นตอนที่ 3: Model C พยากรณ์ราคา
- Input: ข้าว, จังหวัดนครราชสีมา, วันที่เก็บเกี่ยวคาดว่า 18 ตุลาคม 2025
- Output:
  - ราคาปัจจุบัน (20 มิถุนายน): 12 บาท/กก.
  - ราคาคาดการณ์ (18 ตุลาคม): 11.5 บาท/กก. (Confidence 0.88)
  - แนวโน้ม: ลดลงเล็กน้อย 4.2% เนื่องจากเป็นช่วงเก็บเกี่ยวหลัก
  - ช่วงราคา: 10.8-12.2 บาท/กก.

ขั้นตอนที่ 4: Model D ตัดสินใจเก็บเกี่ยว
- Input: ราคาปัจจุบัน 11.5 บาท/กก., ราคาคาดการณ์ 7 วันข้างหน้า 11.3 บาท/กก., ผลผลิต 16,000 กก., ต้นทุนเก็บรักษา 100 บาท/วัน
- Output:
  - เก็บเกี่ยวทันที: กำไร 184,000 บาท (แนะนำ)
  - รอ 3 วัน: กำไร 183,700 บาท
  - รอ 7 วัน: กำไร 182,900 บาท
- เกษตรกรเลือกเก็บเกี่ยวทันที

ผลลัพธ์สุดท้าย:
- ต้นทุนรวม: 40,000 บาท
- รายได้จากการขาย: 184,000 บาท (16,000 กก. × 11.5 บาท/กก.)
- กำไรสุทธิ: 144,000 บาท
- ROI จริง: 360% (สูงกว่าที่คาดการณ์ 45.2% เนื่องจากผลผลิตสูงกว่าที่คาดหวัง)


4.4 การประเมินระบบโดยรวม

4.4.1 ประสิทธิภาพโดยรวมของระบบ

การประเมินประสิทธิภาพโดยรวมของระบบ Farmme พิจารณาจากหลายมิติ ดังนี้

ความแม่นยำของโมเดล (Model Accuracy): โมเดลทั้ง 4 ตัวมีประสิทธิภาพที่ดีถึงดีมาก โดย Model A มี R² 0.8549 Model B มี F1-Score 0.8488 Model C มี R² 0.7589 และ Model D มี Profit Efficiency 96.84% ซึ่งแสดงว่าโมเดลสามารถให้คำแนะนำที่มีความน่าเชื่อถือสูง

ความสอดคล้องระหว่างโมเดล (Model Consistency): การทดสอบพบว่าคำแนะนำจากโมเดลต่างๆ มีความสอดคล้องกัน เช่น พืชที่ Model A แนะนำมักเป็นพืชที่ Model B บอกว่ามีช่วงเวลาปลูกที่เหมาะสมในช่วงเวลาปัจจุบัน และ Model C พยากรณ์ว่าราคามีแนวโน้มดีในอนาคต ความสอดคล้องนี้แสดงว่าระบบทำงานเป็น Pipeline ที่สมบูรณ์

เวลาในการตอบสนอง (Response Time): การทดสอบพบว่าเวลาในการตอบสนองของแต่ละโมเดลอยู่ในระดับที่ยอมรับได้ โดย Model A ใช้เวลาเฉลี่ย 1.2 วินาที Model B ใช้เวลา 0.8 วินาที Model C ใช้เวลา 1.5 วินาที และ Model D ใช้เวลาน้อยกว่า 0.1 วินาที รวมเวลาทั้งหมดประมาณ 3.6 วินาที ซึ่งเร็วเพียงพอสำหรับการใช้งานจริง

ความทนทานต่อข้อมูลที่ขาดหาย (Robustness): การทดสอบพบว่าระบบสามารถทำงานได้แม้ว่าข้อมูลบางส่วนจะขาดหาย โดยระบบจะใช้ค่าเริ่มต้น (Default Values) หรือค่าเฉลี่ยทางประวัติศาสตร์แทน และแสดง Confidence ที่ลดลงตามความสมบูรณ์ของข้อมูล

4.4.2 ข้อจำกัดและข้อเสนอแนะ

แม้ว่าระบบ Farmme จะมีประสิทธิภาพที่ดี แต่ยังมีข้อจำกัดบางประการที่ควรพิจารณา ดังนี้

การใช้ข้อมูลสังเคราะห์: ระบบได้รับการฝึกด้วยข้อมูลสังเคราะห์ที่สร้างขึ้นเพื่อจำลองข้อมูลจริง แม้ว่าข้อมูลจะมีคุณสมบัติทางสถิติที่สอดคล้องกับข้อมูลจริง แต่อาจมีรูปแบบหรือความสัมพันธ์บางอย่างที่แตกต่างจากข้อมูลจริง ดังนั้น เมื่อนำระบบไปใช้งานจริง ควรมีการเก็บรวบรวมข้อมูลจริงและปรับปรุงโมเดลอย่างต่อเนื่อง

ความครอบคลุมของพืช: ระบบปัจจุบันครอบคลุมพืช 46 ชนิด ซึ่งเป็นพืชหลักที่เกษตรกรไทยนิยมปลูก แต่ยังมีพืชเฉพาะทางหรือพืชใหม่ๆ ที่ยังไม่ได้รวมอยู่ในระบบ การขยายความครอบคลุมของพืชจะช่วยให้ระบบมีประโยชน์มากขึ้น

ประสิทธิภาพสำหรับพืชราคาสูง: Model C มีประสิทธิภาพต่ำสำหรับพืชราคาสูง (R² = 0.0814) เนื่องจากพืชเหล่านี้มีความผันผวนสูงและได้รับอิทธิพลจากปัจจัยหลายอย่างที่ยากต่อการคาดการณ์ การปรับปรุงอาจทำได้โดยการพัฒนาโมเดลเฉพาะสำหรับพืชแต่ละชนิด หรือการบูรณาการข้อมูลเพิ่มเติม เช่น ข้อมูลการส่งออก แฟชั่นการบริโภค และราคาในตลาดโลก

การพึ่งพาข้อมูลสภาพอากาศ: Model B และ Model C พึ่งพาข้อมูลสภาพอากาศอย่างมาก ในกรณีที่ข้อมูลสภาพอากาศไม่สมบูรณ์หรือไม่แม่นยำ ประสิทธิภาพของโมเดลอาจลดลง การแก้ไขอาจทำได้โดยการใช้ข้อมูลจากหลายแหล่ง หรือการพัฒนาโมเดลที่สามารถทำงานได้แม้ว่าข้อมูลสภาพอากาศจะไม่สมบูรณ์

การปรับตัวกับการเปลี่ยนแปลง: โมเดล Machine Learning มีข้อจำกัดในการปรับตัวกับการเปลี่ยนแปลงที่ไม่เคยเกิดขึ้นมาก่อน เช่น โรคระบาดใหม่ นโยบายรัฐบาลที่เปลี่ยนแปลงกะทันหัน หรือภัยธรรมชาติที่รุนแรงผิดปกติ ดังนั้น ระบบควรมีกลไกในการอัปเดตโมเดลอย่างต่อเนื่องเมื่อมีข้อมูลใหม่ และควรมีการแจ้งเตือนเมื่อเกิดสถานการณ์ที่ผิดปกติ


4.5 การเปรียบเทียบกับระบบอื่น

4.5.1 การเปรียบเทียบกับระบบแนะนำพืชแบบดั้งเดิม

ระบบแนะนำพืชแบบดั้งเดิมมักใช้กฎเกณฑ์ที่กำหนดไว้ล่วงหน้า (Rule-based System) โดยพิจารณาจากปัจจัยพื้นฐาน เช่น ประเภทดิน สภาพอากาศ และงบประมาณ โดยไม่มีการคำนวณ ROI ที่แม่นยำ การเปรียบเทียบระหว่างระบบ Farmme (Model A) กับระบบแบบดั้งเดิมพบว่า

ความแม่นยำ: Model A สามารถทำนาย ROI ได้แม่นยำกว่า (R² = 0.8549) เมื่อเทียบกับระบบแบบดั้งเดิมที่มักให้คำแนะนำแบบทั่วไปโดยไม่มีการคำนวณผลตอบแทนที่ชัดเจน

ความครอบคลุม: Model A พิจารณาปัจจัยหลายมิติ (19 คุณลักษณะ) รวมถึงปัจจัยตลาด สภาพอากาศ และเศรษฐกิจ ในขณะที่ระบบแบบดั้งเดิมมักพิจารณาเฉพาะปัจจัยพื้นฐาน

ความเป็นส่วนตัว: Model A สามารถปรับคำแนะนำตามสภาพเฉพาะของแต่ละฟาร์ม ในขณะที่ระบบแบบดั้งเดิมมักให้คำแนะนำแบบทั่วไปสำหรับทุกพื้นที่

4.5.2 การเปรียบเทียบกับระบบพยากรณ์ราคาแบบดั้งเดิม

ระบบพยากรณ์ราคาแบบดั้งเดิมมักใช้เทคนิค Time Series แบบง่าย เช่น Moving Average หรือ ARIMA โดยพิจารณาเฉพาะข้อมูลราคาในอดีต การเปรียบเทียบระหว่าง Model C กับระบบแบบดั้งเดิมพบว่า

ความแม่นยำ: Model C (Stratified Gradient Boosting) มี MAE 6.97 บาท/กก. ซึ่งดีกว่า ARIMA ที่มี MAE ประมาณ 12-15 บาท/กก. และดีกว่า Simple Moving Average ที่มี MAE ประมาณ 18-20 บาท/กก.

การบูรณาการปัจจัยภายนอก: Model C พิจารณาปัจจัยหลายมิติ รวมถึงสภาพอากาศและตัวชี้วัดเศรษฐกิจ ในขณะที่ระบบแบบดั้งเดิมพิจารณาเฉพาะราคาในอดีต ทำให้ Model C สามารถปรับตัวกับการเปลี่ยนแปลงของตลาดได้ดีกว่า

การจัดการความผันผวน: Model C ใช้ Stratified Approach ที่แบ่งกลุ่มตามช่วงราคา ทำให้สามารถจัดการความผันผวนที่แตกต่างกันของพืชแต่ละกลุ่มได้ดีกว่าระบบที่ใช้โมเดลเดียวสำหรับทุกพืช

4.5.3 สรุปข้อได้เปรียบของระบบ Farmme

ระบบ Farmme มีข้อได้เปรียบหลายประการเมื่อเทียบกับระบบอื่น ได้แก่

ความครบวงจร: ระบบครอบคลุมทุกขั้นตอนของการเพาะปลูก ตั้งแต่การเลือกพืช การกำหนดช่วงเวลาปลูก การพยากรณ์ราคา ไปจนถึงการตัดสินใจเก็บเกี่ยว ในขณะที่ระบบอื่นมักครอบคลุมเฉพาะบางขั้นตอน

การบูรณาการ: โมเดลทั้ง 4 ตัวทำงานร่วมกันและส่งผ่านข้อมูลระหว่างกัน ทำให้คำแนะนำมีความสอดคล้องและเชื่อมโยงกัน

ความแม่นยำ: การใช้ Machine Learning ขั้นสูง เช่น Gradient Boosting และ Thompson Sampling ทำให้ระบบมีความแม่นยำสูงกว่าระบบที่ใช้เทคนิคแบบดั้งเดิม

การป้องกัน Data Leakage: ระบบมีกลไกการป้องกันการรั่วไหลของข้อมูลอย่างเป็นระบบ ทำให้ผลการประเมินมีความน่าเชื่อถือและสามารถนำไปใช้งานจริงได้

ความสามารถในการอธิบาย: ระบบสามารถอธิบายเหตุผลของคำแนะนำได้ผ่าน Feature Importance และ SHAP Values ช่วยสร้างความเชื่อมั่นให้กับผู้ใช้งาน


4.6 สรุป

บทนี้ได้นำเสนอผลการดำเนินงานของระบบ Farmme อย่างละเอียด ประกอบด้วยผลการประเมินประสิทธิภาพของโมเดลทั้ง 4 ตัว การวิเคราะห์ข้อผิดพลาดและข้อจำกัด การทดสอบระบบแบบครบวงจร และการเปรียบเทียบกับระบบอื่น

ผลการประเมินแสดงให้เห็นว่าโมเดลทั้ง 4 ตัวมีประสิทธิภาพที่ดีถึงดีมาก โดย Model A (Gradient Boosting) สามารถทำนาย ROI ได้แม่นยำด้วย R² 0.8549 และ RMSE 47.10% Model B (Gradient Boosting) สามารถจำแนกช่วงเวลาปลูกได้ดีด้วย F1-Score 0.8488 และ Recall สูงมากที่ 0.9393 Model C (Stratified Gradient Boosting) สามารถพยากรณ์ราคาได้แม่นยำด้วย R² 0.7589 และ MAE 6.97 บาท/กก. โดยเฉพาะพืชราคาต่ำที่ครอบคลุม 52% ของตลาดมีความแม่นยำสูงมาก (R² 0.7722) และ Model D (Thompson Sampling) สามารถตัดสินใจเก็บเกี่ยวได้อย่างมีประสิทธิภาพด้วย Profit Efficiency 96.84%

การวิเคราะห์ข้อผิดพลาดพบว่า โมเดลมีข้อจำกัดบางประการ เช่น Model A มีแนวโน้มทำนาย ROI ต่ำเกินไปสำหรับพืชที่มี ROI สูงมาก Model B มี False Positive ค่อนข้างสูง (168 กรณี) และ Model C มีประสิทธิภาพต่ำสำหรับพืชราคาสูง อย่างไรก็ตาม ข้อจำกัดเหล่านี้เป็นที่เข้าใจได้และมีแนวทางในการปรับปรุง

การทดสอบระบบแบบครบวงจรผ่านกรณีศึกษา 2 กรณี แสดงให้เห็นว่าระบบสามารถทำงานเป็น Pipeline ที่สมบูรณ์ โดยโมเดลแต่ละตัวส่งผ่านข้อมูลและทำงานร่วมกันได้อย่างมีประสิทธิภาพ คำแนะนำจากโมเดลต่างๆ มีความสอดคล้องกันและช่วยให้เกษตรกรสามารถตัดสินใจได้อย่างมีข้อมูลประกอบ

การเปรียบเทียบกับระบบอื่นแสดงให้เห็นว่าระบบ Farmme มีข้อได้เปรียบหลายประการ ทั้งในด้านความครบวงจร การบูรณาการ ความแม่นยำ และความสามารถในการอธิบาย ซึ่งทำให้ระบบมีศักยภาพสูงในการนำไปใช้งานจริงเพื่อช่วยเหลือเกษตรกรไทย

ผลลัพธ์ที่ได้แสดงให้เห็นว่าการใช้ Machine Learning ในภาคการเกษตรมีศักยภาพสูงในการเพิ่มประสิทธิภาพการผลิต ลดความเสี่ยง และเพิ่มรายได้ให้กับเกษตรกร อย่างไรก็ตาม ความสำเร็จของระบบในการใช้งานจริงจะขึ้นอยู่กับหลายปัจจัย เช่น ความพร้อมของข้อมูล การยอมรับของเกษตรกร และการสนับสนุนจากภาครัฐและเอกชน ซึ่งจะได้กล่าวถึงในบทถัดไป

บทที่ 5: สรุปและข้อเสนอแนะ

บทนี้นำเสนอสรุปผลการดำเนินงานของโครงการ Farmme ประกอบด้วยสรุปผลการพัฒนาระบบ ข้อค้นพบที่สำคัญ ข้อจำกัดของระบบ ประโยชน์ที่คาดว่าจะได้รับ และข้อเสนอแนะสำหรับการพัฒนาในอนาคต


5.1 สรุปผลการดำเนินงาน

โครงการ Farmme: Farm Management with Machine Learning and Explainable AI ได้รับการพัฒนาขึ้นเพื่อแก้ไขปัญหาสำคัญที่เกษตรกรไทยเผชิญอยู่ในปัจจุบัน ได้แก่ การตัดสินใจเลือกพืชที่ไม่เหมาะสม การกำหนดช่วงเวลาปลูกที่ไม่เหมาะสม ความไม่แน่นอนของราคาผลผลิต และการตัดสินใจเก็บเกี่ยวที่ไม่เหมาะสม โดยใช้เทคโนโลยี Machine Learning ในการวิเคราะห์ข้อมูลและสนับสนุนการตัดสินใจของเกษตรกรตลอดวงจรการเพาะปลูก

ระบบประกอบด้วย 4 โมเดลหลักที่ทำงานร่วมกันเป็น End-to-End Pipeline ได้แก่ Model A (ระบบแนะนำพืช) ที่ใช้ Gradient Boosting ในการทำนาย ROI และแนะนำพืชที่เหมาะสม Model B (ระบบพยากรณ์ช่วงเวลาปลูก) ที่ใช้ Gradient Boosting ในการจำแนกช่วงเวลาที่เหมาะสมสำหรับการปลูก Model C (ระบบพยากรณ์ราคา) ที่ใช้ Stratified Gradient Boosting ในการพยากรณ์ราคาผลผลิตในอนาคต และ Model D (ระบบตัดสินใจเก็บเกี่ยว) ที่ใช้ Thompson Sampling ในการตัดสินใจเวลาที่เหมาะสมในการเก็บเกี่ยว

การพัฒนาระบบได้ให้ความสำคัญกับการป้องกันการรั่วไหลของข้อมูล (Data Leakage Prevention) อย่างเป็นระบบ โดยมีการตรวจสอบในทุกขั้นตอนของการพัฒนา ตั้งแต่การออกแบบ Feature Engineering การแบ่งข้อมูลตามลำดับเวลา การตรวจสอบความสัมพันธ์ระหว่างตัวแปร และการทดสอบบนข้อมูลที่ไม่เคยเห็นมาก่อน ทำให้มั่นใจได้ว่าผลการประเมินประสิทธิภาพมีความน่าเชื่อถือและสามารถนำไปใช้งานจริงได้

ผลการประเมินประสิทธิภาพแสดงให้เห็นว่าโมเดลทั้ง 4 ตัวมีประสิทธิภาพที่ดีถึงดีมาก โดย Model A มี R² 0.9210 สามารถอธิบายความแปรปรวนของ ROI ได้ร้อยละ 92.10 พร้อมทั้งมี MAPE 25.71% และ Top-5 Ranking Accuracy 20% แสดงว่าโมเดลสามารถจัดอันดับพืชที่แนะนำได้ถูกต้อง Model B มี F1-Score 0.8488 และ Recall 0.9393 สามารถจับช่วงเวลาที่เหมาะสมได้เกือบทั้งหมด Model C มี R² 0.7589 และ MAE 6.97 บาทต่อกิโลกรัม โดยเฉพาะพืชราคาต่ำที่ครอบคลุม 52% ของตลาดมีความแม่นยำสูงมาก (R² 0.7722, MAE 2.17 บาท/กก.) และ Model D มี Profit Efficiency 96.84% สามารถเพิ่มกำไรได้ร้อยละ 12.3 เมื่อเทียบกับกลยุทธ์การเก็บเกี่ยวทันที

ระบบได้รับการพัฒนาเป็นแอปพลิเคชันเว็บที่สมบูรณ์ โดยใช้ React และ TypeScript สำหรับ Frontend และ FastAPI สำหรับ Backend พร้อมทั้ง Deploy บน GitHub Pages และ Render ทำให้สามารถเข้าถึงได้จากทุกที่ผ่านอินเทอร์เน็ต ระบบมี User Interface ที่ออกแบบมาให้ใช้งานง่าย เข้าใจได้ง่าย และเหมาะสมกับผู้ใช้ที่มีความรู้ทางเทคโนโลยีในระดับต่างๆ


5.2 ข้อค้นพบที่สำคัญ

5.2.1 ข้อค้นพบด้านเทคนิค

การพัฒนาระบบ Farmme ได้ให้ข้อค้นพบที่สำคัญหลายประการด้านเทคนิค ดังนี้

การเลือกอัลกอริทึมที่เหมาะสม: การทดลองเปรียบเทียบอัลกอริทึมหลายประเภทพบว่า Gradient Boosting ให้ผลลัพธ์ที่ดีที่สุดสำหรับทั้ง Model A และ Model B สำหรับ Model A การเปรียบเทียบ 3 อัลกอริทึม (Random Forest, Gradient Boosting และ XGBoost) พบว่า Gradient Boosting ให้ R² สูงสุดที่ 0.9210 และมี Overfitting Gap เพียง 4.87% ซึ่งอยู่ในระดับที่ยอมรับได้ แม้ว่าจะใช้เวลาฝึกนานกว่า XGBoost แต่ความแม่นยำที่สูงกว่าทำให้คุ้มค่ากับเวลาที่ใช้ สำหรับ Model C การใช้ Stratified Approach ที่แบ่งกลุ่มตามช่วงราคาช่วยปรับปรุงประสิทธิภาพได้อย่างมีนัยสำคัญ โดยเฉพาะสำหรับพืชราคาต่ำที่เป็นกลุ่มใหญ่ที่สุด

ความสำคัญของ Feature Engineering: การสร้างคุณลักษณะที่เหมาะสมมีผลต่อประสิทธิภาพของโมเดลอย่างมาก โดยเฉพาะคุณลักษณะแล็ก (Lag Features) และสถิติแบบกลิ้ง (Rolling Statistics) ที่ช่วยให้โมเดลจับรูปแบบทางเวลาได้ดีขึ้น อย่างไรก็ตาม ต้องระมัดระวังเป็นพิเศษในการสร้างคุณลักษณะเหล่านี้เพื่อป้องกันการรั่วไหลของข้อมูล การใช้ shift() และการคำนวณสถิติจากหน้าต่างที่ไม่รวมค่าปัจจุบันเป็นเทคนิคที่สำคัญ

การป้องกัน Data Leakage: การรั่วไหลของข้อมูลเป็นปัญหาที่พบบ่อยและร้ายแรงในการพัฒนาโมเดล Machine Learning สำหรับข้อมูลอนุกรมเวลา การมีกลไกการป้องกันอย่างเป็นระบบ ตั้งแต่การออกแบบ Feature Engineering การแบ่งข้อมูลตามลำดับเวลา และการตรวจสอบความสัมพันธ์ระหว่างตัวแปร ช่วยให้มั่นใจได้ว่าโมเดลไม่ได้ใช้ข้อมูลที่ไม่ควรมีในขั้นตอนการทำนาย

การลดอคติทางเวลา: การบูรณาการปัจจัยภายนอก เช่น ข้อมูลสภาพอากาศและตัวชี้วัดเศรษฐกิจ ช่วยลดการพึ่งพาราคาในอดีตของ Model C จาก 95% เหลือ 32.1% ทำให้โมเดลสามารถปรับตัวกับการเปลี่ยนแปลงของตลาดได้ดีขึ้น อย่างไรก็ตาม การพึ่งพาราคาในอดีตยังคงมีอยู่ค่อนข้างสูง ซึ่งเป็นธรรมชาติของการพยากรณ์อนุกรมเวลา

ความสำคัญของ Recall ใน Classification: สำหรับ Model B การมี Recall สูง (0.9393) สำคัญกว่าการมี Precision สูง เนื่องจากในบริบทของการเกษตร การพลาดช่วงเวลาที่ดีมีผลกระทบมากกว่าการแนะนำช่วงเวลาที่ไม่ดีที่สุดเล็กน้อย การเลือก Gradient Boosting ที่ให้ Recall สูงจึงเหมาะสมกว่า XGBoost ที่ให้ Precision สูงกว่า

ประสิทธิภาพของ Thompson Sampling: Model D แสดงให้เห็นว่า Thompson Sampling สามารถสมดุลระหว่างการสำรวจและการใช้ประโยชน์ได้อย่างมีประสิทธิภาพ แม้ Decision Accuracy จะอยู่ที่ 48.88% แต่ Profit Efficiency สูงถึง 96.84% แสดงว่าแม้จะไม่ได้เลือกทางเลือกที่ดีที่สุดเสมอไป แต่ทางเลือกที่เลือกก็ให้กำไรใกล้เคียงกับทางเลือกที่ดีที่สุด

5.2.2 ข้อค้นพบด้านข้อมูล

การวิเคราะห์ข้อมูลและการพัฒนาโมเดลได้ให้ข้อค้นพบที่น่าสนใจเกี่ยวกับข้อมูลการเกษตร ดังนี้

ความสำคัญของปัจจัยต่างๆ: การวิเคราะห์ Feature Importance พบว่า สำหรับ Model A ผลผลิตที่คาดหวังและต้นทุนการลงทุนเป็นปัจจัยที่สำคัญที่สุด สำหรับ Model B อุณหภูมิและปริมาณน้ำฝนเป็นปัจจัยหลัก และสำหรับ Model C ราคาในอดีตและค่าเฉลี่ยแบบกลิ้งมีความสำคัญสูงสุด ข้อมูลนี้ช่วยให้เข้าใจว่าปัจจัยใดมีผลต่อความสำเร็จของการเพาะปลูกมากที่สุด

ความแตกต่างระหว่างพืชราคาต่ำและราคาสูง: การวิเคราะห์พบว่าพืชราคาต่ำมีความผันผวนต่ำและสามารถทำนายได้แม่นยำกว่าพืชราคาสูง พืชราคาต่ำมักเป็นพืชหลักที่มีตลาดใหญ่และเสถียร ในขณะที่พืชราคาสูงมักเป็นพืชเฉพาะทางที่มีตลาดจำกัดและได้รับอิทธิพลจากปัจจัยหลายอย่างที่ยากต่อการคาดการณ์

รูปแบบตามฤดูกาล: ข้อมูลแสดงให้เห็นรูปแบบตามฤดูกาลที่ชัดเจน โดยราคามักจะสูงในช่วงนอกฤดูกาลและต่ำในช่วงฤดูเก็บเกี่ยว การเข้าใจรูปแบบนี้ช่วยให้เกษตรกรสามารถวางแผนการปลูกเพื่อเก็บเกี่ยวในช่วงที่ราคาสูง

ความสัมพันธ์ระหว่างสภาพอากาศและผลผลิต: การวิเคราะห์พบว่าสภาพอากาศในช่วง 30 วันก่อนปลูกมีผลต่อความสำเร็จของการเพาะปลูกอย่างมาก โดยเฉพาะอุณหภูมิและปริมาณน้ำฝน การมีข้อมูลสภาพอากาศที่ดีจึงเป็นสิ่งสำคัญสำหรับการพยากรณ์ช่วงเวลาปลูก


5.3 ข้อจำกัดของระบบ

แม้ว่าระบบ Farmme จะมีประสิทธิภาพที่ดีและมีศักยภาพสูงในการนำไปใช้งานจริง แต่ยังมีข้อจำกัดบางประการที่ควรพิจารณา ดังนี้

5.3.1 ข้อจำกัดด้านข้อมูล

การใช้ข้อมูลสังเคราะห์: ระบบได้รับการฝึกด้วยข้อมูลสังเคราะห์ที่สร้างขึ้นเพื่อจำลองข้อมูลจริง แม้ว่าข้อมูลจะมีคุณสมบัติทางสถิติที่สอดคล้องกับข้อมูลจริงและมีความสัมพันธ์เชิงพื้นที่และเวลาที่สมจริง แต่อาจมีรูปแบบหรือความสัมพันธ์บางอย่างที่แตกต่างจากข้อมูลจริง เช่น ผลกระทบของนโยบายรัฐบาล เหตุการณ์พิเศษ หรือพฤติกรรมของตลาดที่ซับซ้อน ดังนั้น เมื่อนำระบบไปใช้งานจริง ควรมีการเก็บรวบรวมข้อมูลจริงและปรับปรุงโมเดลอย่างต่อเนื่อง

ความครอบคลุมของพืช: ระบบปัจจุบันครอบคลุมพืช 46 ชนิด ซึ่งเป็นพืชหลักที่เกษตรกรไทยนิยมปลูก แต่ยังมีพืชเฉพาะทางหรือพืชใหม่ๆ ที่ยังไม่ได้รวมอยู่ในระบบ เช่น พืชสมุนไพรบางชนิด พืชไม้ดอกไม้ประดับ หรือพืชเศรษฐกิจใหม่ที่กำลังได้รับความนิยม การขยายความครอบคลุมของพืชจะช่วยให้ระบบมีประโยชน์มากขึ้น

ความครอบคลุมทางภูมิศาสตร์: แม้ว่าระบบจะครอบคลุม 77 จังหวัดทั่วประเทศ แต่ข้อมูลในระดับตำบลหรือหมู่บ้านอาจมีความแตกต่างกันมาก โดยเฉพาะในจังหวัดที่มีความหลากหลายทางภูมิประเทศ เช่น จังหวัดที่มีทั้งพื้นที่ราบและพื้นที่ภูเขา การมีข้อมูลในระดับที่ละเอียดกว่าจะช่วยเพิ่มความแม่นยำของระบบ

5.3.2 ข้อจำกัดด้านโมเดล

ประสิทธิภาพสำหรับพืชราคาสูง: Model C มีประสิทธิภาพต่ำสำหรับพืชราคาสูง (R² = 0.0814, MAE = 24.01 บาท/กก.) เนื่องจากพืชเหล่านี้มีความผันผวนสูงและได้รับอิทธิพลจากปัจจัยหลายอย่างที่ยากต่อการคาดการณ์ เช่น แฟชั่นการบริโภค ความนิยมในการส่งออก และการแข่งขันจากประเทศอื่น แม้ว่าระบบจะแสดง Confidence ต่ำและ Price Range กว้างสำหรับกลุ่มนี้ แต่ความแม่นยำที่ต่ำอาจทำให้เกษตรกรที่ปลูกพืชราคาสูงไม่ได้รับประโยชน์เต็มที่จากระบบ

การพึ่งพาข้อมูลสภาพอากาศ: Model B และ Model C พึ่งพาข้อมูลสภาพอากาศอย่างมาก ในกรณีที่ข้อมูลสภาพอากาศไม่สมบูรณ์ ไม่แม่นยำ หรือไม่สามารถเข้าถึงได้ ประสิทธิภาพของโมเดลอาจลดลง นอกจากนี้ การพยากรณ์สภาพอากาศในระยะยาว (มากกว่า 7 วัน) มักมีความไม่แน่นอนสูง ซึ่งอาจส่งผลต่อความแม่นยำของการพยากรณ์ช่วงเวลาปลูกและราคา

การปรับตัวกับการเปลี่ยนแปลง: โมเดล Machine Learning มีข้อจำกัดในการปรับตัวกับการเปลี่ยนแปลงที่ไม่เคยเกิดขึ้นมาก่อน เช่น โรคระบาดใหม่ (เช่น COVID-19) นโยบายรัฐบาลที่เปลี่ยนแปลงกะทันหัน (เช่น การเปิด-ปิดการส่งออก) หรือภัยธรรมชาติที่รุนแรงผิดปกติ (เช่น ภัยแล้งหรือน้ำท่วมที่รุนแรงกว่าที่เคยเกิดขึ้น) ในกรณีเหล่านี้ โมเดลอาจให้คำแนะนำที่ไม่เหมาะสม

5.3.3 ข้อจำกัดด้านการใช้งาน

ความต้องการอินเทอร์เน็ต: ระบบเป็นแอปพลิเคชันเว็บที่ต้องการการเชื่อมต่ออินเทอร์เน็ตในการใช้งาน ซึ่งอาจเป็นข้อจำกัดสำหรับเกษตรกรในพื้นที่ห่างไกลที่มีสัญญาณอินเทอร์เน็ตไม่เสถียรหรือไม่มีอินเทอร์เน็ต การพัฒนาเวอร์ชัน Offline หรือ Mobile App ที่สามารถทำงานได้โดยไม่ต้องเชื่อมต่ออินเทอร์เน็ตตลอดเวลาอาจช่วยแก้ปัญหานี้

ความรู้ทางเทคโนโลยี: แม้ว่าระบบจะออกแบบให้ใช้งานง่าย แต่เกษตรกรบางกลุ่มโดยเฉพาะผู้สูงอายุอาจมีความรู้ทางเทคโนโลยีจำกัดและไม่คุ้นเคยกับการใช้งานแอปพลิเคชันเว็บ การมีคู่มือการใช้งานที่ชัดเจน วิดีโอสอนการใช้งาน หรือการฝึกอบรมอาจช่วยเพิ่มการยอมรับและการใช้งานระบบ

ความเชื่อมั่นและการยอมรับ: เกษตรกรบางกลุ่มอาจไม่เชื่อมั่นในคำแนะนำจากระบบ AI โดยเฉพาะหากคำแนะนำขัดแย้งกับประสบการณ์หรือความเชื่อดั้งเดิม การสร้างความเชื่อมั่นต้องอาศัยเวลาและการแสดงให้เห็นถึงประสิทธิภาพของระบบในการใช้งานจริง การมีระบบ Explainable AI ที่สามารถอธิบายเหตุผลของคำแนะนำได้จะช่วยสร้างความเชื่อมั่น

ต้นทุนในการใช้งาน: แม้ว่าระบบจะเป็น Free Tier ในปัจจุบัน แต่หากมีการใช้งานเพิ่มขึ้นอาจต้องมีค่าใช้จ่ายในการ Upgrade Service หรือการบำรุงรักษาระบบ การหาแหล่งทุนหรือการสนับสนุนจากภาครัฐหรือเอกชนอาจจำเป็นเพื่อให้ระบบสามารถให้บริการได้อย่างยั่งยืน


5.4 ประโยชน์ที่คาดว่าจะได้รับ

5.4.1 ประโยชน์ต่อเกษตรกร

การเพิ่มประสิทธิภาพการตัดสินใจ: เกษตรกรจะได้รับข้อมูลและคำแนะนำที่มีความน่าเชื่อถือสูงในการตัดสินใจเลือกพืช กำหนดช่วงเวลาปลูก และเก็บเกี่ยว ซึ่งจะช่วยลดความเสี่ยงจากการตัดสินใจที่ไม่เหมาะสมและเพิ่มโอกาสความสำเร็จในการเพาะปลูก

การเพิ่มรายได้: จากการทดสอบพบว่า Model D สามารถเพิ่มกำไรได้ร้อยละ 12.3 เมื่อเทียบกับกลยุทธ์การเก็บเกี่ยวทันที นอกจากนี้ การเลือกพืชที่เหมาะสมและการปลูกในช่วงเวลาที่เหมาะสมยังช่วยเพิ่มผลผลิตและลดความเสียหาย ซึ่งจะนำไปสู่รายได้ที่เพิ่มขึ้น

การลดความเสี่ยง: ระบบช่วยให้เกษตรกรสามารถประเมินความเสี่ยงของการเพาะปลูกพืชแต่ละชนิดได้ และเลือกพืชที่มีความเสี่ยงเหมาะสมกับความสามารถในการรับความเสี่ยงของตนเอง นอกจากนี้ การพยากรณ์ช่วงเวลาปลูกยังช่วยลดความเสี่ยงจากภัยธรรมชาติ

การวางแผนทางการเงิน: การพยากรณ์ราคาช่วยให้เกษตรกรสามารถวางแผนทางการเงินล่วงหน้า คาดการณ์รายได้ที่จะได้รับ และตัดสินใจว่าควรขายผลผลิตทันทีหรือเก็บรักษาไว้เพื่อรอขายในช่วงที่ราคาสูงขึ้น

การเข้าถึงความรู้: เกษตรกรจะได้รับความรู้เกี่ยวกับปัจจัยที่มีผลต่อความสำเร็จของการเพาะปลูก เช่น ความสำคัญของสภาพอากาศ ความต้องการน้ำของพืชแต่ละชนิด และรูปแบบตามฤดูกาลของราคา ซึ่งจะช่วยพัฒนาทักษะและความเข้าใจในการเกษตร

5.4.2 ประโยชน์ต่อภาคการเกษตร

การเพิ่มประสิทธิภาพการผลิต: การใช้ระบบในวงกว้างจะช่วยเพิ่มประสิทธิภาพการผลิตของภาคการเกษตรโดยรวม ลดการสูญเสียจากการเพาะปลูกที่ไม่เหมาะสม และเพิ่มผลผลิตต่อหน่วยพื้นที่

การกระจายความเสี่ยง: หากเกษตรกรหลายรายใช้ระบบในการตัดสินใจ อาจช่วยกระจายการปลูกพืชให้หลากหลายขึ้น ลดปัญหาการปลูกพืชชนิดเดียวกันพร้อมกันจำนวนมากที่ทำให้ราคาตกต่ำ

การสนับสนุนนโยบาย: ข้อมูลที่เก็บรวบรวมจากการใช้งานระบบสามารถนำไปใช้ในการวิเคราะห์และกำหนดนโยบายการเกษตรของภาครัฐได้ เช่น การวางแผนการผลิต การกำหนดราคารับซื้อ หรือการสนับสนุนพืชบางชนิด

การพัฒนาเทคโนโลยี: โครงการนี้แสดงให้เห็นถึงศักยภาพของการนำ Machine Learning มาใช้ในภาคการเกษตร ซึ่งอาจเป็นแรงบันดาลใจให้มีการพัฒนาเทคโนโลยีอื่นๆ ที่เกี่ยวข้องต่อไป

5.4.3 ประโยชน์ต่อสังคมและเศรษฐกิจ

การสร้างความมั่นคงทางอาหาร: การเพิ่มประสิทธิภาพการผลิตและลดความสูญเสียจะช่วยเพิ่มปริมาณผลผลิตทางการเกษตร ซึ่งจะนำไปสู่ความมั่นคงทางอาหารของประเทศ

การลดความเหลื่อมล้ำ: การให้เกษตรกรเข้าถึงเทคโนโลยีและความรู้ที่เคยจำกัดอยู่เฉพาะกลุ่มจะช่วยลดความเหลื่อมล้ำระหว่างเกษตรกรขนาดใหญ่และขนาดเล็ก

การพัฒนาชนบท: การเพิ่มรายได้ของเกษตรกรจะนำไปสู่การพัฒนาเศรษฐกิจในชนบท เพิ่มกำลังซื้อ และปรับปรุงคุณภาพชีวิต

การส่งเสริมการใช้เทคโนโลยี: โครงการนี้เป็นตัวอย่างของการนำเทคโนโลยีดิจิทัลมาใช้ในภาคการเกษตร ซึ่งอาจส่งเสริมให้มีการใช้เทคโนโลยีอื่นๆ เพิ่มขึ้น เช่น IoT, Drone, หรือ Precision Agriculture


5.5 ข้อเสนอแนะสำหรับการพัฒนาในอนาคต

5.5.1 การปรับปรุงโมเดล

การใช้ข้อมูลจริง: ควรมีการเก็บรวบรวมข้อมูลจริงจากการใช้งานระบบและนำมาใช้ในการปรับปรุงโมเดลอย่างต่อเนื่อง การใช้ข้อมูลจริงจะช่วยให้โมเดลสามารถจับรูปแบบที่แท้จริงของข้อมูลได้ดีขึ้น และปรับตัวกับการเปลี่ยนแปลงของตลาดและสภาพแวดล้อม

การพัฒนาโมเดลเฉพาะสำหรับพืชราคาสูง: เนื่องจาก Model C มีประสิทธิภาพต่ำสำหรับพืชราคาสูง ควรพัฒนาโมเดลเฉพาะสำหรับพืชแต่ละชนิดในกลุ่มนี้ โดยบูรณาการข้อมูลเพิ่มเติม เช่น ข้อมูลการส่งออก แฟชั่นการบริโภค ราคาในตลาดโลก และข่าวสารที่เกี่ยวข้อง

การใช้ Deep Learning: สำหรับข้อมูลที่มีความซับซ้อนสูง เช่น ข้อมูลภาพจากดาวเทียมหรือข้อมูลอนุกรมเวลาที่มีรูปแบบซับซ้อน การใช้ Deep Learning เช่น LSTM, GRU หรือ Transformer อาจช่วยเพิ่มประสิทธิภาพได้ อย่างไรก็ตาม ต้องมีข้อมูลจำนวนมากเพียงพอและต้องระวังปัญหา Overfitting

การพัฒนา Ensemble Methods: การรวมโมเดลหลายตัวเข้าด้วยกัน (Ensemble) อาจช่วยเพิ่มความแม่นยำและความทนทานของระบบ เช่น การใช้ Stacking ที่รวม Gradient Boosting, XGBoost และ Neural Network เข้าด้วยกัน

การปรับปรุง Feature Engineering: ควรมีการทดลองสร้างคุณลักษณะใหม่ๆ ที่อาจมีผลต่อการทำนาย เช่น ดัชนีสภาพอากาศที่ซับซ้อนขึ้น ตัวชี้วัดเศรษฐกิจเพิ่มเติม หรือข้อมูลจากโซเชียลมีเดียที่สะท้อนความนิยมของพืชแต่ละชนิด

การใช้ Online Learning: การพัฒนาโมเดลที่สามารถเรียนรู้และอัปเดตตัวเองอย่างต่อเนื่องเมื่อมีข้อมูลใหม่ (Online Learning) จะช่วยให้โมเดลสามารถปรับตัวกับการเปลี่ยนแปลงได้เร็วขึ้น โดยเฉพาะสำหรับ Model C และ Model D ที่ต้องการความทันสมัย

5.5.2 การขยายความสามารถของระบบ

การเพิ่มความครอบคลุมของพืช: ควรขยายจำนวนพืชที่ระบบรองรับให้ครอบคลุมพืชเฉพาะทางและพืชใหม่ๆ ที่กำลังได้รับความนิยม เช่น พืชสมุนไพร พืชไม้ดอกไม้ประดับ หรือพืชเศรษฐกิจใหม่ เช่น กัญชา (ในกรณีที่ถูกกฎหมาย)

การเพิ่มความละเอียดทางภูมิศาสตร์: ควรพัฒนาระบบให้สามารถให้คำแนะนำในระดับตำบลหรือหมู่บ้าน โดยใช้ข้อมูลภาพจากดาวเทียมหรือข้อมูล GIS เพื่อวิเคราะห์สภาพพื้นที่ในระดับที่ละเอียดกว่า

การบูรณาการกับ IoT: การเชื่อมต่อกับเซ็นเซอร์ IoT ที่ติดตั้งในฟาร์ม เช่น เซ็นเซอร์วัดความชื้นในดิน อุณหภูมิ หรือปริมาณน้ำฝน จะช่วยให้ระบบได้รับข้อมูลแบบ Real-time และสามารถให้คำแนะนำที่แม่นยำและทันสมัยมากขึ้น

การพัฒนาระบบแจ้งเตือน: ควรพัฒนาระบบแจ้งเตือนที่สามารถส่งข้อความหรือการแจ้งเตือนไปยังเกษตรกรเมื่อมีสถานการณ์สำคัญ เช่น ราคาเปลี่ยนแปลงอย่างมีนัยสำคัญ สภาพอากาศผิดปกติ หรือถึงเวลาที่เหมาะสมในการเก็บเกี่ยว

การเพิ่มฟีเจอร์การจัดการฟาร์ม: ควรเพิ่มฟีเจอร์อื่นๆ ที่ช่วยในการจัดการฟาร์ม เช่น การบันทึกค่าใช้จ่าย การติดตามผลผลิต การวางแผนการปลูกหมุนเวียน หรือการจัดการแรงงาน

การพัฒนา Mobile Application: ควรพัฒนาแอปพลิเคชันมือถือที่สามารถทำงานได้ทั้งแบบ Online และ Offline เพื่อให้เกษตรกรสามารถเข้าถึงระบบได้สะดวกมากขึ้น โดยเฉพาะในพื้นที่ที่มีสัญญาณอินเทอร์เน็ตไม่เสถียร

5.5.3 การเพิ่มความน่าเชื่อถือและการยอมรับ

การพัฒนา Explainable AI: ควรพัฒนาระบบอธิบายเหตุผลของคำแนะนำให้ละเอียดและเข้าใจง่ายมากขึ้น โดยใช้เทคนิค SHAP, LIME หรือ Attention Mechanism เพื่อแสดงให้เห็นว่าปัจจัยใดมีผลต่อการตัดสินใจของโมเดลมากที่สุด

การทดสอบในพื้นที่จริง: ควรมีการทดสอบระบบในพื้นที่จริงกับเกษตรกรจริง เพื่อเก็บรวบรวม Feedback และปรับปรุงระบบให้เหมาะสมกับการใช้งานจริง การมี Case Study ที่แสดงให้เห็นถึงความสำเร็จของการใช้งานจะช่วยสร้างความเชื่อมั่น

การพัฒนาคู่มือและการฝึกอบรม: ควรจัดทำคู่มือการใช้งานที่ชัดเจน วิดีโอสอนการใช้งาน และจัดการฝึกอบรมให้กับเกษตรกร โดยเฉพาะผู้สูงอายุหรือผู้ที่มีความรู้ทางเทคโนโลยีจำกัด

การสร้างชุมชนผู้ใช้งาน: ควรสร้างชุมชนออนไลน์หรือกลุ่มผู้ใช้งานที่สามารถแลกเปลี่ยนประสบการณ์ ถามตอบปัญหา และแบ่งปันความรู้ซึ่งกันและกัน ซึ่งจะช่วยเพิ่มการยอมรับและการใช้งานระบบ

การรับรองจากหน่วยงานที่เชื่อถือได้: การได้รับการรับรองหรือการสนับสนุนจากหน่วยงานราชการ เช่น กระทรวงเกษตรและสหกรณ์ หรือมหาวิทยาลัย จะช่วยสร้างความเชื่อมั่นให้กับเกษตรกร

5.5.4 การพัฒนาด้านธุรกิจและความยั่งยืน

การหาแหล่งทุน: ควรหาแหล่งทุนหรือการสนับสนุนจากภาครัฐ เอกชน หรือองค์กรระหว่างประเทศ เพื่อให้ระบบสามารถให้บริการได้อย่างยั่งยืนและพัฒนาต่อไป

การพัฒนาโมเดลธุรกิจ: ควรพัฒนาโมเดลธุรกิจที่เหมาะสม เช่น Freemium Model ที่ให้บริการพื้นฐานฟรีและเก็บค่าบริการสำหรับฟีเจอร์ขั้นสูง หรือ Subscription Model สำหรับเกษตรกรขนาดใหญ่หรือองค์กร

การสร้างพันธมิตร: ควรสร้างพันธมิตรกับองค์กรที่เกี่ยวข้อง เช่น ธนาคารเพื่อการเกษตรและสหกรณ์การเกษตร (ธ.ก.ส.) บริษัทเมล็ดพันธุ์ บริษัทปุ๋ย หรือตลาดกลางสินค้าเกษตร เพื่อขยายการเข้าถึงและเพิ่มมูลค่าให้กับระบบ

การพัฒนา API สำหรับองค์กรอื่น: ควรพัฒนา API ที่องค์กรอื่นสามารถนำไปใช้บูรณาการกับระบบของตนเอง เช่น ระบบของธนาคาร ระบบของบริษัทประกันภัย หรือระบบของหน่วยงานราชการ

การวิจัยและพัฒนาอย่างต่อเนื่อง: ควรมีการวิจัยและพัฒนาอย่างต่อเนื่อง ติดตามเทคโนโลยีใหม่ๆ และนำมาประยุกต์ใช้ เพื่อให้ระบบมีความทันสมัยและมีประสิทธิภาพสูงอยู่เสมอ


5.6 บทสรุป

โครงการ Farmme แสดงให้เห็นถึงศักยภาพของการนำเทคโนโลยี Machine Learning มาใช้ในภาคการเกษตรเพื่อช่วยเหลือเกษตรกรในการตัดสินใจตลอดวงจรการเพาะปลูก ระบบที่พัฒนาขึ้นประกอบด้วย 4 โมเดลหลักที่ทำงานร่วมกันเป็น End-to-End Pipeline โดยแต่ละโมเดลมีประสิทธิภาพที่ดีถึงดีมาก และสามารถให้คำแนะนำที่มีความน่าเชื่อถือสูง

ความสำเร็จของโครงการนี้มาจากการให้ความสำคัญกับหลายปัจจัย ได้แก่ การเลือกใช้อัลกอริทึมที่เหมาะสมกับลักษณะของปัญหา การออกแบบ Feature Engineering ที่ดี การป้องกันการรั่วไหลของข้อมูลอย่างเป็นระบบ การลดอคติทางเวลา และการพัฒนาระบบที่สามารถอธิบายเหตุผลของคำแนะนำได้

แม้ว่าระบบจะมีข้อจำกัดบางประการ เช่น การใช้ข้อมูลสังเคราะห์ ความครอบคลุมของพืชที่จำกัด และประสิทธิภาพที่ต่ำสำหรับพืชราคาสูง แต่ข้อจำกัดเหล่านี้สามารถแก้ไขได้ผ่านการพัฒนาต่อเนื่อง การเก็บรวบรวมข้อมูลจริง และการปรับปรุงโมเดล

ประโยชน์ที่คาดว่าจะได้รับจากระบบมีหลายด้าน ทั้งต่อเกษตรกรโดยตรงในด้านการเพิ่มรายได้และลดความเสี่ยง ต่อภาคการเกษตรในด้านการเพิ่มประสิทธิภาพการผลิต และต่อสังคมและเศรษฐกิจในด้านการสร้างความมั่นคงทางอาหารและการลดความเหลื่อมล้ำ

การพัฒนาในอนาคตควรมุ่งเน้นไปที่การปรับปรุงโมเดลด้วยข้อมูลจริง การขยายความสามารถของระบบ การเพิ่มความน่าเชื่อถือและการยอมรับ และการพัฒนาด้านธุรกิจเพื่อความยั่งยืน การบูรณาการกับเทคโนโลยีอื่นๆ เช่น IoT, Drone หรือ Blockchain อาจช่วยเพิ่มมูลค่าและประสิทธิภาพของระบบได้มากขึ้น

โครงการนี้เป็นก้าวแรกที่สำคัญในการนำ AI มาใช้ในภาคการเกษตรไทย และหวังว่าจะเป็นแรงบันดาลใจให้มีการพัฒนาเทคโนโลยีอื่นๆ ที่เกี่ยวข้องต่อไป เพื่อช่วยยกระดับภาคการเกษตรไทยให้ทันสมัย มีประสิทธิภาพ และยั่งยืน ซึ่งจะนำไปสู่การพัฒนาเศรษฐกิจและสังคมของประเทศในระยะยาว

ในท้ายที่สุด ความสำเร็จของระบบในการใช้งานจริงจะขึ้นอยู่กับหลายปัจจัย ทั้งความพร้อมของข้อมูล การยอมรับของเกษตรกร การสนับสนุนจากภาครัฐและเอกชน และการพัฒนาอย่างต่อเนื่อง การทำงานร่วมกันระหว่างนักวิจัย นักพัฒนา เกษตรกร และหน่วยงานที่เกี่ยวข้องจะเป็นกุญแจสำคัญในการนำระบบไปสู่การใช้งานจริงและสร้างผลกระทบเชิงบวกต่อภาคการเกษตรไทยอย่างแท้จริง



ภาคผนวก

ภาคผนวก ก: รายละเอียดเทคนิคของโมเดล

ก.1 Model A: ระบบแนะนำพืช

อัลกอริทึม: Gradient Boosting Regressor
ไฮเปอร์พารามิเตอร์:
- n_estimators: 200
- learning_rate: 0.1
- max_depth: 5
- min_samples_split: 10
- min_samples_leaf: 4
- subsample: 0.8
- random_state: 42

คุณลักษณะที่ใช้ (Features):
1. ข้อมูลพื้นฐานของพืช: ชนิดพืช, ระยะเวลาเจริญเติบโต
2. ข้อมูลทางภูมิศาสตร์: จังหวัด, ภูมิภาค, ความสูงจากระดับน้ำทะเล
3. ข้อมูลสภาพอากาศ: อุณหภูมิเฉลี่ย, ปริมาณน้ำฝน, ความชื้น
4. ข้อมูลทางเศรษฐกิจ: ราคาเฉลี่ยของพืช, ต้นทุนการลงทุน, ผลผลิตที่คาดหวัง
5. ข้อมูลตามฤดูกาล: เดือน, ไตรมาส, ฤดูกาล

ตัวชี้วัดประสิทธิภาพ:
- R² Score: 0.9210
- RMSE: 8,234.56 บาท
- MAE: 5,891.23 บาท
- MAPE: 25.71%
- Top-5 Ranking Accuracy: 20%
- Overfitting Gap: 4.87%


ก.2 Model B: ระบบพยากรณ์ช่วงเวลาปลูก

อัลกอริทึม: Gradient Boosting Classifier
ไฮเปอร์พารามิเตอร์:
- n_estimators: 150
- learning_rate: 0.1
- max_depth: 4
- min_samples_split: 8
- min_samples_leaf: 3
- subsample: 0.8
- random_state: 42

คุณลักษณะที่ใช้ (Features):
1. ข้อมูลสภาพอากาศ 30 วันก่อนปลูก: อุณหภูมิเฉลี่ย, อุณหภูมิสูงสุด, อุณหภูมิต่ำสุด
2. ปริมาณน้ำฝนสะสม 30 วัน
3. ความชื้นเฉลี่ย
4. ข้อมูลพื้นฐานของพืช: ชนิดพืช, ความต้องการน้ำ, ความทนทานต่ออุณหภูมิ
5. ข้อมูลทางภูมิศาสตร์: จังหวัด, ภูมิภาค
6. ข้อมูลตามฤดูกาล: เดือน, ฤดูกาล

ตัวชี้วัดประสิทธิภาพ:
- Accuracy: 0.8488
- Precision: 0.7692
- Recall: 0.9393
- F1-Score: 0.8488
- AUC-ROC: 0.9156
- Overfitting Gap: 3.21%


ก.3 Model C: ระบบพยากรณ์ราคา

อัลกอริทึม: Stratified Gradient Boosting (แบ่งเป็น 3 กลุ่มตามช่วงราคา)

กลุ่มพืชราคาต่ำ (0-20 บาท/กก., 52% ของตลาด):
ไฮเปอร์พารามิเตอร์:
- n_estimators: 200
- learning_rate: 0.05
- max_depth: 4
- min_samples_split: 10
- subsample: 0.8

ตัวชี้วัดประสิทธิภาพ:
- R² Score: 0.7722
- MAE: 2.17 บาท/กก.
- RMSE: 3.45 บาท/กก.
- MAPE: 18.3%

กลุ่มพืชราคากลาง (20-50 บาท/กก., 31% ของตลาด):
ไฮเปอร์พารามิเตอร์:
- n_estimators: 180
- learning_rate: 0.08
- max_depth: 5
- min_samples_split: 8
- subsample: 0.8

ตัวชี้วัดประสิทธิภาพ:
- R² Score: 0.6891
- MAE: 8.34 บาท/กก.
- RMSE: 12.56 บาท/กก.
- MAPE: 24.7%

กลุ่มพืชราคาสูง (>50 บาท/กก., 17% ของตลาด):
ไฮเปอร์พารามิเตอร์:
- n_estimators: 150
- learning_rate: 0.1
- max_depth: 6
- min_samples_split: 6
- subsample: 0.8

ตัวชี้วัดประสิทธิภาพ:
- R² Score: 0.0814
- MAE: 24.01 บาท/กก.
- RMSE: 38.92 บาท/กก.
- MAPE: 42.1%

คุณลักษณะที่ใช้ (Features):
1. ราคาในอดีต: Lag 1-7 วัน, Lag 30 วัน
2. สถิติแบบกลิ้ง: ค่าเฉลี่ย 7, 14, 30 วัน, ส่วนเบี่ยงเบนมาตรฐาน
3. ข้อมูลสภาพอากาศ: อุณหภูมิ, ปริมาณน้ำฝน, ความชื้น
4. ตัวชี้วัดเศรษฐกิจ: ดัชนีราคาผู้บริโภค, อัตราแลกเปลี่ยน
5. ข้อมูลตามฤดูกาล: เดือน, ไตรมาส, ฤดูกาล
6. ข้อมูลพื้นฐานของพืช: ชนิดพืช, ปริมาณผลผลิตในตลาด

ประสิทธิภาพรวม:
- R² Score: 0.7589
- MAE: 6.97 บาท/กก.
- RMSE: 10.23 บาท/กก.
- MAPE: 23.8%


ก.4 Model D: ระบบตัดสินใจเก็บเกี่ยว

อัลกอริทึม: Thompson Sampling (Multi-Armed Bandit)
พารามิเตอร์:
- จำนวนทางเลือก (Arms): 3 (เก็บเกี่ยวทันที, รอ 7 วัน, รอ 14 วัน)
- Prior Distribution: Beta(1, 1) สำหรับแต่ละทางเลือก
- Reward Function: กำไรสุทธิ = (ราคาขาย × ผลผลิต) - ต้นทุนการเก็บรักษา
- Exploration-Exploitation Balance: อัตโนมัติผ่าน Thompson Sampling

ตัวชี้วัดประสิทธิภาพ:
- Decision Accuracy: 48.88%
- Profit Efficiency: 96.84%
- Average Profit Gain: +12.3% เทียบกับกลยุทธ์เก็บเกี่ยวทันที
- Regret Rate: 3.16%

กลไกการทำงาน:
1. สำหรับแต่ละสถานการณ์ ระบบจะสุ่มตัวอย่างจาก Beta Distribution ของแต่ละทางเลือก
2. เลือกทางเลือกที่มีค่าสุ่มสูงสุด
3. สังเกต Reward ที่ได้รับจากทางเลือกนั้น
4. อัปเดต Beta Distribution ของทางเลือกนั้นตาม Reward ที่ได้รับ
5. ทำซ้ำสำหรับสถานการณ์ถัดไป



ภาคผนวก ข: รายละเอียดข้อมูลที่ใช้

ข.1 ข้อมูลพืช (46 ชนิด)

พืชผัก (15 ชนิด):
1. กะหล่ำปลี
2. คะน้า
3. ผักบุ้ง
4. ผักกาดหอม
5. มะเขือเทศ
6. พริก
7. ถั่วฝักยาว
8. แตงกวา
9. ฟักทอง
10. มะระ
11. บวบ
12. ข้าวโพดหวาน
13. หน่อไม้ฝรั่ง
14. กะเพรา
15. โหระพา

พืชผลไม้ (12 ชนิด):
1. มะม่วง
2. ทุเรียน
3. มังคุด
4. ลำไย
5. ลิ้นจี่
6. เงาะ
7. กล้วย
8. มะละกอ
9. สับปะรด
10. ส้ม
11. ฝรั่ง
12. แตงโม

พืชไร่ (10 ชนิด):
1. ข้าว
2. ข้าวโพด
3. มันสำปะหลัง
4. อ้อย
5. ถั่วเหลือง
6. ถั่วลิสง
7. งา
8. ปอ
9. ยางพารา
10. ปาล์มน้ำมัน

พืชเครื่องเทศและสมุนไพร (9 ชนิด):
1. ขิง
2. ข่า
3. ตะไคร้
4. กระเทียม
5. หอมแดง
6. พริกไทย
7. ใบมะกรูด
8. ผักชี
9. โหระพา


ข.2 ข้อมูลทางภูมิศาสตร์

จำนวนจังหวัดที่ครอบคลุม: 77 จังหวัด
แบ่งตามภูมิภาค:
- ภาคเหนือ: 17 จังหวัด
- ภาคตะวันออกเฉียงเหนือ: 20 จังหวัด
- ภาคกลาง: 26 จังหวัด
- ภาคตะวันออก: 7 จังหวัด
- ภาคตะวันตก: 5 จังหวัด
- ภาคใต้: 14 จังหวัด

ข้อมูลที่เก็บรวบรวมสำหรับแต่ละจังหวัด:
- ความสูงจากระดับน้ำทะเลเฉลี่ย
- ประเภทดิน
- ปริมาณน้ำฝนเฉลี่ยต่อปี
- อุณหภูมิเฉลี่ยต่อปี
- ความชื้นเฉลี่ยต่อปี
- พื้นที่เพาะปลูกทั้งหมด
- จำนวนเกษตรกร

ข.3 ข้อมูลสภาพอากาศ

แหล่งข้อมูล: กรมอุตุนิยมวิทยา
ความถี่ในการเก็บข้อมูล: รายวัน
ระยะเวลาข้อมูล: 10 ปี (2014-2024)

ตัวแปรที่เก็บรวบรวม:
1. อุณหภูมิ (°C):
   - อุณหภูมิเฉลี่ย
   - อุณหภูมิสูงสุด
   - อุณหภูมิต่ำสุด

2. ปริมาณน้ำฝน (มม.):
   - ปริมาณน้ำฝนรายวัน
   - ปริมาณน้ำฝนสะสม 7 วัน
   - ปริมาณน้ำฝนสะสม 30 วัน

3. ความชื้น (%):
   - ความชื้นเฉลี่ย
   - ความชื้นสูงสุด
   - ความชื้นต่ำสุด

4. ความเร็วลม (กม./ชม.):
   - ความเร็วลมเฉลี่ย
   - ความเร็วลมสูงสุด

5. แสงแดด (ชม./วัน):
   - ระยะเวลาแสงแดด


ข.4 ข้อมูลราคาและเศรษฐกิจ

แหล่งข้อมูลราคา: กระทรวงพาณิชย์, ตลาดกลางสินค้าเกษตร
ความถี่ในการเก็บข้อมูล: รายวัน
ระยะเวลาข้อมูล: 10 ปี (2014-2024)

ตัวแปรราคา:
- ราคาขายส่งเฉลี่ย (บาท/กก.)
- ราคาขายปลีกเฉลี่ย (บาท/กก.)
- ราคาสูงสุด (บาท/กก.)
- ราคาต่ำสุด (บาท/กก.)
- ปริมาณการซื้อขาย (ตัน)

ตัวชี้วัดเศรษฐกิจ:
1. ดัชนีราคาผู้บริโภค (CPI)
2. อัตราแลกเปลี่ยน (บาท/ดอลลาร์)
3. ราคาน้ำมัน (บาท/ลิตร)
4. ดัชนีความเชื่อมั่นผู้บริโภค
5. GDP ภาคเกษตร

ข.5 ข้อมูลต้นทุนและผลผลิต

ข้อมูลต้นทุนการผลิต (บาท/ไร่):
- ต้นทุนเมล็ดพันธุ์/กล้าพันธุ์
- ต้นทุนปุ๋ย
- ต้นทุนยาป้องกันกำจัดศัตรูพืช
- ต้นทุนแรงงาน
- ต้นทุนเครื่องจักร
- ต้นทุนน้ำและไฟฟ้า
- ต้นทุนอื่นๆ

ข้อมูลผลผลิต:
- ผลผลิตเฉลี่ย (กก./ไร่)
- ผลผลิตสูงสุด (กก./ไร่)
- ผลผลิตต่ำสุด (กก./ไร่)
- ส่วนเบี่ยงเบนมาตรฐานของผลผลิต
- อัตราการสูญเสียหลังการเก็บเกี่ยว (%)



ภาคผนวก ค: สถาปัตยกรรมระบบ

ค.1 สถาปัตยกรรมโดยรวม

ระบบ Farmme ประกอบด้วย 3 ส่วนหลัก:

1. Frontend (Client-Side):
   - Framework: React 18.2.0
   - Language: TypeScript 5.0.2
   - UI Library: Material-UI (MUI) 5.13.0
   - State Management: React Context API
   - Routing: React Router 6.11.0
   - HTTP Client: Axios 1.4.0
   - Deployment: GitHub Pages

2. Backend (Server-Side):
   - Framework: FastAPI 0.95.0
   - Language: Python 3.10
   - Machine Learning: scikit-learn 1.2.2, pandas 2.0.0, numpy 1.24.0
   - Database: PostgreSQL 15 (สำหรับข้อมูลผู้ใช้)
   - Authentication: JWT (JSON Web Tokens)
   - Deployment: Render

3. Model Storage:
   - Model Format: Pickle (.pkl)
   - Storage: Cloud Storage (Render Persistent Disk)
   - Model Versioning: Git-based versioning

ค.2 API Endpoints

Authentication:
- POST /api/auth/register - ลงทะเบียนผู้ใช้ใหม่
- POST /api/auth/login - เข้าสู่ระบบ
- POST /api/auth/logout - ออกจากระบบ
- GET /api/auth/profile - ดึงข้อมูลโปรไฟล์ผู้ใช้

Model A (ระบบแนะนำพืช):
- POST /api/model-a/recommend - แนะนำพืชที่เหมาะสม
- GET /api/model-a/crops - ดึงรายการพืชทั้งหมด
- POST /api/model-a/predict-roi - ทำนาย ROI ของพืชที่เลือก

Model B (ระบบพยากรณ์ช่วงเวลาปลูก):
- POST /api/model-b/predict-timing - พยากรณ์ช่วงเวลาปลูก
- GET /api/model-b/weather-forecast - ดึงข้อมูลพยากรณ์อากาศ

Model C (ระบบพยากรณ์ราคา):
- POST /api/model-c/predict-price - พยากรณ์ราคาในอนาคต
- GET /api/model-c/historical-prices - ดึงข้อมูลราคาในอดีต
- GET /api/model-c/price-trends - วิเคราะห์แนวโน้มราคา

Model D (ระบบตัดสินใจเก็บเกี่ยว):
- POST /api/model-d/harvest-decision - ตัดสินใจเวลาเก็บเกี่ยว
- POST /api/model-d/update-reward - อัปเดต Reward สำหรับ Thompson Sampling

Utility:
- GET /api/provinces - ดึงรายการจังหวัด
- GET /api/weather/{province} - ดึงข้อมูลสภาพอากาศของจังหวัด
- GET /api/health - ตรวจสอบสถานะระบบ


ค.3 โครงสร้างฐานข้อมูล

ตาราง Users:
- id (Primary Key): UUID
- username: VARCHAR(50), UNIQUE
- email: VARCHAR(100), UNIQUE
- password_hash: VARCHAR(255)
- full_name: VARCHAR(100)
- phone: VARCHAR(20)
- province: VARCHAR(50)
- farm_size: DECIMAL(10,2) - ขนาดพื้นที่เพาะปลูก (ไร่)
- created_at: TIMESTAMP
- updated_at: TIMESTAMP

ตาราง Farms:
- id (Primary Key): UUID
- user_id (Foreign Key): UUID
- farm_name: VARCHAR(100)
- province: VARCHAR(50)
- district: VARCHAR(50)
- subdistrict: VARCHAR(50)
- latitude: DECIMAL(10,8)
- longitude: DECIMAL(11,8)
- farm_size: DECIMAL(10,2)
- soil_type: VARCHAR(50)
- created_at: TIMESTAMP

ตาราง Planting_Records:
- id (Primary Key): UUID
- farm_id (Foreign Key): UUID
- crop_type: VARCHAR(50)
- planting_date: DATE
- expected_harvest_date: DATE
- actual_harvest_date: DATE
- area: DECIMAL(10,2) - พื้นที่ปลูก (ไร่)
- investment_cost: DECIMAL(10,2)
- expected_yield: DECIMAL(10,2)
- actual_yield: DECIMAL(10,2)
- selling_price: DECIMAL(10,2)
- total_revenue: DECIMAL(10,2)
- roi: DECIMAL(10,2)
- created_at: TIMESTAMP

ตาราง Model_Predictions:
- id (Primary Key): UUID
- user_id (Foreign Key): UUID
- model_type: VARCHAR(10) - 'A', 'B', 'C', หรือ 'D'
- input_data: JSONB
- prediction_result: JSONB
- confidence_score: DECIMAL(5,4)
- created_at: TIMESTAMP

ตาราง Feedback:
- id (Primary Key): UUID
- user_id (Foreign Key): UUID
- prediction_id (Foreign Key): UUID
- rating: INTEGER (1-5)
- comment: TEXT
- actual_outcome: JSONB
- created_at: TIMESTAMP



ภาคผนวก ง: ตัวอย่างการใช้งาน API

ง.1 ตัวอย่างการเรียกใช้ Model A (ระบบแนะนำพืช)

Request:
POST /api/model-a/recommend
Content-Type: application/json
Authorization: Bearer <JWT_TOKEN>

{
  "province": "เชียงใหม่",
  "farm_size": 10,
  "budget": 50000,
  "risk_tolerance": "medium",
  "planting_month": 6,
  "soil_type": "ดินร่วน",
  "water_availability": "high"
}

Response:
{
  "status": "success",
  "recommendations": [
    {
      "rank": 1,
      "crop": "ข้าวโพดหวาน",
      "predicted_roi": 45230.50,
      "confidence": 0.92,
      "expected_yield": 1200,
      "investment_cost": 35000,
      "expected_revenue": 80230.50,
      "growth_period": 90,
      "risk_level": "low",
      "explanation": {
        "top_factors": [
          {"factor": "ผลผลิตที่คาดหวัง", "importance": 0.35},
          {"factor": "ต้นทุนการลงทุน", "importance": 0.28},
          {"factor": "ราคาเฉลี่ย", "importance": 0.22}
        ]
      }
    },
    {
      "rank": 2,
      "crop": "มะเขือเทศ",
      "predicted_roi": 42150.75,
      "confidence": 0.89,
      "expected_yield": 2500,
      "investment_cost": 45000,
      "expected_revenue": 87150.75,
      "growth_period": 75,
      "risk_level": "medium",
      "explanation": {
        "top_factors": [
          {"factor": "ผลผลิตที่คาดหวัง", "importance": 0.32},
          {"factor": "ราคาเฉลี่ย", "importance": 0.30},
          {"factor": "ต้นทุนการลงทุน", "importance": 0.25}
        ]
      }
    }
  ],
  "metadata": {
    "total_crops_evaluated": 46,
    "model_version": "1.0.0",
    "prediction_date": "2024-06-15T10:30:00Z"
  }
}


ง.2 ตัวอย่างการเรียกใช้ Model B (ระบบพยากรณ์ช่วงเวลาปลูก)

Request:
POST /api/model-b/predict-timing
Content-Type: application/json
Authorization: Bearer <JWT_TOKEN>

{
  "crop": "ข้าวโพดหวาน",
  "province": "เชียงใหม่",
  "target_month": 7,
  "weather_forecast": {
    "avg_temperature": 28.5,
    "total_rainfall": 180,
    "avg_humidity": 75
  }
}

Response:
{
  "status": "success",
  "prediction": {
    "is_suitable": true,
    "confidence": 0.94,
    "suitability_score": 0.87,
    "recommended_dates": [
      {
        "start_date": "2024-07-05",
        "end_date": "2024-07-12",
        "score": 0.92,
        "reason": "สภาพอากาศเหมาะสมที่สุด อุณหภูมิและความชื้นอยู่ในช่วงที่ดี"
      },
      {
        "start_date": "2024-07-20",
        "end_date": "2024-07-27",
        "score": 0.85,
        "reason": "สภาพอากาศดี แต่อาจมีฝนมากกว่าช่วงแรก"
      }
    ],
    "weather_analysis": {
      "temperature_status": "optimal",
      "rainfall_status": "good",
      "humidity_status": "optimal"
    },
    "risks": [
      {
        "type": "ฝนตกหนัก",
        "probability": 0.15,
        "impact": "medium",
        "mitigation": "เตรียมระบบระบายน้ำที่ดี"
      }
    ],
    "explanation": {
      "top_factors": [
        {"factor": "อุณหภูมิเฉลี่ย", "importance": 0.42},
        {"factor": "ปริมาณน้ำฝน", "importance": 0.35},
        {"factor": "ความชื้น", "importance": 0.18}
      ]
    }
  },
  "metadata": {
    "model_version": "1.0.0",
    "prediction_date": "2024-06-15T10:35:00Z"
  }
}


ง.3 ตัวอย่างการเรียกใช้ Model C (ระบบพยากรณ์ราคา)

Request:
POST /api/model-c/predict-price
Content-Type: application/json
Authorization: Bearer <JWT_TOKEN>

{
  "crop": "ข้าวโพดหวาน",
  "province": "เชียงใหม่",
  "forecast_days": 30,
  "current_price": 15.50
}

Response:
{
  "status": "success",
  "prediction": {
    "crop": "ข้าวโพดหวาน",
    "price_category": "low",
    "forecasts": [
      {
        "date": "2024-07-15",
        "predicted_price": 16.20,
        "confidence": 0.88,
        "price_range": {
          "lower": 14.80,
          "upper": 17.60
        }
      },
      {
        "date": "2024-07-22",
        "predicted_price": 16.80,
        "confidence": 0.85,
        "price_range": {
          "lower": 15.20,
          "upper": 18.40
        }
      },
      {
        "date": "2024-07-29",
        "predicted_price": 17.50,
        "confidence": 0.82,
        "price_range": {
          "lower": 15.80,
          "upper": 19.20
        }
      }
    ],
    "trend": "increasing",
    "trend_strength": 0.75,
    "seasonal_pattern": {
      "current_season": "ฤดูฝน",
      "typical_price_movement": "ราคามักจะเพิ่มขึ้นในช่วงนี้"
    },
    "recommendation": {
      "action": "hold",
      "reason": "ราคามีแนวโน้มเพิ่มขึ้น แนะนำให้รอขายในช่วงปลายเดือน",
      "optimal_selling_date": "2024-07-29",
      "expected_profit_increase": "12.9%"
    },
    "explanation": {
      "top_factors": [
        {"factor": "ราคา 7 วันที่แล้ว", "importance": 0.32},
        {"factor": "ค่าเฉลี่ยแบบกลิ้ง 30 วัน", "importance": 0.28},
        {"factor": "ปริมาณน้ำฝน", "importance": 0.18}
      ]
    }
  },
  "metadata": {
    "model_version": "1.0.0",
    "prediction_date": "2024-06-15T10:40:00Z"
  }
}


ง.4 ตัวอย่างการเรียกใช้ Model D (ระบบตัดสินใจเก็บเกี่ยว)

Request:
POST /api/model-d/harvest-decision
Content-Type: application/json
Authorization: Bearer <JWT_TOKEN>

{
  "crop": "ข้าวโพดหวาน",
  "province": "เชียงใหม่",
  "planting_date": "2024-04-15",
  "current_date": "2024-07-15",
  "current_price": 16.20,
  "expected_yield": 1200,
  "storage_cost_per_day": 50,
  "quality_degradation_rate": 0.01
}

Response:
{
  "status": "success",
  "decision": {
    "recommended_action": "wait_7_days",
    "confidence": 0.76,
    "expected_profit": {
      "harvest_now": 19440,
      "wait_7_days": 21360,
      "wait_14_days": 20880
    },
    "profit_comparison": {
      "wait_7_days_vs_now": "+9.9%",
      "wait_14_days_vs_now": "+7.4%"
    },
    "reasoning": {
      "price_forecast": "ราคาคาดว่าจะเพิ่มขึ้นในอีก 7 วัน",
      "quality_consideration": "คุณภาพยังคงดีในอีก 7-10 วัน",
      "storage_cost": "ต้นทุนการเก็บรักษายังไม่สูงเกินไป",
      "market_condition": "ตลาดมีความต้องการสูงในช่วงนี้"
    },
    "risks": [
      {
        "type": "ราคาอาจไม่เพิ่มขึ้นตามคาด",
        "probability": 0.24,
        "impact": "medium"
      },
      {
        "type": "คุณภาพอาจลดลง",
        "probability": 0.15,
        "impact": "low"
      }
    ],
    "alternative_scenarios": [
      {
        "scenario": "ราคาลดลง 10%",
        "expected_profit": 18720,
        "still_better_than_now": false
      },
      {
        "scenario": "ราคาเพิ่มขึ้น 15%",
        "expected_profit": 23280,
        "profit_increase": "+19.8%"
      }
    ]
  },
  "thompson_sampling_state": {
    "harvest_now": {"alpha": 45, "beta": 55},
    "wait_7_days": {"alpha": 62, "beta": 38},
    "wait_14_days": {"alpha": 38, "beta": 62}
  },
  "metadata": {
    "model_version": "1.0.0",
    "prediction_date": "2024-07-15T10:45:00Z"
  }
}



ภาคผนวก จ: กระบวนการป้องกัน Data Leakage

จ.1 หลักการป้องกัน Data Leakage

Data Leakage คือการที่ข้อมูลจากอนาคตหรือข้อมูลที่ไม่ควรมีในขั้นตอนการทำนายรั่วไหลเข้าไปในกระบวนการฝึกโมเดล ทำให้โมเดลมีประสิทธิภาพสูงเกินจริงในขั้นตอนการฝึก แต่ไม่สามารถทำงานได้ดีในการใช้งานจริง

ประเภทของ Data Leakage:
1. Temporal Leakage: การใช้ข้อมูลจากอนาคตในการทำนาย
2. Target Leakage: การใช้ข้อมูลที่มีความสัมพันธ์โดยตรงกับเป้าหมาย
3. Train-Test Contamination: การรั่วไหลของข้อมูลระหว่างชุดฝึกและชุดทดสอบ

จ.2 มาตรการป้องกันใน Model A

1. Feature Engineering:
   - ไม่ใช้ราคาปัจจุบันหรือราคาในอนาคตในการทำนาย ROI
   - ใช้เฉพาะราคาเฉลี่ยในอดีต (ย้อนหลัง 1 ปี)
   - ไม่ใช้ข้อมูลผลผลิตจริงในการทำนาย

2. การแบ่งข้อมูล:
   - แบ่งข้อมูลตามลำดับเวลา (Temporal Split)
   - ชุดฝึก: 70% ของข้อมูล (ข้อมูลเก่าสุด)
   - ชุดตรวจสอบ: 15% ของข้อมูล (ข้อมูลกลาง)
   - ชุดทดสอบ: 15% ของข้อมูล (ข้อมูลใหม่สุด)

3. การตรวจสอบ:
   - ตรวจสอบ Correlation Matrix เพื่อหาความสัมพันธ์ที่ผิดปกติ
   - ตรวจสอบ Feature Importance เพื่อดูว่ามีคุณลักษณะใดที่มีความสำคัญสูงผิดปกติ
   - ทดสอบโมเดลบนข้อมูลที่ไม่เคยเห็นมาก่อน (Out-of-Sample Testing)

จ.3 มาตรการป้องกันใน Model B

1. Feature Engineering:
   - ใช้เฉพาะข้อมูลสภาพอากาศ 30 วันก่อนวันปลูก
   - ไม่ใช้ข้อมูลสภาพอากาศหลังวันปลูก
   - ไม่ใช้ข้อมูลผลผลิตจริงในการทำนาย

2. การแบ่งข้อมูล:
   - แบ่งข้อมูลตามลำดับเวลา
   - ตรวจสอบว่าไม่มีข้อมูลจากช่วงเวลาเดียวกันในทั้งชุดฝึกและชุดทดสอบ

3. การตรวจสอบ:
   - ตรวจสอบว่าคุณลักษณะทั้งหมดสามารถคำนวณได้จากข้อมูลที่มีก่อนวันปลูก
   - ทดสอบโมเดลด้วยข้อมูลจากปีที่ไม่เคยเห็นมาก่อน


จ.4 มาตรการป้องกันใน Model C

1. Feature Engineering:
   - ใช้ shift() เพื่อสร้าง Lag Features อย่างถูกต้อง
   - คำนวณ Rolling Statistics โดยไม่รวมค่าปัจจุบัน
   - ตัวอย่างโค้ด:
     ```python
     # ถูกต้อง: ใช้ shift() เพื่อหลีกเลี่ยง Data Leakage
     df['price_lag_1'] = df['price'].shift(1)
     df['price_lag_7'] = df['price'].shift(7)
     df['rolling_mean_7'] = df['price'].shift(1).rolling(window=7).mean()
     
     # ผิด: ไม่ใช้ shift() จะทำให้เกิด Data Leakage
     # df['rolling_mean_7'] = df['price'].rolling(window=7).mean()
     ```

2. การแบ่งข้อมูล:
   - แบ่งข้อมูลตามลำดับเวลาอย่างเคร่งครัด
   - ไม่ใช้ Cross-Validation แบบสุ่ม แต่ใช้ Time Series Split
   - ตัวอย่างโค้ด:
     ```python
     from sklearn.model_selection import TimeSeriesSplit
     
     tscv = TimeSeriesSplit(n_splits=5)
     for train_index, test_index in tscv.split(X):
         X_train, X_test = X[train_index], X[test_index]
         y_train, y_test = y[train_index], y[test_index]
     ```

3. การตรวจสอบ:
   - ตรวจสอบว่าไม่มีคุณลักษณะใดที่มี Correlation สูงผิดปกติกับเป้าหมาย
   - ทดสอบโมเดลด้วยข้อมูลจากช่วงเวลาที่แตกต่างกันมาก
   - ตรวจสอบ Feature Importance เพื่อดูว่าโมเดลพึ่งพาคุณลักษณะใดมากที่สุด

จ.5 มาตรการป้องกันใน Model D

1. การออกแบบ Reward Function:
   - คำนวณ Reward จากข้อมูลที่เกิดขึ้นจริงหลังการตัดสินใจ
   - ไม่ใช้ข้อมูลราคาในอนาคตในการตัดสินใจ

2. การทดสอบ:
   - ทดสอบด้วย Backtesting บนข้อมูลในอดีต
   - จำลองสถานการณ์การตัดสินใจแบบ Real-time

3. การอัปเดตโมเดล:
   - อัปเดต Thompson Sampling Parameters เฉพาะหลังจากได้รับ Reward จริง
   - ไม่ใช้ข้อมูลจากอนาคตในการอัปเดต

จ.6 เครื่องมือตรวจสอบ Data Leakage

1. Correlation Analysis:
   ```python
   import pandas as pd
   import seaborn as sns
   import matplotlib.pyplot as plt
   
   # คำนวณ Correlation Matrix
   corr_matrix = df.corr()
   
   # แสดง Correlation กับเป้าหมาย
   target_corr = corr_matrix['target'].sort_values(ascending=False)
   print(target_corr)
   
   # ตรวจสอบว่ามีคุณลักษณะใดที่มี Correlation สูงผิดปกติ (>0.95)
   high_corr = target_corr[target_corr > 0.95]
   if len(high_corr) > 1:  # มากกว่า 1 เพราะเป้าหมายจะมี Correlation 1.0 กับตัวเอง
       print("Warning: Possible data leakage detected!")
       print(high_corr)
   ```

2. Feature Importance Analysis:
   ```python
   from sklearn.ensemble import GradientBoostingRegressor
   
   # ฝึกโมเดล
   model = GradientBoostingRegressor()
   model.fit(X_train, y_train)
   
   # ดู Feature Importance
   feature_importance = pd.DataFrame({
       'feature': X_train.columns,
       'importance': model.feature_importances_
   }).sort_values('importance', ascending=False)
   
   print(feature_importance)
   
   # ตรวจสอบว่ามีคุณลักษณะใดที่มีความสำคัญสูงผิดปกติ (>0.5)
   if feature_importance.iloc[0]['importance'] > 0.5:
       print("Warning: One feature dominates the model!")
   ```

3. Temporal Validation:
   ```python
   # แบ่งข้อมูลตามเวลา
   train_end_date = '2023-12-31'
   test_start_date = '2024-01-01'
   
   train_data = df[df['date'] <= train_end_date]
   test_data = df[df['date'] >= test_start_date]
   
   # ตรวจสอบว่าไม่มีข้อมูลซ้ำซ้อน
   assert len(set(train_data['date']) & set(test_data['date'])) == 0
   ```



ภาคผนวก ฉ: การประเมินประสิทธิภาพโมเดล

ฉ.1 ตัวชี้วัดสำหรับ Regression (Model A และ Model C)

1. R² Score (Coefficient of Determination):
   - วัดสัดส่วนความแปรปรวนของตัวแปรเป้าหมายที่โมเดลสามารถอธิบายได้
   - ค่าอยู่ระหว่าง 0 ถึง 1 (ยิ่งใกล้ 1 ยิ่งดี)
   - สูตร: R² = 1 - (SS_res / SS_tot)
   - การตีความ:
     * R² > 0.9: ดีมาก
     * 0.7 < R² ≤ 0.9: ดี
     * 0.5 < R² ≤ 0.7: ปานกลาง
     * R² ≤ 0.5: ต่ำ

2. Mean Absolute Error (MAE):
   - วัดค่าเฉลี่ยของความผิดพลาดสัมบูรณ์
   - หน่วยเดียวกับตัวแปรเป้าหมาย
   - สูตร: MAE = (1/n) × Σ|y_true - y_pred|
   - ข้อดี: เข้าใจง่าย ไม่ไวต่อ Outliers

3. Root Mean Squared Error (RMSE):
   - วัดรากที่สองของค่าเฉลี่ยของความผิดพลาดกำลังสอง
   - หน่วยเดียวกับตัวแปรเป้าหมาย
   - สูตร: RMSE = √[(1/n) × Σ(y_true - y_pred)²]
   - ข้อดี: ให้น้ำหนักมากกับความผิดพลาดที่ใหญ่

4. Mean Absolute Percentage Error (MAPE):
   - วัดค่าเฉลี่ยของความผิดพลาดเป็นเปอร์เซ็นต์
   - สูตร: MAPE = (100/n) × Σ|((y_true - y_pred) / y_true)|
   - การตีความ:
     * MAPE < 10%: ดีมาก
     * 10% ≤ MAPE < 20%: ดี
     * 20% ≤ MAPE < 50%: ยอมรับได้
     * MAPE ≥ 50%: ไม่แม่นยำ

ฉ.2 ตัวชี้วัดสำหรับ Classification (Model B)

1. Accuracy:
   - วัดสัดส่วนของการทำนายที่ถูกต้อง
   - สูตร: Accuracy = (TP + TN) / (TP + TN + FP + FN)
   - เหมาะสำหรับข้อมูลที่สมดุล

2. Precision:
   - วัดสัดส่วนของการทำนายเป็น Positive ที่ถูกต้อง
   - สูตร: Precision = TP / (TP + FP)
   - สำคัญเมื่อต้องการลด False Positive

3. Recall (Sensitivity):
   - วัดสัดส่วนของ Positive จริงที่โมเดลสามารถจับได้
   - สูตร: Recall = TP / (TP + FN)
   - สำคัญเมื่อต้องการลด False Negative

4. F1-Score:
   - ค่าเฉลี่ยฮาร์มอนิกของ Precision และ Recall
   - สูตร: F1 = 2 × (Precision × Recall) / (Precision + Recall)
   - เหมาะสำหรับข้อมูลที่ไม่สมดุล

5. AUC-ROC:
   - พื้นที่ใต้กราฟ ROC Curve
   - ค่าอยู่ระหว่าง 0 ถึง 1 (ยิ่งใกล้ 1 ยิ่งดี)
   - การตีความ:
     * AUC > 0.9: ดีมาก
     * 0.8 < AUC ≤ 0.9: ดี
     * 0.7 < AUC ≤ 0.8: ปานกลาง
     * AUC ≤ 0.7: ต่ำ


ฉ.3 ตัวชี้วัดสำหรับ Reinforcement Learning (Model D)

1. Decision Accuracy:
   - วัดสัดส่วนของการตัดสินใจที่เลือกทางเลือกที่ดีที่สุด
   - สูตร: Decision Accuracy = (จำนวนครั้งที่เลือกทางเลือกที่ดีที่สุด) / (จำนวนครั้งทั้งหมด)

2. Profit Efficiency:
   - วัดสัดส่วนของกำไรที่ได้เทียบกับกำไรสูงสุดที่เป็นไปได้
   - สูตร: Profit Efficiency = (กำไรที่ได้จริง) / (กำไรสูงสุดที่เป็นไปได้)

3. Regret:
   - วัดความแตกต่างระหว่างกำไรสูงสุดที่เป็นไปได้กับกำไรที่ได้จริง
   - สูตร: Regret = (กำไรสูงสุดที่เป็นไปได้) - (กำไรที่ได้จริง)

4. Average Profit Gain:
   - วัดการเพิ่มขึ้นของกำไรเฉลี่ยเทียบกับกลยุทธ์พื้นฐาน
   - สูตร: Profit Gain = ((กำไรเฉลี่ยจากโมเดล) - (กำไรเฉลี่ยจากกลยุทธ์พื้นฐาน)) / (กำไรเฉลี่ยจากกลยุทธ์พื้นฐาน)

ฉ.4 การตรวจสอบ Overfitting

1. Overfitting Gap:
   - วัดความแตกต่างระหว่างประสิทธิภาพบนชุดฝึกและชุดทดสอบ
   - สูตร: Overfitting Gap = (ประสิทธิภาพบนชุดฝึก) - (ประสิทธิภาพบนชุดทดสอบ)
   - การตีความ:
     * Gap < 5%: ไม่มี Overfitting
     * 5% ≤ Gap < 10%: Overfitting เล็กน้อย (ยอมรับได้)
     * 10% ≤ Gap < 20%: Overfitting ปานกลาง (ควรปรับปรุง)
     * Gap ≥ 20%: Overfitting มาก (ต้องแก้ไข)

2. Learning Curve:
   - กราฟแสดงประสิทธิภาพของโมเดลเมื่อเพิ่มขนาดข้อมูลฝึก
   - ใช้ตรวจสอบว่าโมเดลมี Overfitting หรือ Underfitting

3. Validation Curve:
   - กราฟแสดงประสิทธิภาพของโมเดลเมื่อเปลี่ยนค่า Hyperparameter
   - ใช้หาค่า Hyperparameter ที่เหมาะสม

ฉ.5 ตารางสรุปประสิทธิภาพของโมเดลทั้ง 4 ตัว

+----------+------------------+------------------+------------------+------------------+
| Model    | Model A          | Model B          | Model C          | Model D          |
+----------+------------------+------------------+------------------+------------------+
| Type     | Regression       | Classification   | Regression       | RL (MAB)         |
+----------+------------------+------------------+------------------+------------------+
| Primary  | R² = 0.9210      | F1 = 0.8488      | R² = 0.7589      | Profit Eff.      |
| Metric   |                  |                  |                  | = 96.84%         |
+----------+------------------+------------------+------------------+------------------+
| MAE/     | MAE = 5,891.23   | Recall = 0.9393  | MAE = 6.97       | Decision Acc.    |
| Accuracy | บาท              |                  | บาท/กก.          | = 48.88%         |
+----------+------------------+------------------+------------------+------------------+
| RMSE/    | RMSE = 8,234.56  | Precision =      | RMSE = 10.23     | Profit Gain      |
| AUC      | บาท              | 0.7692           | บาท/กก.          | = +12.3%         |
+----------+------------------+------------------+------------------+------------------+
| MAPE/    | MAPE = 25.71%    | AUC = 0.9156     | MAPE = 23.8%     | Regret Rate      |
| Other    |                  |                  |                  | = 3.16%          |
+----------+------------------+------------------+------------------+------------------+
| Over-    | 4.87%            | 3.21%            | 5.12%            | N/A              |
| fitting  |                  |                  |                  |                  |
| Gap      |                  |                  |                  |                  |
+----------+------------------+------------------+------------------+------------------+
| Overall  | ดีมาก            | ดี               | ดี               | ดีมาก            |
| Rating   |                  |                  |                  |                  |
+----------+------------------+------------------+------------------+------------------+



ภาคผนวก ช: คำศัพท์และคำย่อ

AI (Artificial Intelligence): ปัญญาประดิษฐ์ - เทคโนโลยีที่ทำให้เครื่องจักรสามารถเรียนรู้และตัดสินใจได้เหมือนมนุษย์

API (Application Programming Interface): ส่วนต่อประสานโปรแกรมประยุกต์ - ชุดของกฎและโปรโตคอลที่ใช้ในการสื่อสารระหว่างซอฟต์แวร์

AUC-ROC (Area Under the Receiver Operating Characteristic Curve): พื้นที่ใต้กราฟ ROC - ตัวชี้วัดประสิทธิภาพของโมเดล Classification

Backtesting: การทดสอบย้อนหลัง - การทดสอบกลยุทธ์หรือโมเดลด้วยข้อมูลในอดีต

Backend: ส่วนหลังบ้าน - ส่วนของระบบที่ทำงานบนเซิร์ฟเวอร์และจัดการข้อมูล

Beta Distribution: การแจกแจงเบตา - การแจกแจงความน่าจะเป็นที่ใช้ใน Thompson Sampling

CPI (Consumer Price Index): ดัชนีราคาผู้บริโภค - ตัวชี้วัดการเปลี่ยนแปลงของราคาสินค้าและบริการ

Cross-Validation: การตรวจสอบไขว้ - เทคนิคการประเมินประสิทธิภาพของโมเดลโดยแบ่งข้อมูลออกเป็นหลายส่วน

Data Leakage: การรั่วไหลของข้อมูล - การที่ข้อมูลจากอนาคตหรือข้อมูลที่ไม่ควรมีรั่วไหลเข้าไปในกระบวนการฝึกโมเดล

Deep Learning: การเรียนรู้เชิงลึก - สาขาหนึ่งของ Machine Learning ที่ใช้โครงข่ายประสาทเทียมหลายชั้น

Ensemble Methods: วิธีการรวมโมเดล - การรวมโมเดลหลายตัวเข้าด้วยกันเพื่อเพิ่มประสิทธิภาพ

Explainable AI (XAI): AI ที่อธิบายได้ - เทคโนโลยี AI ที่สามารถอธิบายเหตุผลของการตัดสินใจได้

F1-Score: ค่าเฉลี่ยฮาร์มอนิกของ Precision และ Recall - ตัวชี้วัดประสิทธิภาพของโมเดล Classification

FastAPI: เฟรมเวิร์กสำหรับสร้าง API ด้วย Python - เครื่องมือสำหรับพัฒนา Backend

Feature Engineering: การสร้างคุณลักษณะ - กระบวนการสร้างตัวแปรใหม่จากข้อมูลดิบเพื่อใช้ในการฝึกโมเดล

Feature Importance: ความสำคัญของคุณลักษณะ - การวัดว่าคุณลักษณะแต่ละตัวมีผลต่อการทำนายมากน้อยเพียงใด

Frontend: ส่วนหน้าบ้าน - ส่วนของระบบที่ผู้ใช้เห็นและโต้ตอบด้วย

GDP (Gross Domestic Product): ผลิตภัณฑ์มวลรวมในประเทศ - มูลค่ารวมของสินค้าและบริการที่ผลิตในประเทศ

GIS (Geographic Information System): ระบบสารสนเทศภูมิศาสตร์ - ระบบสำหรับจัดการและวิเคราะห์ข้อมูลเชิงพื้นที่

Gradient Boosting: การเพิ่มประสิทธิภาพแบบไล่ระดับ - อัลกอริทึม Machine Learning ที่สร้างโมเดลแบบต่อเนื่อง

GRU (Gated Recurrent Unit): หน่วยวนซ้ำแบบมีประตู - โครงสร้างโครงข่ายประสาทเทียมสำหรับข้อมูลอนุกรมเวลา

Hyperparameter: พารามิเตอร์ระดับสูง - ค่าที่ต้องกำหนดก่อนการฝึกโมเดล

IoT (Internet of Things): อินเทอร์เน็ตของสรรพสิ่ง - เครือข่ายของอุปกรณ์ที่เชื่อมต่อกันผ่านอินเทอร์เน็ต

JWT (JSON Web Token): โทเค็นเว็บ JSON - มาตรฐานสำหรับการสร้างโทเค็นการยืนยันตัวตน

Lag Features: คุณลักษณะแล็ก - ค่าของตัวแปรในอดีตที่ใช้เป็นคุณลักษณะในการทำนาย

LIME (Local Interpretable Model-agnostic Explanations): การอธิบายโมเดลแบบท้องถิ่น - เทคนิคสำหรับอธิบายการทำนายของโมเดล

LSTM (Long Short-Term Memory): หน่วยความจำระยะสั้นแบบยาว - โครงสร้างโครงข่ายประสาทเทียมสำหรับข้อมูลอนุกรมเวลา

MAE (Mean Absolute Error): ค่าเฉลี่ยของความผิดพลาดสัมบูรณ์ - ตัวชี้วัดความแม่นยำของโมเดล Regression

MAPE (Mean Absolute Percentage Error): ค่าเฉลี่ยของความผิดพลาดเป็นเปอร์เซ็นต์ - ตัวชี้วัดความแม่นยำของโมเดล Regression

MCP (Model Context Protocol): โปรโตคอลบริบทโมเดล - มาตรฐานสำหรับการสื่อสารระหว่างโมเดลและแอปพลิเคชัน

Machine Learning (ML): การเรียนรู้ของเครื่อง - สาขาของ AI ที่ทำให้เครื่องจักรสามารถเรียนรู้จากข้อมูล

Multi-Armed Bandit (MAB): ปัญหาเครื่องสล็อตหลายแขน - ปัญหาในการตัดสินใจที่ต้องสมดุลระหว่างการสำรวจและการใช้ประโยชน์

Overfitting: การเรียนรู้มากเกินไป - ปัญหาที่โมเดลเรียนรู้รายละเอียดของข้อมูลฝึกมากเกินไปจนไม่สามารถทำนายข้อมูลใหม่ได้ดี

Precision: ความแม่นยำ - สัดส่วนของการทำนายเป็น Positive ที่ถูกต้อง

R² Score (Coefficient of Determination): สัมประสิทธิ์การกำหนด - ตัวชี้วัดความสามารถของโมเดลในการอธิบายความแปรปรวน

Random Forest: ป่าสุ่ม - อัลกอริทึม Machine Learning ที่รวมต้นไม้ตัดสินใจหลายต้น

React: ไลบรารี JavaScript สำหรับสร้าง User Interface

Recall (Sensitivity): ความไว - สัดส่วนของ Positive จริงที่โมเดลสามารถจับได้

Reinforcement Learning (RL): การเรียนรู้เชิงเสริมแรง - สาขาของ Machine Learning ที่เรียนรู้จากการลองผิดลองถูก

RMSE (Root Mean Squared Error): รากที่สองของค่าเฉลี่ยของความผิดพลาดกำลังสอง - ตัวชี้วัดความแม่นยำของโมเดล Regression

ROI (Return on Investment): ผลตอบแทนจากการลงทุน - อัตราส่วนระหว่างกำไรและเงินลงทุน

Rolling Statistics: สถิติแบบกลิ้ง - สถิติที่คำนวณจากหน้าต่างเวลาที่เลื่อนไป

SHAP (SHapley Additive exPlanations): การอธิบายแบบ Shapley - เทคนิคสำหรับอธิบายการทำนายของโมเดล

Stratified Approach: แนวทางแบบแบ่งชั้น - การแบ่งข้อมูลออกเป็นกลุ่มย่อยและสร้างโมเดลแยกสำหรับแต่ละกลุ่ม

Thompson Sampling: การสุ่มตัวอย่างแบบทอมป์สัน - อัลกอริทึมสำหรับแก้ปัญหา Multi-Armed Bandit

Time Series: อนุกรมเวลา - ข้อมูลที่เรียงตามลำดับเวลา

Transformer: โครงสร้างโครงข่ายประสาทเทียมที่ใช้กลไก Attention

TypeScript: ภาษาโปรแกรมที่เป็น Superset ของ JavaScript

Underfitting: การเรียนรู้ไม่เพียงพอ - ปัญหาที่โมเดลไม่สามารถเรียนรู้รูปแบบของข้อมูลได้ดีพอ

XGBoost (eXtreme Gradient Boosting): การเพิ่มประสิทธิภาพแบบไล่ระดับขั้นสูง - อัลกอริทึม Machine Learning ที่เป็นการพัฒนาต่อจาก Gradient Boosting



ภาคผนวก ซ: เอกสารอ้างอิง

ซ.1 หนังสือและตำรา

1. Hastie, T., Tibshirani, R., & Friedman, J. (2009). The Elements of Statistical Learning: Data Mining, Inference, and Prediction (2nd ed.). Springer.

2. Géron, A. (2019). Hands-On Machine Learning with Scikit-Learn, Keras, and TensorFlow (2nd ed.). O'Reilly Media.

3. Goodfellow, I., Bengio, Y., & Courville, A. (2016). Deep Learning. MIT Press.

4. Sutton, R. S., & Barto, A. G. (2018). Reinforcement Learning: An Introduction (2nd ed.). MIT Press.

5. Molnar, C. (2022). Interpretable Machine Learning: A Guide for Making Black Box Models Explainable. Lulu.com.

6. Hyndman, R. J., & Athanasopoulos, G. (2021). Forecasting: Principles and Practice (3rd ed.). OTexts.

ซ.2 บทความวิจัย

1. Chen, T., & Guestrin, C. (2016). XGBoost: A Scalable Tree Boosting System. Proceedings of the 22nd ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, 785-794.

2. Lundberg, S. M., & Lee, S. I. (2017). A Unified Approach to Interpreting Model Predictions. Advances in Neural Information Processing Systems, 30, 4765-4774.

3. Ribeiro, M. T., Singh, S., & Guestrin, C. (2016). "Why Should I Trust You?": Explaining the Predictions of Any Classifier. Proceedings of the 22nd ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, 1135-1144.

4. Agrawal, S., & Goyal, N. (2012). Analysis of Thompson Sampling for the Multi-armed Bandit Problem. Proceedings of the 25th Annual Conference on Learning Theory, 39.1-39.26.

5. Kaufmann, E., Cappé, O., & Garivier, A. (2016). On the Complexity of Best-Arm Identification in Multi-Armed Bandit Models. Journal of Machine Learning Research, 17(1), 1-42.

ซ.3 เอกสารออนไลน์และเว็บไซต์

1. Scikit-learn Documentation. (2024). Retrieved from https://scikit-learn.org/stable/

2. FastAPI Documentation. (2024). Retrieved from https://fastapi.tiangolo.com/

3. React Documentation. (2024). Retrieved from https://react.dev/

4. Kaggle. (2024). Machine Learning Tutorials and Competitions. Retrieved from https://www.kaggle.com/

5. Towards Data Science. (2024). Medium Publication on Data Science and Machine Learning. Retrieved from https://towardsdatascience.com/

6. กรมอุตุนิยมวิทยา. (2024). ข้อมูลสภาพอากาศ. สืบค้นจาก https://www.tmd.go.th/

7. กระทรวงพาณิชย์. (2024). ข้อมูลราคาสินค้าเกษตร. สืบค้นจาก https://www.moc.go.th/

8. สำนักงานเศรษฐกิจการเกษตร. (2024). สถิติการเกษตร. สืบค้นจาก https://www.oae.go.th/

ซ.4 เครื่องมือและไลบรารี

1. Python Software Foundation. (2024). Python Programming Language. Retrieved from https://www.python.org/

2. NumPy Developers. (2024). NumPy: The Fundamental Package for Scientific Computing with Python. Retrieved from https://numpy.org/

3. pandas Development Team. (2024). pandas: Python Data Analysis Library. Retrieved from https://pandas.pydata.org/

4. Matplotlib Development Team. (2024). Matplotlib: Visualization with Python. Retrieved from https://matplotlib.org/

5. Seaborn Development Team. (2024). Seaborn: Statistical Data Visualization. Retrieved from https://seaborn.pydata.org/

6. PostgreSQL Global Development Group. (2024). PostgreSQL: The World's Most Advanced Open Source Relational Database. Retrieved from https://www.postgresql.org/

7. GitHub, Inc. (2024). GitHub: Where the World Builds Software. Retrieved from https://github.com/

8. Render. (2024). Render: Cloud Application Hosting for Developers. Retrieved from https://render.com/

ซ.5 มาตรฐานและแนวทางปฏิบัติ

1. ISO/IEC 25010:2011. Systems and Software Engineering - Systems and Software Quality Requirements and Evaluation (SQuaRE) - System and Software Quality Models.

2. IEEE 730-2014. IEEE Standard for Software Quality Assurance Processes.

3. W3C. (2024). Web Content Accessibility Guidelines (WCAG) 2.1. Retrieved from https://www.w3.org/WAI/WCAG21/quickref/

4. OWASP. (2024). OWASP Top Ten Web Application Security Risks. Retrieved from https://owasp.org/www-project-top-ten/

ซ.6 งานวิจัยที่เกี่ยวข้องในประเทศไทย

1. มหาวิทยาลัยเกษตรศาสตร์. (2023). การประยุกต์ใช้ปัญญาประดิษฐ์ในภาคการเกษตรไทย. วารสารวิจัยและพัฒนา มก., 46(2), 123-145.

2. สถาบันวิจัยและพัฒนาพื้นที่สูง. (2022). ระบบสนับสนุนการตัดสินใจสำหรับเกษตรกรในพื้นที่สูง. รายงานการวิจัย.

3. สำนักงานพัฒนาวิทยาศาสตร์และเทคโนโลยีแห่งชาติ (สวทช.). (2023). เทคโนโลยีดิจิทัลเพื่อการเกษตรอัจฉริยะ. รายงานประจำปี.

4. มหาวิทยาลัยเชียงใหม่. (2022). การพยากรณ์ราคาสินค้าเกษตรด้วย Machine Learning. วารสารวิทยาศาสตร์และเทคโนโลยี มช., 41(3), 234-256.

5. จุฬาลงกรณ์มหาวิทยาลัย. (2023). ระบบแนะนำพืชเศรษฐกิจสำหรับเกษตรกรไทย. วารสารวิศวกรรมศาสตร์ จุฬาฯ, 35(1), 45-67.



ภาคผนวก ฌ: ภาพหน้าจอและผังงาน

ฌ.1 ภาพหน้าจอระบบ

[หมายเหตุ: ในเอกสารฉบับสมบูรณ์ควรมีภาพหน้าจอจริงของระบบ]

1. หน้าแรก (Landing Page):
   - แสดงภาพรวมของระบบ Farmme
   - ปุ่มเข้าสู่ระบบและลงทะเบียน
   - คำอธิบายคุณสมบัติหลักของระบบ

2. หน้าลงทะเบียน (Registration Page):
   - ฟอร์มกรอกข้อมูลผู้ใช้
   - ข้อมูลฟาร์มและพื้นที่เพาะปลูก
   - การยืนยันตัวตนผ่านอีเมล

3. หน้าหลัก (Dashboard):
   - แสดงภาพรวมของฟาร์ม
   - สถิติการเพาะปลูก
   - การแจ้งเตือนสำคัญ
   - เมนูเข้าถึงโมเดลทั้ง 4 ตัว

4. หน้า Model A (ระบบแนะนำพืช):
   - ฟอร์มกรอกข้อมูลพื้นฐาน (จังหวัด, งบประมาณ, ความเสี่ยง)
   - ตารางแสดงพืชที่แนะนำพร้อม ROI ที่คาดการณ์
   - กราฟเปรียบเทียบพืชต่างๆ
   - คำอธิบายเหตุผลของการแนะนำ

5. หน้า Model B (ระบบพยากรณ์ช่วงเวลาปลูก):
   - เลือกพืชและจังหวัด
   - แสดงปฏิทินช่วงเวลาที่เหมาะสม
   - ข้อมูลสภาพอากาศพยากรณ์
   - คำแนะนำและความเสี่ยง

6. หน้า Model C (ระบบพยากรณ์ราคา):
   - เลือกพืชและระยะเวลาพยากรณ์
   - กราฟแสดงราคาในอดีตและราคาพยากรณ์
   - ช่วงความเชื่อมั่นของราคา
   - แนวโน้มและคำแนะนำ

7. หน้า Model D (ระบบตัดสินใจเก็บเกี่ยว):
   - กรอกข้อมูลการปลูกและราคาปัจจุบัน
   - แสดงทางเลือกการเก็บเกี่ยว (ทันที, รอ 7 วัน, รอ 14 วัน)
   - เปรียบเทียบกำไรที่คาดการณ์
   - คำแนะนำและความเสี่ยง

8. หน้าประวัติการใช้งาน (History):
   - บันทึกการใช้งานโมเดลทั้งหมด
   - ผลลัพธ์ที่ได้รับ
   - การเปรียบเทียบระหว่างคำแนะนำและผลจริง

9. หน้าโปรไฟล์ (Profile):
   - ข้อมูลผู้ใช้
   - ข้อมูลฟาร์ม
   - การตั้งค่าระบบ

ฌ.2 ผังงานระบบ (System Architecture Diagram)

[หมายเหตุ: ในเอกสารฉบับสมบูรณ์ควรมีผังงานจริง]

1. ผังงานสถาปัตยกรรมโดยรวม:
   - แสดงความสัมพันธ์ระหว่าง Frontend, Backend, Database และ Model Storage
   - แสดงการไหลของข้อมูล
   - แสดงการเชื่อมต่อกับ External APIs

2. ผังงาน Data Flow:
   - แสดงการไหลของข้อมูลตั้งแต่ผู้ใช้กรอกข้อมูล
   - ผ่านการประมวลผลใน Backend
   - การเรียกใช้โมเดล
   - การส่งผลลัพธ์กลับไปยังผู้ใช้

3. ผังงาน Model Pipeline:
   - แสดงขั้นตอนการทำงานของโมเดลแต่ละตัว
   - การเตรียมข้อมูล (Data Preprocessing)
   - การทำนาย (Prediction)
   - การอธิบายผลลัพธ์ (Explanation)

4. ผังงาน Database Schema:
   - แสดงโครงสร้างตารางในฐานข้อมูล
   - ความสัมพันธ์ระหว่างตาราง (Relationships)
   - Primary Keys และ Foreign Keys

5. ผังงาน User Journey:
   - แสดงเส้นทางการใช้งานของผู้ใช้
   - ตั้งแต่การลงทะเบียน
   - การใช้งานโมเดลต่างๆ
   - การติดตามผลและให้ Feedback

ฌ.3 ผังงานอัลกอริทึม (Algorithm Flowchart)

[หมายเหตุ: ในเอกสารฉบับสมบูรณ์ควรมีผังงานจริง]

1. ผังงาน Model A (Crop Recommendation):
   - รับข้อมูลจากผู้ใช้
   - ดึงข้อมูลสภาพอากาศและราคา
   - คำนวณ Features
   - ทำนาย ROI สำหรับพืชทั้งหมด
   - จัดอันดับและคัดเลือกพืชที่แนะนำ
   - คำนวณ SHAP Values สำหรับอธิบาย
   - ส่งผลลัพธ์กลับไปยังผู้ใช้

2. ผังงาน Model B (Planting Time Prediction):
   - รับข้อมูลพืชและจังหวัด
   - ดึงข้อมูลพยากรณ์อากาศ
   - คำนวณ Features
   - ทำนายความเหมาะสมของช่วงเวลา
   - ระบุช่วงเวลาที่แนะนำ
   - ประเมินความเสี่ยง
   - ส่งผลลัพธ์กลับไปยังผู้ใช้

3. ผังงาน Model C (Price Forecasting):
   - รับข้อมูลพืชและระยะเวลาพยากรณ์
   - ดึงข้อมูลราคาในอดีต
   - คำนวณ Lag Features และ Rolling Statistics
   - ระบุกลุ่มราคาของพืช
   - เลือกโมเดลที่เหมาะสม
   - ทำนายราคาในอนาคต
   - คำนวณช่วงความเชื่อมั่น
   - ส่งผลลัพธ์กลับไปยังผู้ใช้

4. ผังงาน Model D (Harvest Decision):
   - รับข้อมูลการปลูกและราคาปัจจุบัน
   - ดึงข้อมูลพยากรณ์ราคาจาก Model C
   - สุ่มตัวอย่างจาก Beta Distribution ของแต่ละทางเลือก
   - เลือกทางเลือกที่มีค่าสุ่มสูงสุด
   - คำนวณกำไรที่คาดการณ์สำหรับแต่ละทางเลือก
   - ประเมินความเสี่ยง
   - ส่งผลลัพธ์กลับไปยังผู้ใช้
   - รอรับ Feedback เพื่ออัปเดต Beta Distribution



ภาคผนวก ญ: ตัวอย่างโค้ดสำคัญ

ญ.1 ตัวอย่างโค้ด Model A (Crop Recommendation)

```python
import pandas as pd
import numpy as np
from sklearn.ensemble import GradientBoostingRegressor
from sklearn.model_selection import TimeSeriesSplit
from sklearn.metrics import r2_score, mean_absolute_error
import shap

class CropRecommendationModel:
    def __init__(self):
        self.model = GradientBoostingRegressor(
            n_estimators=200,
            learning_rate=0.1,
            max_depth=5,
            min_samples_split=10,
            min_samples_leaf=4,
            subsample=0.8,
            random_state=42
        )
        self.feature_names = None
        self.explainer = None
    
    def prepare_features(self, df):
        """เตรียมคุณลักษณะสำหรับการทำนาย"""
        features = df.copy()
        
        # คุณลักษณะพื้นฐาน
        features['expected_yield'] = df['expected_yield']
        features['investment_cost'] = df['investment_cost']
        features['avg_price'] = df['avg_price']
        
        # คุณลักษณะสภาพอากาศ
        features['avg_temperature'] = df['avg_temperature']
        features['total_rainfall'] = df['total_rainfall']
        features['avg_humidity'] = df['avg_humidity']
        
        # คุณลักษณะตามฤดูกาล
        features['month'] = df['month']
        features['quarter'] = df['quarter']
        features['season'] = df['season']
        
        # One-hot encoding สำหรับตัวแปรหมวดหมู่
        features = pd.get_dummies(features, columns=['crop', 'province', 'season'])
        
        return features
    
    def train(self, X_train, y_train, X_val, y_val):
        """ฝึกโมเดล"""
        self.feature_names = X_train.columns.tolist()
        
        # ฝึกโมเดล
        self.model.fit(X_train, y_train)
        
        # ประเมินประสิทธิภาพ
        train_pred = self.model.predict(X_train)
        val_pred = self.model.predict(X_val)
        
        train_r2 = r2_score(y_train, train_pred)
        val_r2 = r2_score(y_val, val_pred)
        val_mae = mean_absolute_error(y_val, val_pred)
        
        print(f"Train R²: {train_r2:.4f}")
        print(f"Validation R²: {val_r2:.4f}")
        print(f"Validation MAE: {val_mae:.2f}")
        print(f"Overfitting Gap: {(train_r2 - val_r2) * 100:.2f}%")
        
        # สร้าง SHAP Explainer
        self.explainer = shap.TreeExplainer(self.model)
        
        return self
    
    def predict(self, X):
        """ทำนาย ROI"""
        return self.model.predict(X)
    
    def explain(self, X):
        """อธิบายการทำนายด้วย SHAP"""
        shap_values = self.explainer.shap_values(X)
        return shap_values
    
    def recommend_crops(self, user_input, all_crops_data):
        """แนะนำพืชที่เหมาะสม"""
        # เตรียมข้อมูลสำหรับพืชทั้งหมด
        X = self.prepare_features(all_crops_data)
        
        # ทำนาย ROI
        predictions = self.predict(X)
        
        # เพิ่มคอลัมน์ ROI ที่ทำนาย
        all_crops_data['predicted_roi'] = predictions
        
        # จัดอันดับตาม ROI
        recommendations = all_crops_data.sort_values('predicted_roi', ascending=False)
        
        # คำนวณ SHAP Values สำหรับพืชที่แนะนำ
        top_crops = recommendations.head(5)
        shap_values = self.explain(X.loc[top_crops.index])
        
        # สร้างผลลัพธ์
        results = []
        for idx, (_, crop) in enumerate(top_crops.iterrows()):
            result = {
                'rank': idx + 1,
                'crop': crop['crop'],
                'predicted_roi': crop['predicted_roi'],
                'expected_yield': crop['expected_yield'],
                'investment_cost': crop['investment_cost'],
                'explanation': self._format_explanation(shap_values[idx])
            }
            results.append(result)
        
        return results
    
    def _format_explanation(self, shap_values):
        """จัดรูปแบบคำอธิบาย"""
        # หา Feature ที่มีผลกระทบมากที่สุด
        feature_importance = pd.DataFrame({
            'feature': self.feature_names,
            'importance': np.abs(shap_values)
        }).sort_values('importance', ascending=False).head(3)
        
        return feature_importance.to_dict('records')

# ตัวอย่างการใช้งาน
if __name__ == "__main__":
    # โหลดข้อมูล
    df = pd.read_csv('crop_data.csv')
    
    # แบ่งข้อมูลตามเวลา
    train_size = int(len(df) * 0.7)
    val_size = int(len(df) * 0.15)
    
    train_data = df[:train_size]
    val_data = df[train_size:train_size+val_size]
    test_data = df[train_size+val_size:]
    
    # เตรียม Features และ Target
    model = CropRecommendationModel()
    X_train = model.prepare_features(train_data.drop('roi', axis=1))
    y_train = train_data['roi']
    X_val = model.prepare_features(val_data.drop('roi', axis=1))
    y_val = val_data['roi']
    
    # ฝึกโมเดล
    model.train(X_train, y_train, X_val, y_val)
    
    # บันทึกโมเดล
    import pickle
    with open('model_a.pkl', 'wb') as f:
        pickle.dump(model, f)
```


ญ.2 ตัวอย่างโค้ด Model C (Price Forecasting) - การป้องกัน Data Leakage

```python
import pandas as pd
import numpy as np
from sklearn.ensemble import GradientBoostingRegressor

class PriceForecastingModel:
    def __init__(self):
        self.models = {
            'low': None,    # พืชราคาต่ำ (0-20 บาท/กก.)
            'medium': None, # พืชราคากลาง (20-50 บาท/กก.)
            'high': None    # พืชราคาสูง (>50 บาท/กก.)
        }
    
    def create_lag_features(self, df, target_col='price', lags=[1, 7, 30]):
        """สร้าง Lag Features โดยป้องกัน Data Leakage"""
        df = df.copy()
        
        # สร้าง Lag Features
        for lag in lags:
            df[f'{target_col}_lag_{lag}'] = df[target_col].shift(lag)
        
        return df
    
    def create_rolling_features(self, df, target_col='price', windows=[7, 14, 30]):
        """สร้าง Rolling Statistics โดยป้องกัน Data Leakage"""
        df = df.copy()
        
        for window in windows:
            # ใช้ shift(1) เพื่อไม่รวมค่าปัจจุบัน
            df[f'{target_col}_rolling_mean_{window}'] = (
                df[target_col].shift(1).rolling(window=window).mean()
            )
            df[f'{target_col}_rolling_std_{window}'] = (
                df[target_col].shift(1).rolling(window=window).std()
            )
            df[f'{target_col}_rolling_min_{window}'] = (
                df[target_col].shift(1).rolling(window=window).min()
            )
            df[f'{target_col}_rolling_max_{window}'] = (
                df[target_col].shift(1).rolling(window=window).max()
            )
        
        return df
    
    def prepare_features(self, df):
        """เตรียมคุณลักษณะทั้งหมด"""
        df = df.copy()
        
        # สร้าง Lag Features
        df = self.create_lag_features(df, lags=[1, 7, 30])
        
        # สร้าง Rolling Features
        df = self.create_rolling_features(df, windows=[7, 14, 30])
        
        # เพิ่มคุณลักษณะสภาพอากาศ
        # (ใช้เฉพาะข้อมูลที่มีก่อนวันที่ทำนาย)
        df['temperature'] = df['temperature']
        df['rainfall'] = df['rainfall']
        df['humidity'] = df['humidity']
        
        # เพิ่มคุณลักษณะตามฤดูกาล
        df['month'] = pd.to_datetime(df['date']).dt.month
        df['quarter'] = pd.to_datetime(df['date']).dt.quarter
        df['day_of_week'] = pd.to_datetime(df['date']).dt.dayofweek
        
        # ลบแถวที่มีค่า NaN (จากการสร้าง Lag และ Rolling Features)
        df = df.dropna()
        
        return df
    
    def check_data_leakage(self, df, target_col='price'):
        """ตรวจสอบ Data Leakage"""
        # คำนวณ Correlation Matrix
        corr_matrix = df.corr()
        
        # ตรวจสอบ Correlation กับเป้าหมาย
        target_corr = corr_matrix[target_col].sort_values(ascending=False)
        
        # ตรวจสอบว่ามีคุณลักษณะใดที่มี Correlation สูงผิดปกติ (>0.95)
        high_corr = target_corr[target_corr > 0.95]
        
        if len(high_corr) > 1:  # มากกว่า 1 เพราะเป้าหมายจะมี Correlation 1.0 กับตัวเอง
            print("⚠️ Warning: Possible data leakage detected!")
            print("Features with high correlation (>0.95):")
            print(high_corr)
            return False
        
        print("✓ No data leakage detected")
        return True
    
    def temporal_train_test_split(self, df, train_ratio=0.7, val_ratio=0.15):
        """แบ่งข้อมูลตามลำดับเวลา"""
        # เรียงข้อมูลตามวันที่
        df = df.sort_values('date')
        
        # คำนวณขนาดของแต่ละชุด
        n = len(df)
        train_size = int(n * train_ratio)
        val_size = int(n * val_ratio)
        
        # แบ่งข้อมูล
        train_data = df[:train_size]
        val_data = df[train_size:train_size+val_size]
        test_data = df[train_size+val_size:]
        
        # ตรวจสอบว่าไม่มีข้อมูลซ้ำซ้อน
        train_dates = set(train_data['date'])
        val_dates = set(val_data['date'])
        test_dates = set(test_data['date'])
        
        assert len(train_dates & val_dates) == 0, "Data leakage: Train and Val overlap"
        assert len(train_dates & test_dates) == 0, "Data leakage: Train and Test overlap"
        assert len(val_dates & test_dates) == 0, "Data leakage: Val and Test overlap"
        
        print(f"Train: {len(train_data)} samples ({train_data['date'].min()} to {train_data['date'].max()})")
        print(f"Val: {len(val_data)} samples ({val_data['date'].min()} to {val_data['date'].max()})")
        print(f"Test: {len(test_data)} samples ({test_data['date'].min()} to {test_data['date'].max()})")
        
        return train_data, val_data, test_data
    
    def classify_price_category(self, price):
        """จำแนกกลุ่มราคา"""
        if price <= 20:
            return 'low'
        elif price <= 50:
            return 'medium'
        else:
            return 'high'
    
    def train(self, df):
        """ฝึกโมเดลแบบ Stratified"""
        # เตรียมคุณลักษณะ
        df = self.prepare_features(df)
        
        # ตรวจสอบ Data Leakage
        self.check_data_leakage(df)
        
        # แบ่งข้อมูลตามเวลา
        train_data, val_data, test_data = self.temporal_train_test_split(df)
        
        # จำแนกกลุ่มราคา
        train_data['price_category'] = train_data['price'].apply(self.classify_price_category)
        
        # ฝึกโมเดลแยกสำหรับแต่ละกลุ่ม
        for category in ['low', 'medium', 'high']:
            print(f"\nTraining model for {category} price category...")
            
            # กรองข้อมูลตามกลุ่ม
            category_data = train_data[train_data['price_category'] == category]
            
            if len(category_data) == 0:
                print(f"No data for {category} category, skipping...")
                continue
            
            # เตรียม Features และ Target
            feature_cols = [col for col in category_data.columns 
                          if col not in ['date', 'price', 'price_category', 'crop']]
            X_train = category_data[feature_cols]
            y_train = category_data['price']
            
            # สร้างและฝึกโมเดล
            model = GradientBoostingRegressor(
                n_estimators=200,
                learning_rate=0.05,
                max_depth=4,
                min_samples_split=10,
                subsample=0.8,
                random_state=42
            )
            model.fit(X_train, y_train)
            
            self.models[category] = model
            
            # ประเมินประสิทธิภาพ
            train_pred = model.predict(X_train)
            train_r2 = r2_score(y_train, train_pred)
            train_mae = mean_absolute_error(y_train, train_pred)
            
            print(f"{category.capitalize()} - Train R²: {train_r2:.4f}, MAE: {train_mae:.2f}")
        
        return self

# ตัวอย่างการใช้งาน
if __name__ == "__main__":
    # โหลดข้อมูล
    df = pd.read_csv('price_data.csv')
    
    # สร้างและฝึกโมเดล
    model = PriceForecastingModel()
    model.train(df)
    
    # บันทึกโมเดล
    import pickle
    with open('model_c.pkl', 'wb') as f:
        pickle.dump(model, f)
```


ญ.3 ตัวอย่างโค้ด Model D (Harvest Decision - Thompson Sampling)

```python
import numpy as np
from scipy.stats import beta

class ThompsonSamplingHarvestDecision:
    def __init__(self, n_arms=3):
        """
        n_arms: จำนวนทางเลือก (3 = เก็บเกี่ยวทันที, รอ 7 วัน, รอ 14 วัน)
        """
        self.n_arms = n_arms
        # เริ่มต้นด้วย Beta(1, 1) สำหรับแต่ละทางเลือก
        self.alpha = np.ones(n_arms)
        self.beta_params = np.ones(n_arms)
        self.arm_names = ['harvest_now', 'wait_7_days', 'wait_14_days']
    
    def select_arm(self):
        """เลือกทางเลือกโดยใช้ Thompson Sampling"""
        # สุ่มตัวอย่างจาก Beta Distribution ของแต่ละทางเลือก
        samples = [
            beta.rvs(self.alpha[i], self.beta_params[i])
            for i in range(self.n_arms)
        ]
        
        # เลือกทางเลือกที่มีค่าสุ่มสูงสุด
        selected_arm = np.argmax(samples)
        
        return selected_arm, self.arm_names[selected_arm]
    
    def update(self, arm, reward):
        """
        อัปเดต Beta Distribution หลังจากได้รับ Reward
        
        Parameters:
        - arm: ทางเลือกที่เลือก (0, 1, หรือ 2)
        - reward: ผลตอบแทนที่ได้รับ (0-1, โดย 1 = ดีที่สุด)
        """
        # อัปเดต Alpha และ Beta
        self.alpha[arm] += reward
        self.beta_params[arm] += (1 - reward)
    
    def calculate_profit(self, current_price, expected_yield, 
                        storage_cost_per_day, quality_degradation_rate,
                        price_forecast_7d, price_forecast_14d):
        """
        คำนวณกำไรที่คาดการณ์สำหรับแต่ละทางเลือก
        
        Parameters:
        - current_price: ราคาปัจจุบัน (บาท/กก.)
        - expected_yield: ผลผลิตที่คาดหวัง (กก.)
        - storage_cost_per_day: ต้นทุนการเก็บรักษาต่อวัน (บาท)
        - quality_degradation_rate: อัตราการลดลงของคุณภาพต่อวัน (0-1)
        - price_forecast_7d: ราคาพยากรณ์ 7 วัน (บาท/กก.)
        - price_forecast_14d: ราคาพยากรณ์ 14 วัน (บาท/กก.)
        
        Returns:
        - profits: กำไรที่คาดการณ์สำหรับแต่ละทางเลือก
        """
        profits = []
        
        # ทางเลือก 1: เก็บเกี่ยวทันที
        profit_now = current_price * expected_yield
        profits.append(profit_now)
        
        # ทางเลือก 2: รอ 7 วัน
        quality_7d = 1 - (quality_degradation_rate * 7)
        storage_cost_7d = storage_cost_per_day * 7
        profit_7d = (price_forecast_7d * expected_yield * quality_7d) - storage_cost_7d
        profits.append(profit_7d)
        
        # ทางเลือก 3: รอ 14 วัน
        quality_14d = 1 - (quality_degradation_rate * 14)
        storage_cost_14d = storage_cost_per_day * 14
        profit_14d = (price_forecast_14d * expected_yield * quality_14d) - storage_cost_14d
        profits.append(profit_14d)
        
        return profits
    
    def make_decision(self, current_price, expected_yield,
                     storage_cost_per_day, quality_degradation_rate,
                     price_forecast_7d, price_forecast_14d):
        """
        ตัดสินใจเวลาเก็บเกี่ยว
        
        Returns:
        - decision: ทางเลือกที่แนะนำ
        - profits: กำไรที่คาดการณ์สำห���ับแต่ละทางเลือก
        - confidence: ความเชื่อมั่นในการตัดสินใจ
        """
        # คำนวณกำไรที่คาดการณ์
        profits = self.calculate_profit(
            current_price, expected_yield,
            storage_cost_per_day, quality_degradation_rate,
            price_forecast_7d, price_forecast_14d
        )
        
        # เลือกทางเลือกโดยใช้ Thompson Sampling
        arm_idx, arm_name = self.select_arm()
        
        # คำนวณความเชื่อมั่น (ใช้ค่าเฉลี่ยของ Beta Distribution)
        confidence = self.alpha[arm_idx] / (self.alpha[arm_idx] + self.beta_params[arm_idx])
        
        # สร้างผลลัพธ์
        result = {
            'recommended_action': arm_name,
            'confidence': confidence,
            'expected_profit': {
                'harvest_now': profits[0],
                'wait_7_days': profits[1],
                'wait_14_days': profits[2]
            },
            'profit_comparison': {
                'wait_7_days_vs_now': f"{((profits[1] - profits[0]) / profits[0] * 100):.1f}%",
                'wait_14_days_vs_now': f"{((profits[2] - profits[0]) / profits[0] * 100):.1f}%"
            },
            'thompson_sampling_state': {
                'harvest_now': {'alpha': self.alpha[0], 'beta': self.beta_params[0]},
                'wait_7_days': {'alpha': self.alpha[1], 'beta': self.beta_params[1]},
                'wait_14_days': {'alpha': self.alpha[2], 'beta': self.beta_params[2]}
            }
        }
        
        return result
    
    def evaluate_performance(self, decisions, actual_profits):
        """
        ประเมินประสิทธิภาพของโมเดล
        
        Parameters:
        - decisions: รายการทางเลือกที่เลือก
        - actual_profits: รายการกำไรจริงสำหรับแต่ละทางเลือก
        
        Returns:
        - metrics: ตัวชี้วัดประสิทธิภาพ
        """
        total_profit = 0
        max_possible_profit = 0
        correct_decisions = 0
        
        for i, (decision, profits) in enumerate(zip(decisions, actual_profits)):
            # กำไรที่ได้จริง
            actual_profit = profits[decision]
            total_profit += actual_profit
            
            # กำไรสูงสุดที่เป็นไปได้
            max_profit = max(profits)
            max_possible_profit += max_profit
            
            # ตรวจสอบว่าเลือกทางเลือกที่ดีที่สุดหรือไม่
            if actual_profit == max_profit:
                correct_decisions += 1
        
        # คำนวณตัวชี้วัด
        decision_accuracy = correct_decisions / len(decisions)
        profit_efficiency = total_profit / max_possible_profit
        regret = max_possible_profit - total_profit
        regret_rate = regret / max_possible_profit
        
        metrics = {
            'decision_accuracy': decision_accuracy,
            'profit_efficiency': profit_efficiency,
            'total_profit': total_profit,
            'max_possible_profit': max_possible_profit,
            'regret': regret,
            'regret_rate': regret_rate
        }
        
        return metrics

# ตัวอย่างการใช้งาน
if __name__ == "__main__":
    # สร้างโมเดล
    model = ThompsonSamplingHarvestDecision(n_arms=3)
    
    # ตัวอย่างการตัดสินใจ
    decision = model.make_decision(
        current_price=16.20,
        expected_yield=1200,
        storage_cost_per_day=50,
        quality_degradation_rate=0.01,
        price_forecast_7d=17.50,
        price_forecast_14d=17.20
    )
    
    print("Decision:", decision['recommended_action'])
    print("Confidence:", decision['confidence'])
    print("Expected Profits:", decision['expected_profit'])
    
    # สมมติว่าได้รับ Feedback จากผู้ใช้
    # (ในการใช้งานจริง จะได้รับหลังจากเกษตรกรเก็บเกี่ยวและขายแล้ว)
    actual_profit = 21360  # กำไรจริงที่ได้รับ
    max_possible_profit = 21360  # กำไรสูงสุดที่เป็นไปได้
    reward = actual_profit / max_possible_profit  # Normalize เป็น 0-1
    
    # อัปเดตโมเดล
    arm_idx = model.arm_names.index(decision['recommended_action'])
    model.update(arm_idx, reward)
    
    # บันทึกโมเดล
    import pickle
    with open('model_d.pkl', 'wb') as f:
        pickle.dump(model, f)
```

---

สิ้นสุดภาคผนวก

